-- Copyright 2011-12 Paul Kulchenko, ZeroBrane LLC
-- Created by Danny Boisvert (derived from love2d.lua)

--[[

*** For getting the precompiled binaries ***

[Binaries]
- http://sourceforge.net/projects/urho3d/files/Urho3D/
  Download the STATIC package for your target operating system.
  The Urho3D executable will be located in "./bin/"

[Setup]
- Make Urho3D executable available in PATH or put it into one of the default folders: "C:\Program Files\Urho3D" or "D:\Program Files\Urho3D" on Windows or "/Applications" on Mac OS X;
- Switch to urho3d interpreter by going to "Project | Lua Interpreter | Urho3D";
- Set the project directory to Urho3D samples by going to "Project | Project Directory | Choose...";
  - "(Urho3D Root Path)\share\Urho3D\Resources\Data\LuaScripts" on Windows or "(Urho3D Root Path)/share/Urho3D/Resources/Data/LuaScripts" on Mac OS X or Linux
- Open any of the found scripts in the project tab;
- Run the script

*** For generating a new Urho3D API file ***

[Prerequisite]
- CMake 2.8+;
- Compatible compiler for Urho3D (see their Readme file);
- Doxygen (Added in your PATH)

[Process]
- Get the desired version on "http://github.com/urho3d/Urho3D" and "Download Zip";
- Extract and build it with the "-DURHO3D_LUA=1" or "-DURHO3D_LUAJIT=1" and "-DURHO3D_DOCS=1";
- When done, insinuating that you're in the "Build" folder:
	cd ../Source/Urho3D/LuaScript/pkgs/
	<path/to/build-tree>/bin/tool/tolua++ -L ToZerobraneStudioHook.lua -P -o ../../../../Docs/urho3d.lua <path/to/build-tree>/bin/tool/LuaPkgToDox.txt
  (Change slashes side for Windows)
- The API file will be in the "Docs" folder named "urho3d.lua";
- Add the API in ZeroBraneStudio,
  Using the package file (./package/urho3d.lua):
    - Copy the content of the generated file and replace "local api = {...}" with it;
  Using the API file (./api/lua/urho3d.lua):
    - Copy and replace the file in your API folder

*** Other useful information ***

[Additional information]
- We suggest to add "arg.urho3dArgs = '-w -x 1024 -y 768'" or any other prefered resolution
  in your "user.lua" configuration for setting as window mode
- you can also add "path.urho3d = 'yourUrhoBinaryFullname'" and "arg.urho3dScript = scriptFilename" to specify startup behavior
--]]

local urho3d
local win = ide.osname == "Windows"
local mac = ide.osname == "Macintosh"

local interpreter = {
  name = "Urho3D",
  description = "Urho3D game engine",
  api = {"baselib", "urho3d"},
  frun = function(self,wfilename,rundebug)
    urho3d = urho3d or ide.config.path.urho3d -- check if the path is configured
    if not urho3d then
      local sep = win and ';' or ':'
      local default =
           win and (GenerateProgramFilesPath('urho3d', sep)..sep)
        or mac and ('/Applications/urho3d.app/Contents/MacOS'..sep)
        or ''
      local path = default
                 ..(os.getenv('PATH') or '')..sep
                 ..(GetPathWithSep(self:fworkdir(wfilename)))..sep
                 ..(os.getenv('HOME') and GetPathWithSep(os.getenv('HOME'))..'bin' or '')
      local paths = {}
      for p in path:gmatch("[^"..sep.."]+") do
        urho3d = urho3d or GetFullPathIfExists(p, win and 'Urho3DPlayer.exe' or 'Urho3DPlayer')
        table.insert(paths, p)
      end
      if not urho3d then
        ide:Print("Can't find urho3d executable in any of the following folders: "
          ..table.concat(paths, ", "))
        return
      end
    end

    if rundebug then
      DebuggerAttachDefault({runstart = ide.config.debugger.runonstart == true})
    end

	local scriptName = ide.config.arg.urho3dScript or wfilename:GetFullName()
    local params = ide.config.arg.any or ide.config.arg.urho3dArgs
    local cmd = ('"%s" "%s" %s'):format(urho3d, scriptName, params or "")
    -- CommandLineRun(cmd,wdir,tooutput,nohide,stringcallback,uid,endcallback)
    return CommandLineRun(cmd,self:fworkdir(wfilename),true,false,nil,nil,
      function() ide.debugger.pid = nil end)
  end,
  fprojdir = function(self,wfilename)
    return wfilename:GetPath(wx.wxPATH_GET_VOLUME)
  end,
  fworkdir = function(self,wfilename)
    return ide.config.path.projectdir or wfilename:GetPath(wx.wxPATH_GET_VOLUME)
  end,
  hasdebugger = true,
  fattachdebug = function(self) DebuggerAttachDefault() end,
  scratchextloop = true,
  takeparameters = true,
}

-- Urho3D API generated on 2017-04-23

local api = {

  -- Classes
  Animatable = {
    childs = {
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  AnimatedModel = {
    childs = {
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      AddAnimationState = {
        args = "(Animation* animation)",
        description = "Add an animation.",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      RemoveAnimationState = {
        args = "(Animation* animation)",
        description = "() RemoveAnimationState (const String animationName),\n() RemoveAnimationState (StringHash animationNameHash),\n() RemoveAnimationState (AnimationState* state),\n() RemoveAnimationState (unsigned index)\nRemove an animation by animation pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAllAnimationStates = {
        args = "()",
        description = "Remove all animations.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      SetUpdateInvisible = {
        args = "(bool enable)",
        description = "Set whether to update animation and the bounding box when not visible. Recommended to enable for physically controlled models like ragdolls.",
        returns = "()",
        type = "method"
      },
      SetMorphWeight = {
        args = "(const String name, float weight)",
        description = "() SetMorphWeight (StringHash nameHash, float weight),\n() SetMorphWeight (unsigned index, float weight)\nSet vertex morph weight by name.",
        returns = "()",
        type = "method"
      },
      ResetMorphWeights = {
        args = "()",
        description = "Reset all vertex morphs to zero.",
        returns = "()",
        type = "method"
      },
      GetSkeleton = {
        args = "()",
        description = "Return skeleton.",
        returns = "(Skeleton&)",
        valuetype = "Skeleton",
        type = "method"
      },
      GetNumAnimationStates = {
        args = "()",
        description = "Return number of animation states.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAnimationState = {
        args = "(Animation* animation)",
        description = "(AnimationState*) GetAnimationState (const String animationName),\n(AnimationState*) GetAnimationState (const StringHash animationNameHash),\n(AnimationState*) GetAnimationState (unsigned index)\nReturn animation state by animation pointer.",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetUpdateInvisible = {
        args = "()",
        description = "Return whether to update animation when not visible.",
        returns = "(bool)",
        type = "method"
      },
      GetNumMorphs = {
        args = "()",
        description = "Return number of vertex morphs.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMorphWeight = {
        args = "(const String name)",
        description = "(float) GetMorphWeight (StringHash nameHash),\n(float) GetMorphWeight (unsigned index)\nReturn vertex morph weight by name.",
        returns = "(float)",
        type = "method"
      },
      IsMaster = {
        args = "()",
        description = "Return whether is the master (first) animated model.",
        returns = "(bool)",
        type = "method"
      },
      UpdateBoneBoundingBox = {
        args = "()",
        description = "Recalculate the bone bounding box. Normally called internally, but can also be manually called if up-to-date information before rendering is necessary.",
        returns = "()",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*",
        type = "value"
      },
      skeleton = {
        valuetype = "Skeleton",
        description = "(Readonly) Skeleton&\nSkeleton.",
        type = "value"
      },
      numAnimationStates = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      updateInvisible = {
        description = "bool\nUpdate animation when invisible flag.",
        type = "value"
      },
      numMorphs = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      master = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  AnimatedSprite2D = {
    childs = {
      SetAnimationSet = {
        args = "(AnimationSet2D* animationSet)",
        description = "Set animation set.",
        returns = "()",
        type = "method"
      },
      SetEntity = {
        args = "(const String entity)",
        description = "Set entity name (skin name for spine, entity name for spriter).",
        returns = "()",
        type = "method"
      },
      SetAnimation = {
        args = "(const String name, LoopMode2D loopMode = LM_DEFAULT)",
        description = "Set animation by name and loop mode.",
        returns = "()",
        type = "method"
      },
      SetLoopMode = {
        args = "(LoopMode2D loopMode)",
        description = "Set loop mode.",
        returns = "()",
        type = "method"
      },
      SetSpeed = {
        args = "(float speed)",
        description = "Set speed.",
        returns = "()",
        type = "method"
      },
      GetAnimationSet = {
        args = "()",
        description = "Return animation.",
        returns = "(AnimationSet2D*)",
        valuetype = "AnimationSet2D",
        type = "method"
      },
      GetEntity = {
        args = "()",
        description = "Return entity name.",
        returns = "(const String)",
        type = "method"
      },
      GetAnimation = {
        args = "()",
        description = "Return animation name.",
        returns = "(const String)",
        type = "method"
      },
      GetLoopMode = {
        args = "()",
        description = "Return loop mode.",
        returns = "(LoopMode2D)",
        type = "method"
      },
      GetSpeed = {
        args = "()",
        description = "Return speed.",
        returns = "(float)",
        type = "method"
      },
      speed = {
        description = "float\nSpeed.",
        type = "value"
      },
      entity = {
        description = "String\nEntity name.",
        type = "value"
      },
      animation = {
        description = "String",
        type = "value"
      },
      animationSet = {
        valuetype = "AnimationSet2D",
        description = "AnimationSet2D*\nAnimation set.",
        type = "value"
      },
      loopMode = {
        description = "LoopMode2D\nLoop mode.",
        type = "value"
      },
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetFlip = {
        args = "(bool flipX, bool flipY)",
        description = "Set flip.",
        returns = "()",
        type = "method"
      },
      SetFlipX = {
        args = "(bool flipX)",
        description = "Set flip X.",
        returns = "()",
        type = "method"
      },
      SetFlipY = {
        args = "(bool flipY)",
        description = "Set flip Y.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color.",
        returns = "()",
        type = "method"
      },
      SetAlpha = {
        args = "(float alpha)",
        description = "Set alpha.",
        returns = "()",
        type = "method"
      },
      SetUseHotSpot = {
        args = "(bool useHotSpot)",
        description = "Set whether to use custom-defined hot spot.",
        returns = "()",
        type = "method"
      },
      SetHotSpot = {
        args = "(const Vector2& hotspot)",
        description = "Set hot spot.",
        returns = "()",
        type = "method"
      },
      SetUseDrawRect = {
        args = "(bool useDrawRect)",
        description = "Set whether to use custom-defined draw rectangle.",
        returns = "()",
        type = "method"
      },
      SetDrawRect = {
        args = "(const Rect& rect)",
        description = "Set draw rectangle.",
        returns = "()",
        type = "method"
      },
      SetUseTextureRect = {
        args = "(bool useTextureRect)",
        description = "Set whether to use custom-defined texture rectangle.",
        returns = "()",
        type = "method"
      },
      SetTextureRect = {
        args = "(const Rect& rect)",
        description = "Set texture rectangle.",
        returns = "()",
        type = "method"
      },
      SetCustomMaterial = {
        args = "(Material* customMaterial)",
        description = "Set custom material.",
        returns = "()",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetFlipX = {
        args = "()",
        description = "Return flip X.",
        returns = "(bool)",
        type = "method"
      },
      GetFlipY = {
        args = "()",
        description = "Return flip Y.",
        returns = "(bool)",
        type = "method"
      },
      GetColor = {
        args = "()",
        description = "Return color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetAlpha = {
        args = "()",
        description = "Return alpha.",
        returns = "(float)",
        type = "method"
      },
      GetUseHotSpot = {
        args = "()",
        description = "Return whether to use custom-defined hot spot.",
        returns = "(bool)",
        type = "method"
      },
      GetHotSpot = {
        args = "()",
        description = "Return hot spot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetUseDrawRect = {
        args = "()",
        description = "Return whether to use custom-defined draw rectangle.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawRect = {
        args = "()",
        description = "Return draw rect.",
        returns = "(const Rect&)",
        valuetype = "Rect",
        type = "method"
      },
      GetUseTextureRect = {
        args = "()",
        description = "Return whether to use custom-defined texture rectangle.",
        returns = "(bool)",
        type = "method"
      },
      GetTextureRect = {
        args = "()",
        description = "Return texture rect.",
        returns = "(const Rect&)",
        valuetype = "Rect",
        type = "method"
      },
      GetCustomMaterial = {
        args = "()",
        description = "Return custom material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      flipX = {
        description = "bool\nFlip X.",
        type = "value"
      },
      flipY = {
        description = "bool\nFlip Y.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColor.",
        type = "value"
      },
      alpha = {
        description = "float",
        type = "value"
      },
      useHotSpot = {
        description = "bool\nUse hot spot flag.",
        type = "value"
      },
      hotSpot = {
        description = "Vector2\nHot spot.",
        type = "value"
      },
      customMaterial = {
        valuetype = "Material",
        description = "Material*\nCustom material.",
        type = "value"
      },
      drawRect = {
        description = "Rect\nDraw rectangle.",
        type = "value"
      },
      useDrawRect = {
        description = "bool\nUse draw rectangle flag.",
        type = "value"
      },
      textureRect = {
        description = "Rect\nTexture rectangle.",
        type = "value"
      },
      useTextureRect = {
        description = "bool\nUse texture rectangle flag.",
        type = "value"
      },
      SetLayer = {
        args = "(int layer)",
        description = "Set layer.",
        returns = "()",
        type = "method"
      },
      SetOrderInLayer = {
        args = "(int orderInLayer)",
        description = "Set order in layer.",
        returns = "()",
        type = "method"
      },
      GetLayer = {
        args = "()",
        description = "Return layer.",
        returns = "(int)",
        type = "method"
      },
      GetOrderInLayer = {
        args = "()",
        description = "Return order in layer.",
        returns = "(int)",
        type = "method"
      },
      layer = {
        description = "int\nLayer.",
        type = "value"
      },
      orderInLayer = {
        description = "int\nOrder in layer.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Animation = {
    childs = {
      new = {
        args = "()",
        returns = "(Animation*)",
        valuetype = "Animation",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetAnimationName = {
        args = "(const String name)",
        description = "Set animation name.",
        returns = "()",
        type = "method"
      },
      SetLength = {
        args = "(float length)",
        description = "Set animation length.",
        returns = "()",
        type = "method"
      },
      CreateTrack = {
        args = "(const String name)",
        description = "Create and return a track by name. If track by same name already exists, returns the existing.",
        returns = "(AnimationTrack*)",
        valuetype = "AnimationTrack",
        type = "method"
      },
      RemoveTrack = {
        args = "(const String name)",
        description = "Remove a track by name. Return true if was found and removed successfully. This is unsafe if the animation is currently used in playback.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTracks = {
        args = "()",
        description = "Remove all tracks. This is unsafe if the animation is currently used in playback.",
        returns = "()",
        type = "method"
      },
      SetTrigger = {
        args = "(unsigned index, const AnimationTriggerPoint& trigger)",
        description = "Set a trigger point at index.",
        returns = "()",
        type = "method"
      },
      AddTrigger = {
        args = "(const AnimationTriggerPoint& trigger)",
        description = "() AddTrigger (float time, bool timeIsNormalized, const Variant& data)\nAdd a trigger point.",
        returns = "()",
        type = "method"
      },
      RemoveTrigger = {
        args = "(unsigned index)",
        description = "Remove a trigger point by index.",
        returns = "()",
        type = "method"
      },
      RemoveAllTriggers = {
        args = "()",
        description = "Remove all trigger points.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone the animation.",
        returns = "(Animation*)",
        valuetype = "Animation",
        type = "method"
      },
      GetAnimationName = {
        args = "()",
        description = "Return animation name.",
        returns = "(const String)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return animation length.",
        returns = "(float)",
        type = "method"
      },
      GetNumTracks = {
        args = "()",
        description = "Return number of animation tracks.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTrack = {
        args = "(const String name)",
        description = "(AnimationTrack*) GetTrack (StringHash nameHash),\n(AnimationTrack*) GetTrack (unsigned index)\nReturn animation track by name.",
        returns = "(AnimationTrack*)",
        valuetype = "AnimationTrack",
        type = "method"
      },
      GetNumTriggers = {
        args = "()",
        description = "Return number of animation trigger points.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTrigger = {
        args = "(unsigned index)",
        description = "Return a trigger point by index.",
        returns = "(AnimationTriggerPoint*)",
        valuetype = "AnimationTriggerPoint",
        type = "method"
      },
      animationName = {
        description = "String\nAnimation name.",
        type = "value"
      },
      length = {
        description = "float\nAnimation length.",
        type = "value"
      },
      numTracks = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numTriggers = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationControl = {
    childs = {
      new = {
        args = "()",
        returns = "(AnimationControl*)",
        valuetype = "AnimationControl",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      name = {
        description = "String",
        type = "value"
      },
      hash = {
        description = "StringHash",
        type = "value"
      },
      speed = {
        description = "float",
        type = "value"
      },
      targetWeight = {
        description = "float",
        type = "value"
      },
      fadeTime = {
        description = "float",
        type = "value"
      },
      autoFadeTime = {
        description = "float",
        type = "value"
      },
      removeOnCompletion = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationController = {
    childs = {
      Play = {
        args = "(const String name, char layer, bool looped, float fadeInTime = 0.0f)",
        returns = "(bool)",
        type = "method"
      },
      PlayExclusive = {
        args = "(const String name, char layer, bool looped, float fadeTime = 0.0f)",
        returns = "(bool)",
        type = "method"
      },
      Stop = {
        args = "(const String name, float fadeOutTime = 0.0f)",
        description = "Stop an animation. Zero fadetime is instant. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      StopLayer = {
        args = "(char layer, float fadeOutTime = 0.0f)",
        returns = "()",
        type = "method"
      },
      StopAll = {
        args = "(float fadeTime = 0.0f)",
        description = "Stop all animations. Zero fadetime is instant.",
        returns = "()",
        type = "method"
      },
      Fade = {
        args = "(const String name, float targetWeight, float fadeTime)",
        description = "Fade animation to target weight. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      FadeOthers = {
        args = "(const String name, float targetWeight, float fadeTime)",
        description = "Fade other animations on the same layer to target weight. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetLayer = {
        args = "(const String name, char layer)",
        returns = "(bool)",
        type = "method"
      },
      SetStartBone = {
        args = "(const String name, const String startBoneName)",
        description = "Set animation start bone. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetTime = {
        args = "(const String name, float time)",
        description = "Set animation time position. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetWeight = {
        args = "(const String name, float weight)",
        description = "Set animation weight. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetLooped = {
        args = "(const String name, bool enable)",
        description = "Set animation looping. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetBlendMode = {
        args = "(const String name, AnimationBlendMode mode)",
        description = "Set animation blending mode. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetSpeed = {
        args = "(const String name, float speed)",
        description = "Set animation speed. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetAutoFade = {
        args = "(const String name, float fadeOutTime)",
        description = "Set animation autofade at end (non-looped animations only.) Zero time disables. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      SetRemoveOnCompletion = {
        args = "(const String name, bool removeOnCompletion)",
        description = "Set whether an animation auto-removes on completion.",
        returns = "(bool)",
        type = "method"
      },
      IsPlaying = {
        args = "(const String name)",
        description = "(bool) IsPlaying (char layer)\nReturn whether an animation is active. Note that non-looping animations that are being clamped at the end also return true.",
        returns = "(bool)",
        type = "method"
      },
      IsFadingIn = {
        args = "(const String name)",
        description = "Return whether an animation is fading in.",
        returns = "(bool)",
        type = "method"
      },
      IsFadingOut = {
        args = "(const String name)",
        description = "Return whether an animation is fading out.",
        returns = "(bool)",
        type = "method"
      },
      IsAtEnd = {
        args = "(const String name)",
        description = "Return whether an animation is at its end. Will return false if the animation is not active at all.",
        returns = "(bool)",
        type = "method"
      },
      GetLayer = {
        args = "(const String name)",
        description = "Return animation blending layer.",
        returns = "(char)",
        type = "method"
      },
      GetStartBone = {
        args = "(const String name)",
        description = "Return animation start bone, or null if no such animation.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      GetStartBoneName = {
        args = "(const String name)",
        description = "Return animation start bone name, or empty string if no such animation.",
        returns = "(const String)",
        type = "method"
      },
      GetTime = {
        args = "(const String name)",
        description = "Return animation time position.",
        returns = "(float)",
        type = "method"
      },
      GetWeight = {
        args = "(const String name)",
        description = "Return animation weight.",
        returns = "(float)",
        type = "method"
      },
      IsLooped = {
        args = "(const String name)",
        description = "Return animation looping.",
        returns = "(bool)",
        type = "method"
      },
      GetBlendMode = {
        args = "(const String name)",
        description = "Return animation blending mode.",
        returns = "(AnimationBlendMode)",
        type = "method"
      },
      GetLength = {
        args = "(const String name)",
        description = "Return animation length.",
        returns = "(float)",
        type = "method"
      },
      GetSpeed = {
        args = "(const String name)",
        description = "Return animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetFadeTarget = {
        args = "(const String name)",
        description = "Return animation fade target weight.",
        returns = "(float)",
        type = "method"
      },
      GetFadeTime = {
        args = "(const String name)",
        description = "Return animation fade time.",
        returns = "(float)",
        type = "method"
      },
      GetAutoFade = {
        args = "(const String name)",
        description = "Return animation autofade time.",
        returns = "(float)",
        type = "method"
      },
      GetRemoveOnCompletion = {
        args = "(const String name)",
        description = "Return whether animation auto-removes on completion, or false if no such animation.",
        returns = "(bool)",
        type = "method"
      },
      GetAnimationState = {
        args = "(const String name)",
        description = "(AnimationState*) GetAnimationState (StringHash nameHash)\nFind an animation state by animation name.",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      GetAnimation = {
        args = "(unsigned index)",
        returns = "(const AnimationControl*)",
        valuetype = "AnimationControl",
        type = "method"
      },
      GetNumAnimations = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationKeyFrame = {
    childs = {
      time = {
        description = "float",
        type = "value"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      rotation = {
        description = "Quaternion",
        type = "value"
      },
      scale = {
        description = "Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationSet2D = {
    childs = {
      GetNumAnimations = {
        args = "()",
        description = "Get number of animations.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAnimation = {
        args = "(unsigned index)",
        description = "Return animation name.",
        returns = "(String)",
        type = "method"
      },
      numAnimations = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationState = {
    childs = {
      new = {
        args = "(AnimatedModel* model, Animation* animation)",
        description = "(AnimationState*) new (Node* node, Animation* animation)",
        returns = "(AnimationState*)",
        valuetype = "AnimationState",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetStartBone = {
        args = "(Bone* bone)",
        description = "Set start bone. Not supported in node animation mode. Resets any assigned per-bone weights.",
        returns = "()",
        type = "method"
      },
      SetLooped = {
        args = "(bool looped)",
        description = "Set looping enabled/disabled.",
        returns = "()",
        type = "method"
      },
      SetWeight = {
        args = "(float weight)",
        description = "Set blending weight.",
        returns = "()",
        type = "method"
      },
      SetTime = {
        args = "(float time)",
        description = "Set time position. Does not fire animation triggers.",
        returns = "()",
        type = "method"
      },
      SetBoneWeight = {
        args = "(const String name, float weight, bool recursive = false)",
        description = "() SetBoneWeight (StringHash nameHash, float weight, bool recursive = false),\n() SetBoneWeight (unsigned index, float weight, bool recursive = false)\nSet per-bone blending weight by name.",
        returns = "()",
        type = "method"
      },
      AddWeight = {
        args = "(float delta)",
        description = "Modify blending weight.",
        returns = "()",
        type = "method"
      },
      AddTime = {
        args = "(float delta)",
        description = "Modify time position. %Animation triggers will be fired.",
        returns = "()",
        type = "method"
      },
      SetLayer = {
        args = "(char layer)",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(AnimationBlendMode mode)",
        description = "Set blending mode.",
        returns = "()",
        type = "method"
      },
      GetAnimation = {
        args = "()",
        description = "Return animation.",
        returns = "(Animation*)",
        valuetype = "Animation",
        type = "method"
      },
      GetStartBone = {
        args = "()",
        description = "Return start bone.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      GetBoneWeight = {
        args = "(const String name)",
        description = "(float) GetBoneWeight (StringHash nameHash),\n(float) GetBoneWeight (unsigned index)\nReturn per-bone blending weight by name.",
        returns = "(float)",
        type = "method"
      },
      GetTrackIndex = {
        args = "(const String name)",
        description = "(unsigned) GetTrackIndex (StringHash nameHash)\nReturn track index by bone name, or M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether weight is nonzero.",
        returns = "(bool)",
        type = "method"
      },
      IsLooped = {
        args = "()",
        description = "Return whether looped.",
        returns = "(bool)",
        type = "method"
      },
      GetWeight = {
        args = "()",
        description = "Return blending weight.",
        returns = "(float)",
        type = "method"
      },
      GetTime = {
        args = "()",
        description = "Return time position.",
        returns = "(float)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return animation length.",
        returns = "(float)",
        type = "method"
      },
      GetLayer = {
        args = "()",
        description = "Return blending layer.",
        returns = "(char)",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blending mode.",
        returns = "(AnimationBlendMode)",
        type = "method"
      },
      animation = {
        valuetype = "Animation",
        description = "(Readonly) Animation*\nAnimation.",
        type = "value"
      },
      startBone = {
        valuetype = "Bone",
        description = "Bone*\nStart bone.",
        type = "value"
      },
      enabled = {
        description = "(Readonly) bool",
        type = "value"
      },
      looped = {
        description = "bool\nLooped flag.",
        type = "value"
      },
      weight = {
        description = "float\nBlending weight.",
        type = "value"
      },
      time = {
        description = "float\nTime position.",
        type = "value"
      },
      length = {
        description = "(Readonly) float",
        type = "value"
      },
      layer = {
        description = "char\nBlending layer.",
        type = "value"
      },
      blendMode = {
        description = "AnimationBlendMode",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationTrack = {
    childs = {
      SetKeyFrame = {
        args = "(unsigned index, const AnimationKeyFrame& keyFrame)",
        returns = "()",
        type = "method"
      },
      AddKeyFrame = {
        args = "(const AnimationKeyFrame& keyFrame)",
        returns = "()",
        type = "method"
      },
      InsertKeyFrame = {
        args = "(unsigned index, const AnimationKeyFrame& keyFrame)",
        returns = "()",
        type = "method"
      },
      RemoveKeyFrame = {
        args = "(unsigned index)",
        returns = "()",
        type = "method"
      },
      RemoveAllKeyFrames = {
        args = "()",
        returns = "()",
        type = "method"
      },
      GetKeyFrame = {
        args = "(unsigned index)",
        returns = "(AnimationKeyFrame*)",
        valuetype = "AnimationKeyFrame",
        type = "method"
      },
      GetNumKeyFrames = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "const String",
        type = "value"
      },
      nameHash = {
        description = "const StringHash",
        type = "value"
      },
      channelMask = {
        description = "char",
        type = "value"
      },
      keyFrames = {
        description = "Vector<AnimationKeyFrame>",
        type = "value"
      },
      numKeyFrames = {
        description = "(Readonly) unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  AnimationTriggerPoint = {
    childs = {
      new = {
        args = "()",
        returns = "(AnimationTriggerPoint*)",
        valuetype = "AnimationTriggerPoint",
        type = "method"
      },
      time = {
        description = "float",
        type = "value"
      },
      data = {
        description = "Variant",
        type = "value"
      },
    },
    type = "class"
  },
  Audio = {
    childs = {
      SetMode = {
        args = "(int bufferLengthMSec, int mixRate, bool stereo, bool interpolation = true)",
        description = "Initialize sound output with specified buffer length and output mode.",
        returns = "(bool)",
        type = "method"
      },
      Play = {
        args = "()",
        description = "Restart sound output.",
        returns = "(bool)",
        type = "method"
      },
      Stop = {
        args = "()",
        description = "Suspend sound output.",
        returns = "()",
        type = "method"
      },
      SetMasterGain = {
        args = "(const String type, float gain)",
        description = "Set master gain on a specific sound type such as sound effects, music or voice.",
        returns = "()",
        type = "method"
      },
      PauseSoundType = {
        args = "(const String type)",
        description = "Pause playback of specific sound type. This allows to suspend e.g. sound effects or voice when the game is paused. By default all sound types are unpaused.",
        returns = "()",
        type = "method"
      },
      ResumeSoundType = {
        args = "(const String type)",
        description = "Resume playback of specific sound type.",
        returns = "()",
        type = "method"
      },
      ResumeAll = {
        args = "()",
        description = "Resume playback of all sound types.",
        returns = "()",
        type = "method"
      },
      SetListener = {
        args = "(SoundListener* listener)",
        description = "Set active sound listener for 3D sounds.",
        returns = "()",
        type = "method"
      },
      StopSound = {
        args = "(Sound* sound)",
        description = "Stop any sound source playing a certain sound clip.",
        returns = "()",
        type = "method"
      },
      GetSampleSize = {
        args = "()",
        description = "Return byte size of one sample.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMixRate = {
        args = "()",
        description = "Return mixing rate.",
        returns = "(int)",
        type = "method"
      },
      GetInterpolation = {
        args = "()",
        description = "Return whether output is interpolated.",
        returns = "(bool)",
        type = "method"
      },
      IsStereo = {
        args = "()",
        description = "Return whether output is stereo.",
        returns = "(bool)",
        type = "method"
      },
      IsPlaying = {
        args = "()",
        description = "Return whether audio is being output.",
        returns = "(bool)",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether an audio stream has been reserved.",
        returns = "(bool)",
        type = "method"
      },
      HasMasterGain = {
        args = "(const String type)",
        returns = "(bool)",
        type = "method"
      },
      GetMasterGain = {
        args = "(const String type)",
        description = "Return master gain for a specific sound source type. Unknown sound types will return full gain (1).",
        returns = "(float)",
        type = "method"
      },
      IsSoundTypePaused = {
        args = "(const String type)",
        description = "Return whether specific sound type has been paused.",
        returns = "(bool)",
        type = "method"
      },
      GetListener = {
        args = "()",
        description = "Return active sound listener.",
        returns = "(SoundListener*)",
        valuetype = "SoundListener",
        type = "method"
      },
      GetSoundSources = {
        args = "()",
        description = "Return all sound sources.",
        returns = "(const PODVector<SoundSource*>&)",
        valuetype = "PODVector<SoundSource*>",
        type = "method"
      },
      AddSoundSource = {
        args = "(SoundSource* soundSource)",
        description = "Add a sound source to keep track of. Called by SoundSource.",
        returns = "()",
        type = "method"
      },
      RemoveSoundSource = {
        args = "(SoundSource* soundSource)",
        description = "Remove a sound source. Called by SoundSource.",
        returns = "()",
        type = "method"
      },
      MixOutput = {
        args = "(void* dest, unsigned samples)",
        returns = "()",
        type = "method"
      },
      sampleSize = {
        description = "(Readonly) unsigned\nSample size.",
        type = "value"
      },
      mixRate = {
        description = "(Readonly) int\nMixing rate.",
        type = "value"
      },
      interpolation = {
        description = "(Readonly) bool\nMixing interpolation flag.",
        type = "value"
      },
      stereo = {
        description = "(Readonly) bool\nStereo flag.",
        type = "value"
      },
      playing = {
        description = "(Readonly) bool\nPlaying flag.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      listener = {
        valuetype = "SoundListener",
        description = "SoundListener*\nSound listener.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  BiasParameters = {
    childs = {
      new = {
        args = "()",
        description = "(BiasParameters*) new (float constantBias, float slopeScaledBias, float normalOffset = 0.0f)",
        returns = "(BiasParameters*)",
        valuetype = "BiasParameters",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      constantBias = {
        description = "float",
        type = "value"
      },
      slopeScaledBias = {
        description = "float",
        type = "value"
      },
      normalOffset = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Billboard = {
    childs = {
      position = {
        description = "Vector3",
        type = "value"
      },
      size = {
        description = "Vector2",
        type = "value"
      },
      uv = {
        description = "Rect",
        type = "value"
      },
      color = {
        description = "Color",
        type = "value"
      },
      rotation = {
        description = "float",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  BillboardSet = {
    childs = {
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetNumBillboards = {
        args = "(unsigned num)",
        description = "Set number of billboards.",
        returns = "()",
        type = "method"
      },
      SetRelative = {
        args = "(bool enable)",
        description = "Set whether billboards are relative to the scene node. Default true.",
        returns = "()",
        type = "method"
      },
      SetScaled = {
        args = "(bool enable)",
        description = "Set whether scene node scale affects billboards' size. Default true.",
        returns = "()",
        type = "method"
      },
      SetSorted = {
        args = "(bool enable)",
        description = "Set whether billboards are sorted by distance. Default false.",
        returns = "()",
        type = "method"
      },
      SetFixedScreenSize = {
        args = "(bool enable)",
        description = "Set whether billboards have fixed size on screen (measured in pixels) regardless of distance to camera. Default false.",
        returns = "()",
        type = "method"
      },
      SetFaceCameraMode = {
        args = "(FaceCameraMode mode)",
        description = "Set how the billboards should rotate in relation to the camera. Default is to follow camera rotation on all axes (FC_ROTATE_XYZ.)",
        returns = "()",
        type = "method"
      },
      SetMinAngle = {
        args = "(float angle)",
        description = "Set minimal angle between billboard normal and look-at direction.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      Commit = {
        args = "()",
        description = "Mark for bounding box and vertex buffer update. Call after modifying the billboards.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumBillboards = {
        args = "()",
        description = "Return number of billboards.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBillboard = {
        args = "(unsigned index)",
        description = "Return billboard by index.",
        returns = "(Billboard*)",
        valuetype = "Billboard",
        type = "method"
      },
      IsRelative = {
        args = "()",
        description = "Return whether billboards are relative to the scene node.",
        returns = "(bool)",
        type = "method"
      },
      IsScaled = {
        args = "()",
        description = "Return whether scene node scale affects billboards' size.",
        returns = "(bool)",
        type = "method"
      },
      IsSorted = {
        args = "()",
        description = "Return whether billboards are sorted.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedScreenSize = {
        args = "()",
        description = "Return whether billboards are fixed screen size.",
        returns = "(bool)",
        type = "method"
      },
      GetFaceCameraMode = {
        args = "()",
        description = "Return how the billboards rotate in relation to the camera.",
        returns = "(FaceCameraMode)",
        type = "method"
      },
      GetMinAngle = {
        args = "()",
        description = "Return minimal angle between billboard normal and look-at direction.",
        returns = "(float)",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numBillboards = {
        description = "unsigned",
        type = "value"
      },
      relative = {
        description = "bool\nBillboards relative flag.",
        type = "value"
      },
      scaled = {
        description = "bool\nScale affects billboard scale flag.",
        type = "value"
      },
      sorted = {
        description = "bool\nBillboards sorted flag.",
        type = "value"
      },
      fixedScreenSize = {
        description = "bool\nBillboards fixed screen size flag.",
        type = "value"
      },
      faceCameraMode = {
        description = "FaceCameraMode\nBillboard rotation mode in relation to the camera.",
        type = "value"
      },
      minAngle = {
        description = "float\nMinimal angle between billboard normal and look-at direction.",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Bone = {
    childs = {
      new = {
        args = "()",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      name = {
        description = "String",
        type = "value"
      },
      nameHash = {
        description = "StringHash",
        type = "value"
      },
      parentIndex = {
        description = "unsigned",
        type = "value"
      },
      initialPosition = {
        description = "Vector3",
        type = "value"
      },
      initialRotation = {
        description = "Quaternion",
        type = "value"
      },
      initialScale = {
        description = "Vector3",
        type = "value"
      },
      offsetMatrix = {
        description = "Matrix3x4",
        type = "value"
      },
      animated = {
        description = "bool",
        type = "value"
      },
      collisionMask = {
        description = "char",
        type = "value"
      },
      radius = {
        description = "float",
        type = "value"
      },
      boundingBox = {
        description = "BoundingBox",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
    },
    type = "class"
  },
  BorderImage = {
    childs = {
      new = {
        args = "()",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  BoundingBox = {
    childs = {
      new = {
        args = "()",
        description = "(BoundingBox*) new (const BoundingBox& box),\n(BoundingBox*) new (const Rect& rect),\n(BoundingBox*) new (const Vector3& min, const Vector3& max),\n(BoundingBox*) new (float min, float max),\n(BoundingBox*) new (const Frustum& frustum),\n(BoundingBox*) new (const Polyhedron& poly),\n(BoundingBox*) new (const Sphere& sphere)",
        returns = "(BoundingBox*)",
        valuetype = "BoundingBox",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const BoundingBox& box)",
        description = "() Define (const Rect& rect),\n() Define (const Vector3& min, const Vector3& max),\n() Define (float min, float max),\n() Define (const Vector3& point),\n() Define (const Frustum& frustum),\n() Define (const Polyhedron& poly),\n() Define (const Sphere& sphere)",
        returns = "()",
        type = "method"
      },
      Merge = {
        args = "(const Vector3& point)",
        description = "() Merge (const BoundingBox& box),\n() Merge (const Frustum& frustum),\n() Merge (const Polyhedron& poly),\n() Merge (const Sphere& sphere)",
        returns = "()",
        type = "method"
      },
      Clip = {
        args = "(const BoundingBox& box)",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Defined = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Center = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      HalfSize = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(BoundingBox) Transformed (const Matrix3x4& transform)",
        returns = "(BoundingBox)",
        type = "method"
      },
      Projected = {
        args = "(const Matrix4& projection)",
        returns = "(Rect)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "(Intersection) IsInside (const BoundingBox& box),\n(Intersection) IsInside (const Sphere& sphere)",
        returns = "(Intersection)",
        type = "method"
      },
      IsInsideFast = {
        args = "(const BoundingBox& box)",
        description = "(Intersection) IsInsideFast (const Sphere& sphere)",
        returns = "(Intersection)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      min = {
        description = "Vector3",
        type = "value"
      },
      max = {
        description = "Vector3",
        type = "value"
      },
      center = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      size = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      halfSize = {
        description = "(Readonly) Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  Button = {
    childs = {
      new = {
        args = "()",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetPressedOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedOffset (int x, int y)\nSet offset to image rectangle used when pressed.",
        returns = "()",
        type = "method"
      },
      SetPressedChildOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedChildOffset (int x, int y)\nSet offset of child elements when pressed.",
        returns = "()",
        type = "method"
      },
      SetRepeat = {
        args = "(float delay, float rate)",
        description = "Set repeat properties. Rate 0 (default) disables repeat.",
        returns = "()",
        type = "method"
      },
      SetRepeatDelay = {
        args = "(float delay)",
        description = "Set repeat delay.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set repeat rate.",
        returns = "()",
        type = "method"
      },
      GetPressedOffset = {
        args = "()",
        description = "Return pressed image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPressedChildOffset = {
        args = "()",
        description = "Return offset of child elements when pressed.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetRepeatDelay = {
        args = "()",
        description = "Return repeat delay.",
        returns = "(float)",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return repeat rate.",
        returns = "(float)",
        type = "method"
      },
      IsPressed = {
        args = "()",
        description = "Return whether is currently pressed.",
        returns = "(bool)",
        type = "method"
      },
      pressedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed image offset.",
        type = "value"
      },
      pressedChildOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed label offset.",
        type = "value"
      },
      repeatDelay = {
        description = "float\nRepeat delay.",
        type = "value"
      },
      repeatRate = {
        description = "float\nRepeat rate.",
        type = "value"
      },
      pressed = {
        description = "(Readonly) bool\nCurrent pressed state.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Camera = {
    childs = {
      SetNearClip = {
        args = "(float nearClip)",
        description = "Set near clip distance.",
        returns = "()",
        type = "method"
      },
      SetFarClip = {
        args = "(float farClip)",
        description = "Set far clip distance.",
        returns = "()",
        type = "method"
      },
      SetFov = {
        args = "(float fov)",
        description = "Set vertical field of view in degrees.",
        returns = "()",
        type = "method"
      },
      SetOrthoSize = {
        args = "(float orthoSize)",
        description = "() SetOrthoSize (const Vector2& orthoSize)\nSet orthographic mode view uniform size.",
        returns = "()",
        type = "method"
      },
      SetAspectRatio = {
        args = "(float aspectRatio)",
        description = "Set aspect ratio manually. Disables the auto aspect ratio -mode.",
        returns = "()",
        type = "method"
      },
      SetFillMode = {
        args = "(FillMode mode)",
        description = "Set polygon fill mode to use when rendering a scene.",
        returns = "()",
        type = "method"
      },
      SetZoom = {
        args = "(float zoom)",
        description = "Set zoom.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Will be and'ed with object's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetViewOverrideFlags = {
        args = "(unsigned flags)",
        description = "Set view override flags.",
        returns = "()",
        type = "method"
      },
      SetOrthographic = {
        args = "(bool enable)",
        description = "Set orthographic mode enabled/disabled.",
        returns = "()",
        type = "method"
      },
      SetAutoAspectRatio = {
        args = "(bool enable)",
        description = "Set automatic aspect ratio based on viewport dimensions. Enabled by default.",
        returns = "()",
        type = "method"
      },
      SetProjectionOffset = {
        args = "(const Vector2& offset)",
        description = "Set projection offset. It needs to be calculated as (offset in pixels) / (viewport dimensions.)",
        returns = "()",
        type = "method"
      },
      SetUseReflection = {
        args = "(bool enable)",
        description = "Set reflection mode.",
        returns = "()",
        type = "method"
      },
      SetReflectionPlane = {
        args = "(const Plane& reflectionPlane)",
        description = "Set reflection plane in world space for reflection mode.",
        returns = "()",
        type = "method"
      },
      SetUseClipping = {
        args = "(bool enable)",
        description = "Set whether to use a custom clip plane.",
        returns = "()",
        type = "method"
      },
      SetClipPlane = {
        args = "(const Plane& clipPlane)",
        description = "Set custom clipping plane in world space.",
        returns = "()",
        type = "method"
      },
      SetProjection = {
        args = "(const Matrix4& projection)",
        returns = "()",
        type = "method"
      },
      GetFarClip = {
        args = "()",
        description = "Return far clip distance. If a custom projection matrix is in use, is calculated from it instead of the value assigned with SetFarClip().",
        returns = "(float)",
        type = "method"
      },
      GetNearClip = {
        args = "()",
        description = "Return near clip distance. If a custom projection matrix is in use, is calculated from it instead of the value assigned with SetNearClip().",
        returns = "(float)",
        type = "method"
      },
      GetFov = {
        args = "()",
        description = "Return vertical field of view in degrees.",
        returns = "(float)",
        type = "method"
      },
      GetOrthoSize = {
        args = "()",
        description = "Return orthographic mode size.",
        returns = "(float)",
        type = "method"
      },
      GetAspectRatio = {
        args = "()",
        description = "Return aspect ratio.",
        returns = "(float)",
        type = "method"
      },
      GetZoom = {
        args = "()",
        description = "Return zoom.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetViewOverrideFlags = {
        args = "()",
        description = "Return view override flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFillMode = {
        args = "()",
        description = "Return fill mode.",
        returns = "(FillMode)",
        type = "method"
      },
      IsOrthographic = {
        args = "()",
        description = "Return orthographic flag.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoAspectRatio = {
        args = "()",
        description = "Return auto aspect ratio flag.",
        returns = "(bool)",
        type = "method"
      },
      GetFrustum = {
        args = "()",
        description = "Return frustum in world space.",
        returns = "(const Frustum&)",
        valuetype = "Frustum",
        type = "method"
      },
      GetProjection = {
        args = "()",
        description = "Return projection matrix. It's in D3D convention with depth range 0 - 1.",
        returns = "(Matrix4)",
        type = "method"
      },
      GetGPUProjection = {
        args = "()",
        description = "Return projection matrix converted to API-specific format for use as a shader parameter.",
        returns = "(Matrix4)",
        type = "method"
      },
      GetView = {
        args = "()",
        description = "Return view matrix.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetFrustumSize = {
        args = "(Vector3& near, Vector3& far)",
        description = "Return frustum near and far sizes.",
        returns = "()",
        type = "method"
      },
      GetHalfViewSize = {
        args = "()",
        description = "Return half view size.",
        returns = "(float)",
        type = "method"
      },
      GetSplitFrustum = {
        args = "(float nearClip, float farClip)",
        description = "Return frustum split by custom near and far clip distances.",
        returns = "(Frustum)",
        type = "method"
      },
      GetViewSpaceFrustum = {
        args = "()",
        description = "Return frustum in view space.",
        returns = "(Frustum)",
        type = "method"
      },
      GetViewSpaceSplitFrustum = {
        args = "(float nearClip, float farClip)",
        description = "Return split frustum in view space.",
        returns = "(Frustum)",
        type = "method"
      },
      GetScreenRay = {
        args = "(float x, float y)",
        description = "Return ray corresponding to normalized screen coordinates (0 - 1), with origin on the near clip plane.",
        returns = "(Ray)",
        type = "method"
      },
      WorldToScreenPoint = {
        args = "(const Vector3& worldPos)",
        description = "Convert a world space point to normalized screen coordinates (0 - 1).",
        returns = "(Vector2)",
        type = "method"
      },
      ScreenToWorldPoint = {
        args = "(const Vector3& screenPos)",
        returns = "(Vector3)",
        type = "method"
      },
      GetProjectionOffset = {
        args = "()",
        description = "Return projection offset.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetUseReflection = {
        args = "()",
        description = "Return whether is using reflection.",
        returns = "(bool)",
        type = "method"
      },
      GetReflectionPlane = {
        args = "()",
        description = "Return the reflection plane.",
        returns = "(const Plane&)",
        valuetype = "Plane",
        type = "method"
      },
      GetUseClipping = {
        args = "()",
        description = "Return whether is using a custom clipping plane.",
        returns = "(bool)",
        type = "method"
      },
      GetClipPlane = {
        args = "()",
        description = "Return the custom clipping plane.",
        returns = "(const Plane&)",
        valuetype = "Plane",
        type = "method"
      },
      GetDistance = {
        args = "(const Vector3& worldPos)",
        description = "Return distance to position. In orthographic mode uses only Z coordinate.",
        returns = "(float)",
        type = "method"
      },
      GetDistanceSquared = {
        args = "(const Vector3& worldPos)",
        description = "Return squared distance to position. In orthographic mode uses only Z coordinate.",
        returns = "(float)",
        type = "method"
      },
      GetLodDistance = {
        args = "(float distance, float scale, float bias)",
        description = "Return a scene node's LOD scaled distance.",
        returns = "(float)",
        type = "method"
      },
      IsProjectionValid = {
        args = "()",
        description = "Return if projection parameters are valid for rendering and raycasting.",
        returns = "(bool)",
        type = "method"
      },
      GetEffectiveWorldTransform = {
        args = "()",
        description = "Get effective world transform for matrix and frustum calculations including reflection but excluding node scaling.",
        returns = "(Matrix3x4)",
        type = "method"
      },
      farClip = {
        description = "float\nFar clip distance.",
        type = "value"
      },
      nearClip = {
        description = "float\nNear clip distance.",
        type = "value"
      },
      fov = {
        description = "float\nField of view.",
        type = "value"
      },
      orthoSize = {
        description = "float\nOrthographic view size.",
        type = "value"
      },
      aspectRatio = {
        description = "float\nAspect ratio.",
        type = "value"
      },
      zoom = {
        description = "float\nZoom.",
        type = "value"
      },
      lodBias = {
        description = "float\nLOD bias.",
        type = "value"
      },
      viewMask = {
        description = "unsigned\nView mask.",
        type = "value"
      },
      viewOverrideFlags = {
        description = "unsigned\nView override flags.",
        type = "value"
      },
      fillMode = {
        description = "FillMode\nFill mode.",
        type = "value"
      },
      orthographic = {
        description = "bool\nOrthographic mode flag.",
        type = "value"
      },
      autoAspectRatio = {
        description = "bool\nAuto aspect ratio flag.",
        type = "value"
      },
      frustum = {
        valuetype = "Frustum",
        description = "(Readonly) Frustum&\nCached world space frustum.",
        type = "value"
      },
      projection = {
        description = "(Readonly) Matrix4\nCached projection matrix.",
        type = "value"
      },
      GPUProjection = {
        description = "(Readonly) Matrix4",
        type = "value"
      },
      view = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&\nCached view matrix.",
        type = "value"
      },
      halfViewSize = {
        description = "(Readonly) float",
        type = "value"
      },
      viewSpaceFrustum = {
        description = "(Readonly) Frustum",
        type = "value"
      },
      projectionOffset = {
        valuetype = "Vector2",
        description = "Vector2&\nProjection offset.",
        type = "value"
      },
      useReflection = {
        description = "bool\nReflection mode enabled flag.",
        type = "value"
      },
      reflectionPlane = {
        valuetype = "Plane",
        description = "Plane&\nReflection plane.",
        type = "value"
      },
      useClipping = {
        description = "bool\nUse custom clip plane flag.",
        type = "value"
      },
      clipPlane = {
        valuetype = "Plane",
        description = "Plane&\nClipping plane.",
        type = "value"
      },
      projectionValid = {
        description = "(Readonly) bool",
        type = "value"
      },
      effectiveWorldTransform = {
        description = "(Readonly) Matrix3x4",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CascadeParameters = {
    childs = {
      new = {
        args = "()",
        description = "(CascadeParameters*) new (float split1, float split2, float split3, float split4, float fadeStart, float biasAutoAdjust = 1.0f)",
        returns = "(CascadeParameters*)",
        valuetype = "CascadeParameters",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      fadeStart = {
        description = "float",
        type = "value"
      },
      biasAutoAdjust = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  CheckBox = {
    childs = {
      new = {
        args = "()",
        returns = "(CheckBox*)",
        valuetype = "CheckBox",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetChecked = {
        args = "(bool enable)",
        description = "Set checked state.",
        returns = "()",
        type = "method"
      },
      SetCheckedOffset = {
        args = "(const IntVector2& rect)",
        description = "() SetCheckedOffset (int x, int y)\nSet checked image offset.",
        returns = "()",
        type = "method"
      },
      IsChecked = {
        args = "()",
        description = "Return whether is checked.",
        returns = "(bool)",
        type = "method"
      },
      GetCheckedOffset = {
        args = "()",
        description = "Return checked image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      checked = {
        description = "bool\nCurrent checked state.",
        type = "value"
      },
      checkedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChecked image offset.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionBox2D = {
    childs = {
      SetSize = {
        args = "(const Vector2& size)",
        description = "() SetSize (float width, float height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetCenter = {
        args = "(const Vector2& center)",
        description = "() SetCenter (float x, float y)\nSet center.",
        returns = "()",
        type = "method"
      },
      SetAngle = {
        args = "(float angle)",
        description = "Set angle.",
        returns = "()",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetCenter = {
        args = "()",
        description = "Return center.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetAngle = {
        args = "()",
        description = "Return angle.",
        returns = "(float)",
        type = "method"
      },
      size = {
        valuetype = "Vector2",
        description = "Vector2&\nSize.",
        type = "value"
      },
      center = {
        valuetype = "Vector2",
        description = "Vector2&\nCenter",
        type = "value"
      },
      angle = {
        description = "float\nAngle.",
        type = "value"
      },
      SetTrigger = {
        args = "(bool trigger)",
        description = "Set trigger.",
        returns = "()",
        type = "method"
      },
      SetCategoryBits = {
        args = "(int categoryBits)",
        description = "Set filter category bits.",
        returns = "()",
        type = "method"
      },
      SetMaskBits = {
        args = "(int maskBits)",
        description = "Set filter mask bits.",
        returns = "()",
        type = "method"
      },
      SetGroupIndex = {
        args = "(int groupIndex)",
        description = "Set filter group index.",
        returns = "()",
        type = "method"
      },
      SetDensity = {
        args = "(float density)",
        description = "Set density.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution .",
        returns = "()",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return trigger.",
        returns = "(bool)",
        type = "method"
      },
      GetCategoryBits = {
        args = "()",
        description = "Return filter category bits.",
        returns = "(int)",
        type = "method"
      },
      GetMaskBits = {
        args = "()",
        description = "Return filter mask bits.",
        returns = "(int)",
        type = "method"
      },
      GetGroupIndex = {
        args = "()",
        description = "Return filter group index.",
        returns = "(int)",
        type = "method"
      },
      GetDensity = {
        args = "()",
        description = "Return density.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution.",
        returns = "(float)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      trigger = {
        description = "bool",
        type = "value"
      },
      categoryBits = {
        description = "int",
        type = "value"
      },
      maskBits = {
        description = "int",
        type = "value"
      },
      groupIndex = {
        description = "int",
        type = "value"
      },
      density = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      mass = {
        description = "(Readonly) float",
        type = "value"
      },
      inertia = {
        description = "(Readonly) float",
        type = "value"
      },
      massCenter = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionChain2D = {
    childs = {
      SetLoop = {
        args = "(bool loop)",
        description = "Set loop.",
        returns = "()",
        type = "method"
      },
      SetVertexCount = {
        args = "(unsigned count)",
        description = "Set vertex count.",
        returns = "()",
        type = "method"
      },
      SetVertex = {
        args = "(unsigned index, const Vector2& vertex)",
        description = "Set vertex.",
        returns = "()",
        type = "method"
      },
      SetVertices = {
        args = "(const PODVector<Vector2>& vertices)",
        returns = "()",
        type = "method"
      },
      GetLoop = {
        args = "()",
        description = "Return loop.",
        returns = "(bool)",
        type = "method"
      },
      GetVertexCount = {
        args = "()",
        description = "Return vertex count.",
        returns = "(unsigned)",
        type = "method"
      },
      GetVertex = {
        args = "(unsigned index)",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      loop = {
        description = "bool\nLoop.",
        type = "value"
      },
      vertexCount = {
        description = "unsigned",
        type = "value"
      },
      SetTrigger = {
        args = "(bool trigger)",
        description = "Set trigger.",
        returns = "()",
        type = "method"
      },
      SetCategoryBits = {
        args = "(int categoryBits)",
        description = "Set filter category bits.",
        returns = "()",
        type = "method"
      },
      SetMaskBits = {
        args = "(int maskBits)",
        description = "Set filter mask bits.",
        returns = "()",
        type = "method"
      },
      SetGroupIndex = {
        args = "(int groupIndex)",
        description = "Set filter group index.",
        returns = "()",
        type = "method"
      },
      SetDensity = {
        args = "(float density)",
        description = "Set density.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution .",
        returns = "()",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return trigger.",
        returns = "(bool)",
        type = "method"
      },
      GetCategoryBits = {
        args = "()",
        description = "Return filter category bits.",
        returns = "(int)",
        type = "method"
      },
      GetMaskBits = {
        args = "()",
        description = "Return filter mask bits.",
        returns = "(int)",
        type = "method"
      },
      GetGroupIndex = {
        args = "()",
        description = "Return filter group index.",
        returns = "(int)",
        type = "method"
      },
      GetDensity = {
        args = "()",
        description = "Return density.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution.",
        returns = "(float)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      trigger = {
        description = "bool",
        type = "value"
      },
      categoryBits = {
        description = "int",
        type = "value"
      },
      maskBits = {
        description = "int",
        type = "value"
      },
      groupIndex = {
        description = "int",
        type = "value"
      },
      density = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      mass = {
        description = "(Readonly) float",
        type = "value"
      },
      inertia = {
        description = "(Readonly) float",
        type = "value"
      },
      massCenter = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionCircle2D = {
    childs = {
      SetRadius = {
        args = "(float radius)",
        description = "Set radius.",
        returns = "()",
        type = "method"
      },
      SetCenter = {
        args = "(const Vector2& center)",
        description = "() SetCenter (float x, float y)\nSet center.",
        returns = "()",
        type = "method"
      },
      GetRadius = {
        args = "()",
        description = "Return radius.",
        returns = "(float)",
        type = "method"
      },
      GetCenter = {
        args = "()",
        description = "Return center.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      radius = {
        description = "float\nRadius.",
        type = "value"
      },
      center = {
        valuetype = "Vector2",
        description = "Vector2&\nCenter.",
        type = "value"
      },
      SetTrigger = {
        args = "(bool trigger)",
        description = "Set trigger.",
        returns = "()",
        type = "method"
      },
      SetCategoryBits = {
        args = "(int categoryBits)",
        description = "Set filter category bits.",
        returns = "()",
        type = "method"
      },
      SetMaskBits = {
        args = "(int maskBits)",
        description = "Set filter mask bits.",
        returns = "()",
        type = "method"
      },
      SetGroupIndex = {
        args = "(int groupIndex)",
        description = "Set filter group index.",
        returns = "()",
        type = "method"
      },
      SetDensity = {
        args = "(float density)",
        description = "Set density.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution .",
        returns = "()",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return trigger.",
        returns = "(bool)",
        type = "method"
      },
      GetCategoryBits = {
        args = "()",
        description = "Return filter category bits.",
        returns = "(int)",
        type = "method"
      },
      GetMaskBits = {
        args = "()",
        description = "Return filter mask bits.",
        returns = "(int)",
        type = "method"
      },
      GetGroupIndex = {
        args = "()",
        description = "Return filter group index.",
        returns = "(int)",
        type = "method"
      },
      GetDensity = {
        args = "()",
        description = "Return density.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution.",
        returns = "(float)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      trigger = {
        description = "bool",
        type = "value"
      },
      categoryBits = {
        description = "int",
        type = "value"
      },
      maskBits = {
        description = "int",
        type = "value"
      },
      groupIndex = {
        description = "int",
        type = "value"
      },
      density = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      mass = {
        description = "(Readonly) float",
        type = "value"
      },
      inertia = {
        description = "(Readonly) float",
        type = "value"
      },
      massCenter = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionEdge2D = {
    childs = {
      SetVertex1 = {
        args = "(const Vector2& vertex)",
        description = "Set vertex 1.",
        returns = "()",
        type = "method"
      },
      SetVertex2 = {
        args = "(const Vector2& vertex)",
        description = "Set vertex 2.",
        returns = "()",
        type = "method"
      },
      SetVertices = {
        args = "(const Vector2& vertex1, const Vector2& vertex2)",
        description = "Set vertices.",
        returns = "()",
        type = "method"
      },
      GetVertex1 = {
        args = "()",
        description = "Return vertex 1.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetVertex2 = {
        args = "()",
        description = "Return vertex 2.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      vertex1 = {
        valuetype = "Vector2",
        description = "Vector2&\nVertex 1.",
        type = "value"
      },
      vertex2 = {
        valuetype = "Vector2",
        description = "Vector2&\nVertex 2.",
        type = "value"
      },
      SetTrigger = {
        args = "(bool trigger)",
        description = "Set trigger.",
        returns = "()",
        type = "method"
      },
      SetCategoryBits = {
        args = "(int categoryBits)",
        description = "Set filter category bits.",
        returns = "()",
        type = "method"
      },
      SetMaskBits = {
        args = "(int maskBits)",
        description = "Set filter mask bits.",
        returns = "()",
        type = "method"
      },
      SetGroupIndex = {
        args = "(int groupIndex)",
        description = "Set filter group index.",
        returns = "()",
        type = "method"
      },
      SetDensity = {
        args = "(float density)",
        description = "Set density.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution .",
        returns = "()",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return trigger.",
        returns = "(bool)",
        type = "method"
      },
      GetCategoryBits = {
        args = "()",
        description = "Return filter category bits.",
        returns = "(int)",
        type = "method"
      },
      GetMaskBits = {
        args = "()",
        description = "Return filter mask bits.",
        returns = "(int)",
        type = "method"
      },
      GetGroupIndex = {
        args = "()",
        description = "Return filter group index.",
        returns = "(int)",
        type = "method"
      },
      GetDensity = {
        args = "()",
        description = "Return density.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution.",
        returns = "(float)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      trigger = {
        description = "bool",
        type = "value"
      },
      categoryBits = {
        description = "int",
        type = "value"
      },
      maskBits = {
        description = "int",
        type = "value"
      },
      groupIndex = {
        description = "int",
        type = "value"
      },
      density = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      mass = {
        description = "(Readonly) float",
        type = "value"
      },
      inertia = {
        description = "(Readonly) float",
        type = "value"
      },
      massCenter = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionPolygon2D = {
    childs = {
      SetVertexCount = {
        args = "(unsigned count)",
        description = "Set vertex count.",
        returns = "()",
        type = "method"
      },
      SetVertex = {
        args = "(unsigned index, const Vector2& vertex)",
        description = "Set vertex.",
        returns = "()",
        type = "method"
      },
      SetVertices = {
        args = "(const PODVector<Vector2>& vertices)",
        returns = "()",
        type = "method"
      },
      GetVertexCount = {
        args = "()",
        description = "Return vertex count.",
        returns = "(unsigned)",
        type = "method"
      },
      GetVertex = {
        args = "(unsigned index)",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      vertexCount = {
        description = "unsigned",
        type = "value"
      },
      SetTrigger = {
        args = "(bool trigger)",
        description = "Set trigger.",
        returns = "()",
        type = "method"
      },
      SetCategoryBits = {
        args = "(int categoryBits)",
        description = "Set filter category bits.",
        returns = "()",
        type = "method"
      },
      SetMaskBits = {
        args = "(int maskBits)",
        description = "Set filter mask bits.",
        returns = "()",
        type = "method"
      },
      SetGroupIndex = {
        args = "(int groupIndex)",
        description = "Set filter group index.",
        returns = "()",
        type = "method"
      },
      SetDensity = {
        args = "(float density)",
        description = "Set density.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution .",
        returns = "()",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return trigger.",
        returns = "(bool)",
        type = "method"
      },
      GetCategoryBits = {
        args = "()",
        description = "Return filter category bits.",
        returns = "(int)",
        type = "method"
      },
      GetMaskBits = {
        args = "()",
        description = "Return filter mask bits.",
        returns = "(int)",
        type = "method"
      },
      GetGroupIndex = {
        args = "()",
        description = "Return filter group index.",
        returns = "(int)",
        type = "method"
      },
      GetDensity = {
        args = "()",
        description = "Return density.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution.",
        returns = "(float)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      trigger = {
        description = "bool",
        type = "value"
      },
      categoryBits = {
        description = "int",
        type = "value"
      },
      maskBits = {
        description = "int",
        type = "value"
      },
      groupIndex = {
        description = "int",
        type = "value"
      },
      density = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      mass = {
        description = "(Readonly) float",
        type = "value"
      },
      inertia = {
        description = "(Readonly) float",
        type = "value"
      },
      massCenter = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionShape = {
    childs = {
      SetBox = {
        args = "(const Vector3& size)",
        description = "() SetBox (const Vector3& size, const Vector3& position),\n() SetBox (const Vector3& size, const Vector3& position, const Quaternion& rotation)\nSet as a box.",
        returns = "()",
        type = "method"
      },
      SetSphere = {
        args = "(float diameter)",
        description = "() SetSphere (float diameter, const Vector3& position),\n() SetSphere (float diameter, const Vector3& position, const Quaternion& rotation)\nSet as a sphere.",
        returns = "()",
        type = "method"
      },
      SetStaticPlane = {
        args = "()",
        description = "() SetStaticPlane (const Vector3& position),\n() SetStaticPlane (const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetCylinder = {
        args = "(float diameter, float height)",
        description = "() SetCylinder (float diameter, float height, const Vector3& position),\n() SetCylinder (float diameter, float height, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetCapsule = {
        args = "(float diameter, float height)",
        description = "() SetCapsule (float diameter, float height, const Vector3& position),\n() SetCapsule (float diameter, float height, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetCone = {
        args = "(float diameter, float height)",
        description = "() SetCone (float diameter, float height, const Vector3& position),\n() SetCone (float diameter, float height, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetTriangleMesh = {
        args = "(Model* model, unsigned lodLevel = 0)",
        description = "() SetTriangleMesh (Model* model, unsigned lodLevel, const Vector3& scale),\n() SetTriangleMesh (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position),\n() SetTriangleMesh (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetCustomTriangleMesh = {
        args = "(CustomGeometry* custom)",
        description = "() SetCustomTriangleMesh (CustomGeometry* custom, const Vector3& scale),\n() SetCustomTriangleMesh (CustomGeometry* custom, const Vector3& scale, const Vector3& position),\n() SetCustomTriangleMesh (CustomGeometry* custom, const Vector3& scale, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetConvexHull = {
        args = "(Model* model, unsigned lodLevel = 0)",
        description = "() SetConvexHull (Model* model, unsigned lodLevel, const Vector3& scale),\n() SetConvexHull (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position),\n() SetConvexHull (Model* model, unsigned lodLevel, const Vector3& scale, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetCustomConvexHull = {
        args = "(CustomGeometry* custom)",
        description = "() SetCustomConvexHull (CustomGeometry* custom, const Vector3& scale),\n() SetCustomConvexHull (CustomGeometry* custom, const Vector3& scale, const Vector3& position),\n() SetCustomConvexHull (CustomGeometry* custom, const Vector3& scale, const Vector3& position, const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetTerrain = {
        args = "(unsigned lodLevel = 0)",
        description = "Set as a terrain. Only works if the same scene node contains a Terrain component.",
        returns = "()",
        type = "method"
      },
      SetShapeType = {
        args = "(ShapeType type)",
        description = "Set shape type.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const Vector3& size)",
        description = "Set shape size.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set offset position.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set offset rotation.",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "Set offset transform.",
        returns = "()",
        type = "method"
      },
      SetMargin = {
        args = "(float margin)",
        description = "Set collision margin.",
        returns = "()",
        type = "method"
      },
      SetModel = {
        args = "(Model* model)",
        description = "Set triangle mesh / convex hull model.",
        returns = "()",
        type = "method"
      },
      SetLodLevel = {
        args = "(unsigned lodLevel)",
        description = "Set model LOD level.",
        returns = "()",
        type = "method"
      },
      GetPhysicsWorld = {
        args = "()",
        description = "Return physics world.",
        returns = "(PhysicsWorld*)",
        valuetype = "PhysicsWorld",
        type = "method"
      },
      GetShapeType = {
        args = "()",
        description = "Return shape type.",
        returns = "(ShapeType)",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return shape size.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return offset position.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return offset rotation.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetMargin = {
        args = "()",
        description = "Return collision margin.",
        returns = "(float)",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return triangle mesh / convex hull model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetLodLevel = {
        args = "()",
        description = "Return model LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(BoundingBox)",
        type = "method"
      },
      physicsWorld = {
        valuetype = "PhysicsWorld",
        description = "(Readonly) PhysicsWorld*\nPhysics world.",
        type = "value"
      },
      shapeType = {
        description = "ShapeType\nCollision shape type.",
        type = "value"
      },
      size = {
        valuetype = "Vector3",
        description = "Vector3&\nShape size.",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&\nOffset position.",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nOffset rotation.",
        type = "value"
      },
      margin = {
        description = "float\nCollision margin.",
        type = "value"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      lodLevel = {
        description = "unsigned\nModel LOD level.",
        type = "value"
      },
      worldBoundingBox = {
        description = "(Readonly) BoundingBox",
        type = "value"
      },
      modelAttr = {
        description = "ResourceRef",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CollisionShape2D = {
    childs = {
      SetTrigger = {
        args = "(bool trigger)",
        description = "Set trigger.",
        returns = "()",
        type = "method"
      },
      SetCategoryBits = {
        args = "(int categoryBits)",
        description = "Set filter category bits.",
        returns = "()",
        type = "method"
      },
      SetMaskBits = {
        args = "(int maskBits)",
        description = "Set filter mask bits.",
        returns = "()",
        type = "method"
      },
      SetGroupIndex = {
        args = "(int groupIndex)",
        description = "Set filter group index.",
        returns = "()",
        type = "method"
      },
      SetDensity = {
        args = "(float density)",
        description = "Set density.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution .",
        returns = "()",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return trigger.",
        returns = "(bool)",
        type = "method"
      },
      GetCategoryBits = {
        args = "()",
        description = "Return filter category bits.",
        returns = "(int)",
        type = "method"
      },
      GetMaskBits = {
        args = "()",
        description = "Return filter mask bits.",
        returns = "(int)",
        type = "method"
      },
      GetGroupIndex = {
        args = "()",
        description = "Return filter group index.",
        returns = "(int)",
        type = "method"
      },
      GetDensity = {
        args = "()",
        description = "Return density.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution.",
        returns = "(float)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      trigger = {
        description = "bool",
        type = "value"
      },
      categoryBits = {
        description = "int",
        type = "value"
      },
      maskBits = {
        description = "int",
        type = "value"
      },
      groupIndex = {
        description = "int",
        type = "value"
      },
      density = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      mass = {
        description = "(Readonly) float",
        type = "value"
      },
      inertia = {
        description = "(Readonly) float",
        type = "value"
      },
      massCenter = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Color = {
    childs = {
      new = {
        args = "()",
        description = "(Color*) new (const Color& color),\n(Color*) new (const Color& color, float a),\n(Color*) new (float r, float g, float b),\n(Color*) new (float r, float g, float b, float a)",
        returns = "(Color*)",
        valuetype = "Color",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ToUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ToHSL = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ToHSV = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      FromHSL = {
        args = "(float h, float s, float l, float a)",
        returns = "()",
        type = "method"
      },
      FromHSV = {
        args = "(float h, float s, float v, float a)",
        returns = "()",
        type = "method"
      },
      ToVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ToVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      SumRGB = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Average = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Luma = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Chroma = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Hue = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      SaturationHSL = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      SaturationHSV = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Value = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Lightness = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      MaxRGB = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      MinRGB = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Range = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      Clip = {
        args = "(bool clipAlpha = false)",
        returns = "()",
        type = "method"
      },
      Invert = {
        args = "(bool invertAlpha = false)",
        returns = "()",
        type = "method"
      },
      Lerp = {
        args = "(const Color& rhs, float t)",
        returns = "(Color)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      Equals = {
        args = "(const Color& rhs)",
        returns = "(bool)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      r = {
        description = "float",
        type = "value"
      },
      g = {
        description = "float",
        type = "value"
      },
      b = {
        description = "float",
        type = "value"
      },
      a = {
        description = "float",
        type = "value"
      },
      WHITE = {
        description = "const Color",
        type = "value"
      },
      GRAY = {
        description = "const Color",
        type = "value"
      },
      BLACK = {
        description = "const Color",
        type = "value"
      },
      RED = {
        description = "const Color",
        type = "value"
      },
      GREEN = {
        description = "const Color",
        type = "value"
      },
      BLUE = {
        description = "const Color",
        type = "value"
      },
      CYAN = {
        description = "const Color",
        type = "value"
      },
      MAGENTA = {
        description = "const Color",
        type = "value"
      },
      YELLOW = {
        description = "const Color",
        type = "value"
      },
      TRANSPARENT = {
        description = "const Color",
        type = "value"
      },
    },
    type = "class"
  },
  ColorFrame = {
    childs = {
      new = {
        args = "()",
        description = "(ColorFrame*) new (const Color& color),\n(ColorFrame*) new (const Color& color, float time)",
        returns = "(ColorFrame*)",
        valuetype = "ColorFrame",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Interpolate = {
        args = "(const ColorFrame& next, float time)",
        returns = "(Color)",
        type = "method"
      },
      color = {
        description = "Color",
        type = "value"
      },
      time = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Component = {
    childs = {
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Connection = {
    childs = {
      SendMessage = {
        args = "(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0)",
        description = "Send a message.",
        returns = "()",
        type = "method"
      },
      SendRemoteEvent = {
        args = "(StringHash eventType, bool inOrder)",
        description = "() SendRemoteEvent (StringHash eventType, bool inOrder, const VariantMap& eventData),\n() SendRemoteEvent (const String eventType, bool inOrder),\n() SendRemoteEvent (const String eventType, bool inOrder, const VariantMap& eventData),\n() SendRemoteEvent (Node* node, StringHash eventType, bool inOrder),\n() SendRemoteEvent (Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData),\n() SendRemoteEvent (Node* node, const String eventType, bool inOrder),\n() SendRemoteEvent (Node* node, const String eventType, bool inOrder, const VariantMap& eventData)\nSend a remote event.",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* newScene)",
        description = "Assign scene. On the server, this will cause the client to load it.",
        returns = "()",
        type = "method"
      },
      SetIdentity = {
        args = "(const VariantMap& identity)",
        description = "Assign identity. Called by Network.",
        returns = "()",
        type = "method"
      },
      SetControls = {
        args = "(const Controls& newControls)",
        description = "Set new controls.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set the observer position for interest management, to be sent to the server.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set the observer rotation for interest management, to be sent to the server. Note: not used by the NetworkPriority component.",
        returns = "()",
        type = "method"
      },
      SetConnectPending = {
        args = "(bool connectPending)",
        description = "Set the connection pending status. Called by Network.",
        returns = "()",
        type = "method"
      },
      SetLogStatistics = {
        args = "(bool enable)",
        description = "Set whether to log data in/out statistics.",
        returns = "()",
        type = "method"
      },
      Disconnect = {
        args = "(int waitMSec = 0)",
        description = "Disconnect. If wait time is non-zero, will block while waiting for disconnect to finish.",
        returns = "()",
        type = "method"
      },
      SendPackageToClient = {
        args = "(PackageFile* package)",
        description = "Trigger client connection to download a package file from the server. Can be used to download additional resource packages when client is already joined in a scene. The package must have been added as a requirement to the scene the client is joined in, or else the eventual download will fail.",
        returns = "()",
        type = "method"
      },
      GetIdentity = {
        args = "()",
        description = "Return client identity.",
        returns = "(VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene used by this connection.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      GetControls = {
        args = "()",
        description = "Return the client controls of this connection.",
        returns = "(const Controls&)",
        valuetype = "Controls",
        type = "method"
      },
      GetTimeStamp = {
        args = "()",
        description = "Return the controls timestamp, sent from client to server along each control update.",
        returns = "(char)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return the observer position sent by the client for interest management.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return the observer rotation sent by the client for interest management.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      IsClient = {
        args = "()",
        description = "Return whether is a client connection.",
        returns = "(bool)",
        type = "method"
      },
      IsConnected = {
        args = "()",
        description = "Return whether is fully connected.",
        returns = "(bool)",
        type = "method"
      },
      IsConnectPending = {
        args = "()",
        description = "Return whether connection is pending.",
        returns = "(bool)",
        type = "method"
      },
      IsSceneLoaded = {
        args = "()",
        description = "Return whether the scene is loaded and ready to receive server updates.",
        returns = "(bool)",
        type = "method"
      },
      GetLogStatistics = {
        args = "()",
        description = "Return whether to log data in/out statistics.",
        returns = "(bool)",
        type = "method"
      },
      GetAddress = {
        args = "()",
        description = "Return remote address.",
        returns = "(String)",
        type = "method"
      },
      GetPort = {
        args = "()",
        description = "Return remote port.",
        returns = "(short)",
        type = "method"
      },
      GetRoundTripTime = {
        args = "()",
        description = "Return the connection's round trip time in milliseconds.",
        returns = "(float)",
        type = "method"
      },
      GetLastHeardTime = {
        args = "()",
        description = "Return the time since last received data from the remote host in milliseconds.",
        returns = "(float)",
        type = "method"
      },
      GetBytesInPerSec = {
        args = "()",
        description = "Return bytes received per second.",
        returns = "(float)",
        type = "method"
      },
      GetBytesOutPerSec = {
        args = "()",
        description = "Return bytes sent per second.",
        returns = "(float)",
        type = "method"
      },
      GetPacketsInPerSec = {
        args = "()",
        description = "Return packets received per second.",
        returns = "(float)",
        type = "method"
      },
      GetPacketsOutPerSec = {
        args = "()",
        description = "Return packets sent per second.",
        returns = "(float)",
        type = "method"
      },
      ToString = {
        args = "()",
        description = "Return an address:port string.",
        returns = "(String)",
        type = "method"
      },
      GetNumDownloads = {
        args = "()",
        description = "Return number of package downloads remaining.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDownloadName = {
        args = "()",
        description = "Return name of current package download, or empty if no downloads.",
        returns = "(const String)",
        type = "method"
      },
      GetDownloadProgress = {
        args = "()",
        description = "Return progress of current package download, or 1.0 if no downloads.",
        returns = "(float)",
        type = "method"
      },
      identity = {
        valuetype = "VariantMap",
        description = "VariantMap&\nIdentity map.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*\nScene.",
        type = "value"
      },
      controls = {
        valuetype = "Controls",
        description = "Controls&\nCurrent controls.",
        type = "value"
      },
      timeStamp = {
        description = "(Readonly) char\nControls timestamp. Incremented after each sent update.",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&\nObserver position for interest management.",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nObserver rotation for interest management.",
        type = "value"
      },
      client = {
        description = "(Readonly) bool",
        type = "value"
      },
      connected = {
        description = "(Readonly) bool",
        type = "value"
      },
      connectPending = {
        description = "bool\nConnection pending flag.",
        type = "value"
      },
      sceneLoaded = {
        description = "(Readonly) bool\nScene loaded flag.",
        type = "value"
      },
      logStatistics = {
        description = "bool\nShow statistics flag.",
        type = "value"
      },
      address = {
        description = "(Readonly) String",
        type = "value"
      },
      port = {
        description = "(Readonly) short",
        type = "value"
      },
      roundTripTime = {
        description = "(Readonly) float",
        type = "value"
      },
      lastHeardTime = {
        description = "(Readonly) float",
        type = "value"
      },
      bytesInPerSec = {
        description = "(Readonly) float",
        type = "value"
      },
      bytesOutPerSec = {
        description = "(Readonly) float",
        type = "value"
      },
      packetsInPerSec = {
        description = "(Readonly) float",
        type = "value"
      },
      packetsOutPerSec = {
        description = "(Readonly) float",
        type = "value"
      },
      numDownloads = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      downloadName = {
        description = "(Readonly) String",
        type = "value"
      },
      downloadProgress = {
        description = "(Readonly) float",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Console = {
    childs = {
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set UI elements' style from an XML file.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Show or hide.",
        returns = "()",
        type = "method"
      },
      Toggle = {
        args = "()",
        description = "Toggle visibility.",
        returns = "()",
        type = "method"
      },
      SetAutoVisibleOnError = {
        args = "(bool enable)",
        description = "Automatically set console to visible when receiving an error log message.",
        returns = "()",
        type = "method"
      },
      SetCommandInterpreter = {
        args = "(const String interpreter)",
        description = "Set the command interpreter.",
        returns = "()",
        type = "method"
      },
      SetNumBufferedRows = {
        args = "(unsigned rows)",
        description = "Set number of buffered rows.",
        returns = "()",
        type = "method"
      },
      SetNumRows = {
        args = "(unsigned rows)",
        description = "Set number of displayed rows.",
        returns = "()",
        type = "method"
      },
      SetNumHistoryRows = {
        args = "(unsigned rows)",
        description = "Set command history maximum size, 0 disables history.",
        returns = "()",
        type = "method"
      },
      SetFocusOnShow = {
        args = "(bool enable)",
        description = "Set whether to automatically focus the line edit when showing. Default true on desktops and false on mobile devices, as on mobiles it would pop up the screen keyboard.",
        returns = "()",
        type = "method"
      },
      AddAutoComplete = {
        args = "(const String option)",
        description = "Add auto complete option.",
        returns = "()",
        type = "method"
      },
      RemoveAutoComplete = {
        args = "(const String option)",
        description = "Remove auto complete option.",
        returns = "()",
        type = "method"
      },
      UpdateElements = {
        args = "()",
        description = "Update elements to layout properly. Call this after manually adjusting the sub-elements.",
        returns = "()",
        type = "method"
      },
      GetDefaultStyle = {
        args = "()",
        description = "Return the UI style file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetBackground = {
        args = "()",
        description = "Return the background element.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetLineEdit = {
        args = "()",
        description = "Return the line edit element.",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      GetCloseButton = {
        args = "()",
        description = "Return the close butoon element.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsAutoVisibleOnError = {
        args = "()",
        description = "Return true when console is set to automatically visible when receiving an error log message.",
        returns = "(bool)",
        type = "method"
      },
      GetCommandInterpreter = {
        args = "()",
        description = "Return the last used command interpreter.",
        returns = "(const String)",
        type = "method"
      },
      GetNumBufferedRows = {
        args = "()",
        description = "Return number of buffered rows.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        description = "Return number of displayed rows.",
        returns = "(unsigned)",
        type = "method"
      },
      CopySelectedRows = {
        args = "()",
        description = "Copy selected rows to system clipboard.",
        returns = "()",
        type = "method"
      },
      GetNumHistoryRows = {
        args = "()",
        description = "Return history maximum size.",
        returns = "(unsigned)",
        type = "method"
      },
      GetHistoryPosition = {
        args = "()",
        description = "Return current history position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetHistoryRow = {
        args = "(unsigned index)",
        description = "Return history row at index.",
        returns = "(const String)",
        type = "method"
      },
      GetFocusOnShow = {
        args = "()",
        description = "Return whether automatically focuses the line edit when showing.",
        returns = "(bool)",
        type = "method"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*",
        type = "value"
      },
      background = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nBackground.",
        type = "value"
      },
      lineEdit = {
        valuetype = "LineEdit",
        description = "(Readonly) LineEdit*\nLine edit.",
        type = "value"
      },
      closeButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nClose button.",
        type = "value"
      },
      visible = {
        description = "bool",
        type = "value"
      },
      autoVisibleOnError = {
        description = "bool\nAuto visible on error flag.",
        type = "value"
      },
      commandInterpreter = {
        description = "String\nLast used command interpreter.",
        type = "value"
      },
      numBufferedRows = {
        description = "unsigned",
        type = "value"
      },
      numRows = {
        description = "unsigned",
        type = "value"
      },
      numHistoryRows = {
        description = "unsigned",
        type = "value"
      },
      historyPosition = {
        description = "(Readonly) unsigned\nCommand history current position.",
        type = "value"
      },
      focusOnShow = {
        description = "bool\nFlag for automatically focusing the line edit on showing the console.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Constraint = {
    childs = {
      SetConstraintType = {
        args = "(ConstraintType type)",
        description = "Set constraint type and recreate the constraint.",
        returns = "()",
        type = "method"
      },
      SetOtherBody = {
        args = "(RigidBody* body)",
        description = "Set other body to connect to. Set to null to connect to the static world.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set constraint position relative to own body.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set constraint rotation relative to own body.",
        returns = "()",
        type = "method"
      },
      SetAxis = {
        args = "(const Vector3& axis)",
        description = "Set constraint rotation relative to own body by specifying the axis.",
        returns = "()",
        type = "method"
      },
      SetOtherPosition = {
        args = "(const Vector3& position)",
        description = "Set constraint position relative to the other body. If connected to the static world, is a world space position.",
        returns = "()",
        type = "method"
      },
      SetOtherRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set constraint rotation relative to the other body. If connected to the static world, is a world space rotation.",
        returns = "()",
        type = "method"
      },
      SetOtherAxis = {
        args = "(const Vector3& axis)",
        description = "Set constraint rotation relative to the other body by specifying the axis.",
        returns = "()",
        type = "method"
      },
      SetWorldPosition = {
        args = "(const Vector3& position)",
        description = "Set constraint world space position. Resets both own and other body relative position, ie. zeroes the constraint error.",
        returns = "()",
        type = "method"
      },
      SetHighLimit = {
        args = "(const Vector2& limit)",
        description = "Set high limit. Interpretation is constraint type specific.",
        returns = "()",
        type = "method"
      },
      SetLowLimit = {
        args = "(const Vector2& limit)",
        description = "Set low limit. Interpretation is constraint type specific.",
        returns = "()",
        type = "method"
      },
      SetERP = {
        args = "(float erp)",
        description = "Set constraint error reduction parameter. Zero = leave to default.",
        returns = "()",
        type = "method"
      },
      SetCFM = {
        args = "(float cfm)",
        description = "Set constraint force mixing parameter. Zero = leave to default.",
        returns = "()",
        type = "method"
      },
      SetDisableCollision = {
        args = "(bool disable)",
        description = "Set whether to disable collisions between connected bodies.",
        returns = "()",
        type = "method"
      },
      GetPhysicsWorld = {
        args = "()",
        description = "Return physics world.",
        returns = "(PhysicsWorld*)",
        valuetype = "PhysicsWorld",
        type = "method"
      },
      GetConstraintType = {
        args = "()",
        description = "Return constraint type.",
        returns = "(ConstraintType)",
        type = "method"
      },
      GetOwnBody = {
        args = "()",
        description = "Return rigid body in own scene node.",
        returns = "(RigidBody*)",
        valuetype = "RigidBody",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return the other rigid body. May be null if connected to the static world.",
        returns = "(RigidBody*)",
        valuetype = "RigidBody",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return constraint position relative to own body.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return constraint rotation relative to own body.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetOtherPosition = {
        args = "()",
        description = "Return constraint position relative to other body.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetOtherRotation = {
        args = "()",
        description = "Return constraint rotation relative to other body.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetWorldPosition = {
        args = "()",
        description = "Return constraint world position, calculated from own body.",
        returns = "(Vector3)",
        type = "method"
      },
      GetHighLimit = {
        args = "()",
        description = "Return high limit.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetLowLimit = {
        args = "()",
        description = "Return low limit.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetERP = {
        args = "()",
        description = "Return constraint error reduction parameter.",
        returns = "(float)",
        type = "method"
      },
      GetCFM = {
        args = "()",
        description = "Return constraint force mixing parameter.",
        returns = "(float)",
        type = "method"
      },
      GetDisableCollision = {
        args = "()",
        description = "Return whether collisions between connected bodies are disabled.",
        returns = "(bool)",
        type = "method"
      },
      physicsWorld = {
        valuetype = "PhysicsWorld",
        description = "(Readonly) PhysicsWorld*\nPhysics world.",
        type = "value"
      },
      constraintType = {
        description = "ConstraintType\nConstraint type.",
        type = "value"
      },
      ownBody = {
        valuetype = "RigidBody",
        description = "(Readonly) RigidBody*\nOwn rigid body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody",
        description = "RigidBody*\nOther rigid body.",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&\nConstraint position.",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nConstraint rotation.",
        type = "value"
      },
      axis = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      otherPosition = {
        valuetype = "Vector3",
        description = "Vector3&\nConstraint other body position.",
        type = "value"
      },
      otherRotation = {
        valuetype = "Quaternion",
        description = "Quaternion&\nConstraint other body axis.",
        type = "value"
      },
      otherAxis = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      worldPosition = {
        description = "Vector3",
        type = "value"
      },
      highLimit = {
        valuetype = "Vector2",
        description = "Vector2&\nHigh limit.",
        type = "value"
      },
      lowLimit = {
        valuetype = "Vector2",
        description = "Vector2&\nLow limit.",
        type = "value"
      },
      ERP = {
        description = "float",
        type = "value"
      },
      CFM = {
        description = "float",
        type = "value"
      },
      disableCollision = {
        description = "bool\nDisable collision between connected bodies flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Constraint2D = {
    childs = {
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintDistance2D = {
    childs = {
      SetOwnerBodyAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set owner body anchor.",
        returns = "()",
        type = "method"
      },
      SetOtherBodyAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set other body anchor.",
        returns = "()",
        type = "method"
      },
      SetFrequencyHz = {
        args = "(float frequencyHz)",
        description = "Set frequency Hz.",
        returns = "()",
        type = "method"
      },
      SetDampingRatio = {
        args = "(float dampingRatio)",
        description = "Set damping ratio.",
        returns = "()",
        type = "method"
      },
      SetLength = {
        args = "(float length)",
        description = "Set length.",
        returns = "()",
        type = "method"
      },
      GetOwnerBodyAnchor = {
        args = "()",
        description = "Return owner body anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetOtherBodyAnchor = {
        args = "()",
        description = "Return other body anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetFrequencyHz = {
        args = "()",
        description = "Return frequency Hz.",
        returns = "(float)",
        type = "method"
      },
      GetDampingRatio = {
        args = "()",
        description = "Return damping ratio.",
        returns = "(float)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return length.",
        returns = "(float)",
        type = "method"
      },
      ownerBodyAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOwner body anchor.",
        type = "value"
      },
      otherBodyAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOther body anchor.",
        type = "value"
      },
      frequencyHz = {
        description = "float",
        type = "value"
      },
      dampingRatio = {
        description = "float",
        type = "value"
      },
      length = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintFriction2D = {
    childs = {
      SetAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set anchor.",
        returns = "()",
        type = "method"
      },
      SetMaxForce = {
        args = "(float maxForce)",
        description = "Set max force.",
        returns = "()",
        type = "method"
      },
      SetMaxTorque = {
        args = "(float maxTorque)",
        description = "Set max torque.",
        returns = "()",
        type = "method"
      },
      GetAnchor = {
        args = "()",
        description = "Return anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxForce = {
        args = "()",
        description = "Set max force.",
        returns = "(float)",
        type = "method"
      },
      GetMaxTorque = {
        args = "()",
        description = "Set max torque.",
        returns = "(float)",
        type = "method"
      },
      anchor = {
        valuetype = "Vector2",
        description = "Vector2&\nAnchor.",
        type = "value"
      },
      maxForce = {
        description = "float",
        type = "value"
      },
      maxTorque = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintGear2D = {
    childs = {
      SetOwnerConstraint = {
        args = "(Constraint2D* constraint)",
        description = "Set owner constraint.",
        returns = "()",
        type = "method"
      },
      SetOtherConstraint = {
        args = "(Constraint2D* constraint)",
        description = "Set other constraint.",
        returns = "()",
        type = "method"
      },
      SetRatio = {
        args = "(float ratio)",
        description = "Set ratio.",
        returns = "()",
        type = "method"
      },
      GetOwnerConstraint = {
        args = "()",
        description = "Return owner constraint.",
        returns = "(Constraint2D*)",
        valuetype = "Constraint2D",
        type = "method"
      },
      GetOtherConstraint = {
        args = "()",
        description = "Return other constraint.",
        returns = "(Constraint2D*)",
        valuetype = "Constraint2D",
        type = "method"
      },
      GetRatio = {
        args = "()",
        description = "Return ratio.",
        returns = "(float)",
        type = "method"
      },
      ownerConstraint = {
        valuetype = "Constraint2D",
        description = "Constraint2D*\nOwner body constraint.",
        type = "value"
      },
      otherConstraint = {
        valuetype = "Constraint2D",
        description = "Constraint2D*\nOther body constraint.",
        type = "value"
      },
      ratio = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintMotor2D = {
    childs = {
      SetLinearOffset = {
        args = "(const Vector2& linearOffset)",
        description = "Set linear offset.",
        returns = "()",
        type = "method"
      },
      SetAngularOffset = {
        args = "(float angularOffset)",
        description = "Set angular offset.",
        returns = "()",
        type = "method"
      },
      SetMaxForce = {
        args = "(float maxForce)",
        description = "Set max force.",
        returns = "()",
        type = "method"
      },
      SetMaxTorque = {
        args = "(float maxTorque)",
        description = "Set max torque.",
        returns = "()",
        type = "method"
      },
      SetCorrectionFactor = {
        args = "(float correctionFactor)",
        description = "Set correction factor.",
        returns = "()",
        type = "method"
      },
      GetLinearOffset = {
        args = "()",
        description = "Return linear offset.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetAngularOffset = {
        args = "()",
        description = "Return angular offset.",
        returns = "(float)",
        type = "method"
      },
      GetMaxForce = {
        args = "()",
        description = "Return max force.",
        returns = "(float)",
        type = "method"
      },
      GetMaxTorque = {
        args = "()",
        description = "Return max torque.",
        returns = "(float)",
        type = "method"
      },
      GetCorrectionFactor = {
        args = "()",
        description = "Return correction factor.",
        returns = "(float)",
        type = "method"
      },
      linearOffset = {
        valuetype = "Vector2",
        description = "Vector2&\nLinear offset.",
        type = "value"
      },
      angularOffset = {
        description = "float",
        type = "value"
      },
      maxForce = {
        description = "float",
        type = "value"
      },
      maxTorque = {
        description = "float",
        type = "value"
      },
      correctionFactor = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintMouse2D = {
    childs = {
      SetTarget = {
        args = "(const Vector2& target)",
        description = "Set target.",
        returns = "()",
        type = "method"
      },
      SetMaxForce = {
        args = "(float maxForce)",
        description = "Set max force.",
        returns = "()",
        type = "method"
      },
      SetFrequencyHz = {
        args = "(float frequencyHz)",
        description = "Set frequency Hz.",
        returns = "()",
        type = "method"
      },
      SetDampingRatio = {
        args = "(float dampingRatio)",
        description = "Set damping ratio.",
        returns = "()",
        type = "method"
      },
      GetTarget = {
        args = "()",
        description = "Return target.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxForce = {
        args = "()",
        description = "Return max force.",
        returns = "(float)",
        type = "method"
      },
      GetFrequencyHz = {
        args = "()",
        description = "Return frequency Hz.",
        returns = "(float)",
        type = "method"
      },
      GetDampingRatio = {
        args = "()",
        description = "Return damping ratio.",
        returns = "(float)",
        type = "method"
      },
      target = {
        valuetype = "Vector2",
        description = "Vector2&\nTarget.",
        type = "value"
      },
      maxForce = {
        description = "float",
        type = "value"
      },
      frequencyHz = {
        description = "float",
        type = "value"
      },
      dampingRatio = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintPrismatic2D = {
    childs = {
      SetAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set anchor.",
        returns = "()",
        type = "method"
      },
      SetAxis = {
        args = "(const Vector2& axis)",
        description = "Set axis.",
        returns = "()",
        type = "method"
      },
      SetEnableLimit = {
        args = "(bool enableLimit)",
        description = "Set enable limit.",
        returns = "()",
        type = "method"
      },
      SetLowerTranslation = {
        args = "(float lowerTranslation)",
        description = "Set lower translation.",
        returns = "()",
        type = "method"
      },
      SetUpperTranslation = {
        args = "(float upperTranslation)",
        description = "Set upper translation.",
        returns = "()",
        type = "method"
      },
      SetEnableMotor = {
        args = "(bool enableMotor)",
        description = "Set enable motor.",
        returns = "()",
        type = "method"
      },
      SetMaxMotorForce = {
        args = "(float maxMotorForce)",
        description = "Set maxmotor force.",
        returns = "()",
        type = "method"
      },
      SetMotorSpeed = {
        args = "(float motorSpeed)",
        description = "Set motor speed.",
        returns = "()",
        type = "method"
      },
      GetAnchor = {
        args = "()",
        description = "Return anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetAxis = {
        args = "()",
        description = "Return axis.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetEnableLimit = {
        args = "()",
        description = "Return enable limit.",
        returns = "(bool)",
        type = "method"
      },
      GetLowerTranslation = {
        args = "()",
        description = "Return lower translation.",
        returns = "(float)",
        type = "method"
      },
      GetUpperTranslation = {
        args = "()",
        description = "Return upper translation.",
        returns = "(float)",
        type = "method"
      },
      GetEnableMotor = {
        args = "()",
        description = "Return enable motor.",
        returns = "(bool)",
        type = "method"
      },
      GetMaxMotorForce = {
        args = "()",
        description = "Return maxmotor force.",
        returns = "(float)",
        type = "method"
      },
      GetMotorSpeed = {
        args = "()",
        description = "Return motor speed.",
        returns = "(float)",
        type = "method"
      },
      anchor = {
        valuetype = "Vector2",
        description = "Vector2&\nAnchor.",
        type = "value"
      },
      axis = {
        valuetype = "Vector2",
        description = "Vector2&\nAxis.",
        type = "value"
      },
      enableLimit = {
        description = "bool",
        type = "value"
      },
      lowerTranslation = {
        description = "float",
        type = "value"
      },
      upperTranslation = {
        description = "float",
        type = "value"
      },
      enableMotor = {
        description = "bool",
        type = "value"
      },
      maxMotorForce = {
        description = "float",
        type = "value"
      },
      motorSpeed = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintPulley2D = {
    childs = {
      SetOwnerBodyGroundAnchor = {
        args = "(const Vector2& groundAnchor)",
        description = "Set other body ground anchor point.",
        returns = "()",
        type = "method"
      },
      SetOtherBodyGroundAnchor = {
        args = "(const Vector2& groundAnchor)",
        description = "Set other body ground anchor point.",
        returns = "()",
        type = "method"
      },
      SetOwnerBodyAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set owner body anchor point.",
        returns = "()",
        type = "method"
      },
      SetOtherBodyAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set other body anchor point.",
        returns = "()",
        type = "method"
      },
      SetRatio = {
        args = "(float ratio)",
        description = "Set ratio.",
        returns = "()",
        type = "method"
      },
      GetOwnerBodyGroundAnchor = {
        args = "()",
        description = "Return owner body ground anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetOtherBodyGroundAnchor = {
        args = "()",
        description = "return other body ground anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetOwnerBodyAnchor = {
        args = "()",
        description = "Return owner body anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetOtherBodyAnchor = {
        args = "()",
        description = "Return other body anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetRatio = {
        args = "()",
        description = "Return ratio.",
        returns = "(float)",
        type = "method"
      },
      ownerBodyGroundAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOwner body ground anchor.",
        type = "value"
      },
      otherBodyGroundAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOther body ground anchor.",
        type = "value"
      },
      ownerBodyAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOwner body anchor.",
        type = "value"
      },
      otherBodyAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOther body anchor.",
        type = "value"
      },
      ratio = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintRevolute2D = {
    childs = {
      SetAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set anchor.",
        returns = "()",
        type = "method"
      },
      SetEnableLimit = {
        args = "(bool enableLimit)",
        description = "Set enable limit.",
        returns = "()",
        type = "method"
      },
      SetLowerAngle = {
        args = "(float lowerAngle)",
        description = "Set lower angle.",
        returns = "()",
        type = "method"
      },
      SetUpperAngle = {
        args = "(float upperAngle)",
        description = "Set upper angle.",
        returns = "()",
        type = "method"
      },
      SetEnableMotor = {
        args = "(bool enableMotor)",
        description = "Set enable motor.",
        returns = "()",
        type = "method"
      },
      SetMotorSpeed = {
        args = "(float motorSpeed)",
        description = "Set motor speed.",
        returns = "()",
        type = "method"
      },
      SetMaxMotorTorque = {
        args = "(float maxMotorTorque)",
        description = "Set max motor torque.",
        returns = "()",
        type = "method"
      },
      GetAnchor = {
        args = "()",
        description = "Return anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetEnableLimit = {
        args = "()",
        description = "Return enable limit.",
        returns = "(bool)",
        type = "method"
      },
      GetLowerAngle = {
        args = "()",
        description = "Return lower angle.",
        returns = "(float)",
        type = "method"
      },
      GetUpperAngle = {
        args = "()",
        description = "Return upper angle.",
        returns = "(float)",
        type = "method"
      },
      GetEnableMotor = {
        args = "()",
        description = "Return enable motor.",
        returns = "(bool)",
        type = "method"
      },
      GetMotorSpeed = {
        args = "()",
        description = "Return motor speed.",
        returns = "(float)",
        type = "method"
      },
      GetMaxMotorTorque = {
        args = "()",
        description = "Return max motor torque.",
        returns = "(float)",
        type = "method"
      },
      anchor = {
        valuetype = "Vector2",
        description = "Vector2&\nAnchor.",
        type = "value"
      },
      enableLimit = {
        description = "bool",
        type = "value"
      },
      lowerAngle = {
        description = "float",
        type = "value"
      },
      upperAngle = {
        description = "float",
        type = "value"
      },
      enableMotor = {
        description = "bool",
        type = "value"
      },
      motorSpeed = {
        description = "float",
        type = "value"
      },
      maxMotorTorque = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintRope2D = {
    childs = {
      SetOwnerBodyAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set owner body anchor.",
        returns = "()",
        type = "method"
      },
      SetOtherBodyAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set other body anchor.",
        returns = "()",
        type = "method"
      },
      SetMaxLength = {
        args = "(float maxLength)",
        description = "Set max length.",
        returns = "()",
        type = "method"
      },
      GetOwnerBodyAnchor = {
        args = "()",
        description = "Return owner body anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetOtherBodyAnchor = {
        args = "()",
        description = "Return other body anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxLength = {
        args = "()",
        description = "Return max length.",
        returns = "(float)",
        type = "method"
      },
      ownerBodyAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOwner body anchor.",
        type = "value"
      },
      otherBodyAnchor = {
        valuetype = "Vector2",
        description = "Vector2&\nOther body anchor.",
        type = "value"
      },
      maxLength = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintWeld2D = {
    childs = {
      SetAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set anchor.",
        returns = "()",
        type = "method"
      },
      SetFrequencyHz = {
        args = "(float frequencyHz)",
        description = "Set frequency Hz.",
        returns = "()",
        type = "method"
      },
      SetDampingRatio = {
        args = "(float dampingRatio)",
        description = "Set damping ratio.",
        returns = "()",
        type = "method"
      },
      GetAnchor = {
        args = "()",
        description = "Return anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetFrequencyHz = {
        args = "()",
        description = "Return frequency Hz.",
        returns = "(float)",
        type = "method"
      },
      GetDampingRatio = {
        args = "()",
        description = "Return damping ratio.",
        returns = "(float)",
        type = "method"
      },
      anchor = {
        valuetype = "Vector2",
        description = "Vector2&\nAnchor.",
        type = "value"
      },
      frequencyHz = {
        description = "float",
        type = "value"
      },
      dampingRatio = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ConstraintWheel2D = {
    childs = {
      SetAnchor = {
        args = "(const Vector2& anchor)",
        description = "Set anchor.",
        returns = "()",
        type = "method"
      },
      SetAxis = {
        args = "(const Vector2& axis)",
        description = "Set axis.",
        returns = "()",
        type = "method"
      },
      SetEnableMotor = {
        args = "(bool enableMotor)",
        description = "Set enable motor.",
        returns = "()",
        type = "method"
      },
      SetMaxMotorTorque = {
        args = "(float maxMotorTorque)",
        description = "Set max motor torque.",
        returns = "()",
        type = "method"
      },
      SetMotorSpeed = {
        args = "(float motorSpeed)",
        description = "Set motor speed.",
        returns = "()",
        type = "method"
      },
      SetFrequencyHz = {
        args = "(float frequencyHz)",
        description = "Set frequency Hz.",
        returns = "()",
        type = "method"
      },
      SetDampingRatio = {
        args = "(float dampingRatio)",
        description = "Set damping ratio.",
        returns = "()",
        type = "method"
      },
      GetAnchor = {
        args = "()",
        description = "Return anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetAxis = {
        args = "()",
        description = "Return axis.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetEnableMotor = {
        args = "()",
        description = "Return enable motor.",
        returns = "(bool)",
        type = "method"
      },
      GetMaxMotorTorque = {
        args = "()",
        description = "Return maxMotor torque.",
        returns = "(float)",
        type = "method"
      },
      GetMotorSpeed = {
        args = "()",
        description = "Return motor speed.",
        returns = "(float)",
        type = "method"
      },
      GetFrequencyHz = {
        args = "()",
        description = "Return frequency Hz.",
        returns = "(float)",
        type = "method"
      },
      GetDampingRatio = {
        args = "()",
        description = "Return damping ratio.",
        returns = "(float)",
        type = "method"
      },
      anchor = {
        valuetype = "Vector2",
        description = "Vector2&\nAnchor.",
        type = "value"
      },
      axis = {
        valuetype = "Vector2",
        description = "Vector2&\nAxis.",
        type = "value"
      },
      enableMotor = {
        description = "bool",
        type = "value"
      },
      maxMotorTorque = {
        description = "float",
        type = "value"
      },
      motorSpeed = {
        description = "float",
        type = "value"
      },
      frequencyHz = {
        description = "float",
        type = "value"
      },
      dampingRatio = {
        description = "float",
        type = "value"
      },
      SetOtherBody = {
        args = "(RigidBody2D* body)",
        description = "Set other rigid body.",
        returns = "()",
        type = "method"
      },
      SetCollideConnected = {
        args = "(bool collideConnected)",
        description = "Set collide connected.",
        returns = "()",
        type = "method"
      },
      GetOwnerBody = {
        args = "()",
        description = "Return owner body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetOtherBody = {
        args = "()",
        description = "Return other body.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetCollideConnected = {
        args = "()",
        description = "Return collide connected.",
        returns = "(bool)",
        type = "method"
      },
      ownerBody = {
        valuetype = "RigidBody2D",
        description = "(Readonly) RigidBody2D*\nOwner body.",
        type = "value"
      },
      otherBody = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*\nOther body.",
        type = "value"
      },
      collideConnected = {
        description = "bool\nCollide connected flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Context = {
    childs = {
      GetEventSender = {
        args = "()",
        returns = "(Object*)",
        valuetype = "Object",
        type = "method"
      },
      GetEventHandler = {
        args = "()",
        returns = "(EventHandler*)",
        valuetype = "EventHandler",
        type = "method"
      },
      GetTypeName = {
        args = "(StringHash objectType)",
        returns = "(const String)",
        type = "method"
      },
    },
    type = "class"
  },
  Controls = {
    childs = {
      new = {
        args = "()",
        returns = "(Controls*)",
        valuetype = "Controls",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Reset = {
        args = "()",
        description = "Reset to initial state.",
        returns = "()",
        type = "method"
      },
      Set = {
        args = "(unsigned buttons, bool down = true)",
        description = "Set or release buttons.",
        returns = "()",
        type = "method"
      },
      IsDown = {
        args = "(unsigned button)",
        returns = "(bool)",
        type = "method"
      },
      IsPressed = {
        args = "(unsigned button, const Controls& previousControls)",
        returns = "(bool)",
        type = "method"
      },
      buttons = {
        description = "unsigned",
        type = "value"
      },
      yaw = {
        description = "float",
        type = "value"
      },
      pitch = {
        description = "float",
        type = "value"
      },
      extraData = {
        description = "VariantMap",
        type = "value"
      },
    },
    type = "class"
  },
  CrowdAgent = {
    childs = {
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Draw debug geometry.",
        returns = "()",
        type = "method"
      },
      SetTargetPosition = {
        args = "(const Vector3& position)",
        description = "Submit a new target position request for this agent.",
        returns = "()",
        type = "method"
      },
      SetTargetVelocity = {
        args = "(const Vector3& velocity)",
        description = "Submit a new target velocity request for this agent.",
        returns = "()",
        type = "method"
      },
      ResetTarget = {
        args = "()",
        description = "Reset any target request for the specified agent. Note that the agent will continue to move into the current direction; set a zero target velocity to actually stop.",
        returns = "()",
        type = "method"
      },
      SetUpdateNodePosition = {
        args = "(bool unodepos)",
        description = "Update the node position. When set to false, the node position should be updated by other means (e.g. using Physics) in response to the E_CROWD_AGENT_REPOSITION event.",
        returns = "()",
        type = "method"
      },
      SetMaxAccel = {
        args = "(float maxAccel)",
        description = "Set the agent's max acceleration.",
        returns = "()",
        type = "method"
      },
      SetMaxSpeed = {
        args = "(float maxSpeed)",
        description = "Set the agent's max velocity.",
        returns = "()",
        type = "method"
      },
      SetRadius = {
        args = "(float radius)",
        description = "Set the agent's radius.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(float height)",
        description = "Set the agent's height.",
        returns = "()",
        type = "method"
      },
      SetQueryFilterType = {
        args = "(unsigned queryFilterType)",
        description = "Set the agent's query filter type.",
        returns = "()",
        type = "method"
      },
      SetObstacleAvoidanceType = {
        args = "(unsigned obstacleOvoidanceType)",
        description = "Set the agent's obstacle avoidance type.",
        returns = "()",
        type = "method"
      },
      SetNavigationQuality = {
        args = "(NavigationQuality val)",
        description = "Set the agent's navigation quality.",
        returns = "()",
        type = "method"
      },
      SetNavigationPushiness = {
        args = "(NavigationPushiness val)",
        description = "Set the agent's navigation pushiness.",
        returns = "()",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return the agent's position.",
        returns = "(Vector3)",
        type = "method"
      },
      GetDesiredVelocity = {
        args = "()",
        description = "Return the agent's desired velocity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetActualVelocity = {
        args = "()",
        description = "Return the agent's actual velocity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetTargetPosition = {
        args = "()",
        description = "Return the agent's requested target position.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetTargetVelocity = {
        args = "()",
        description = "Return the agent's requested target velocity.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetRequestedTargetType = {
        args = "()",
        description = "Return the agent's requested target type, if any.",
        returns = "(CrowdAgentRequestedTarget)",
        type = "method"
      },
      GetAgentState = {
        args = "()",
        description = "Return the agent's  state.",
        returns = "(CrowdAgentState)",
        type = "method"
      },
      GetTargetState = {
        args = "()",
        description = "Return the agent's target state.",
        returns = "(CrowdAgentTargetState)",
        type = "method"
      },
      GetUpdateNodePosition = {
        args = "()",
        description = "Return true when the node's position should be updated by the CrowdManager.",
        returns = "(bool)",
        type = "method"
      },
      GetMaxAccel = {
        args = "()",
        description = "Get the agent's max acceleration.",
        returns = "(float)",
        type = "method"
      },
      GetMaxSpeed = {
        args = "()",
        description = "Get the agent's max velocity.",
        returns = "(float)",
        type = "method"
      },
      GetRadius = {
        args = "()",
        description = "Get the agent's radius.",
        returns = "(float)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Get the agent's height.",
        returns = "(float)",
        type = "method"
      },
      GetQueryFilterType = {
        args = "()",
        description = "Get the agent's query filter type.",
        returns = "(unsigned)",
        type = "method"
      },
      GetObstacleAvoidanceType = {
        args = "()",
        description = "Get the agent's obstacle avoidance type.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNavigationQuality = {
        args = "()",
        description = "Get the agent's navigation quality.",
        returns = "(NavigationQuality)",
        type = "method"
      },
      GetNavigationPushiness = {
        args = "()",
        description = "Get the agent's navigation pushiness.",
        returns = "(NavigationPushiness)",
        type = "method"
      },
      HasRequestedTarget = {
        args = "()",
        description = "Return true when the agent has a target.",
        returns = "(bool)",
        type = "method"
      },
      HasArrived = {
        args = "()",
        description = "Return true when the agent has arrived at its target.",
        returns = "(bool)",
        type = "method"
      },
      IsInCrowd = {
        args = "()",
        description = "Return true when the agent is in crowd (being managed by a crowd manager).",
        returns = "(bool)",
        type = "method"
      },
      targetPosition = {
        description = "Vector3\nRequested target position.",
        type = "value"
      },
      targetVelocity = {
        description = "Vector3\nRequested target velocity.",
        type = "value"
      },
      updateNodePosition = {
        description = "bool\nFlag indicating the node's position should be updated by Detour crowd manager.",
        type = "value"
      },
      maxAccel = {
        description = "float\nAgent's max acceleration.",
        type = "value"
      },
      maxSpeed = {
        description = "float\nAgent's max Velocity.",
        type = "value"
      },
      radius = {
        description = "float\nAgent's radius, if 0 the navigation mesh's setting will be used.",
        type = "value"
      },
      height = {
        description = "float\nAgent's height, if 0 the navigation mesh's setting will be used.",
        type = "value"
      },
      queryFilterType = {
        description = "unsigned\nAgent's query filter type, it is an index to the query filter buffer configured in Detour crowd manager.",
        type = "value"
      },
      obstacleAvoidanceType = {
        description = "unsigned\nAgent's obstacle avoidance type, it is an index to the obstacle avoidance array configured in Detour crowd manager. It is ignored when agent's navigation quality is not set to \"NAVIGATIONQUALITY_HIGH\".",
        type = "value"
      },
      navigationQuality = {
        description = "NavigationQuality",
        type = "value"
      },
      navigationPushiness = {
        description = "NavigationPushiness",
        type = "value"
      },
      position = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      desiredVelocity = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      actualVelocity = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      requestedTargetType = {
        description = "(Readonly) CrowdAgentRequestedTarget\nRequested target type.",
        type = "value"
      },
      agentState = {
        description = "(Readonly) CrowdAgentState",
        type = "value"
      },
      targetState = {
        description = "(Readonly) CrowdAgentTargetState",
        type = "value"
      },
      requestedTarget = {
        description = "(Readonly) bool",
        type = "value"
      },
      arrived = {
        description = "(Readonly) bool",
        type = "value"
      },
      inCrowd = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CrowdManager = {
    childs = {
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      SetCrowdTarget = {
        args = "(const Vector3& position, Node* node = 0)",
        description = "Set the crowd target position. The target position is set to all crowd agents found in the specified node. Defaulted to scene node.",
        returns = "()",
        type = "method"
      },
      SetCrowdVelocity = {
        args = "(const Vector3& velocity, Node* node = 0)",
        description = "Set the crowd move velocity. The move velocity is applied to all crowd agents found in the specified node. Defaulted to scene node.",
        returns = "()",
        type = "method"
      },
      ResetCrowdTarget = {
        args = "(Node* node = 0)",
        description = "Reset any crowd target for all crowd agents found in the specified node. Defaulted to scene node.",
        returns = "()",
        type = "method"
      },
      SetMaxAgents = {
        args = "(unsigned agentCt)",
        description = "Set the maximum number of agents.",
        returns = "()",
        type = "method"
      },
      SetMaxAgentRadius = {
        args = "(float maxAgentRadius)",
        description = "Set the maximum radius of any agent.",
        returns = "()",
        type = "method"
      },
      SetNavigationMesh = {
        args = "(NavigationMesh* navMesh)",
        description = "Assigns the navigation mesh for the crowd.",
        returns = "()",
        type = "method"
      },
      SetIncludeFlags = {
        args = "(unsigned queryFilterType, short flags)",
        returns = "()",
        type = "method"
      },
      SetExcludeFlags = {
        args = "(unsigned queryFilterType, short flags)",
        returns = "()",
        type = "method"
      },
      SetAreaCost = {
        args = "(unsigned queryFilterType, unsigned areaID, float cost)",
        description = "Set the cost of an area for the specified query filter type.",
        returns = "()",
        type = "method"
      },
      SetObstacleAvoidanceParams = {
        args = "(unsigned obstacleAvoidanceType, const CrowdObstacleAvoidanceParams& params)",
        description = "Set the params for the specified obstacle avoidance type.",
        returns = "()",
        type = "method"
      },
      GetAgents = {
        args = "(Node* node = 0, bool inCrowdFilter = true)",
        description = "Get all the crowd agent components in the specified node hierarchy. If the node is not specified then use scene node. When inCrowdFilter is set to true then only get agents that are in the crowd.",
        returns = "(PODVector<CrowdAgent*>)",
        type = "method"
      },
      FindNearestPoint = {
        args = "(const Vector3& point, int queryFilterType)",
        description = "Find the nearest point on the navigation mesh to a given point using the crowd initialized query extent (based on maxAgentRadius) and the specified query filter type.",
        returns = "(Vector3)",
        type = "method"
      },
      MoveAlongSurface = {
        args = "(const Vector3& start, const Vector3& end, int queryFilterType, int maxVisited = 3)",
        description = "Try to move along the surface from one point to another using the crowd initialized query extent (based on maxAgentRadius) and the specified query filter type.",
        returns = "(Vector3)",
        type = "method"
      },
      FindPath = {
        args = "(const Vector3& start, const Vector3& end, int queryFilterType)",
        returns = "(const PODVector<Vector3>&)",
        valuetype = "PODVector<Vector3>",
        type = "method"
      },
      GetRandomPoint = {
        args = "(int queryFilterType)",
        description = "Return a random point on the navigation mesh using the crowd initialized query extent (based on maxAgentRadius) and the specified query filter type.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRandomPointInCircle = {
        args = "(const Vector3& center, float radius, int queryFilterType)",
        description = "Return a random point on the navigation mesh within a circle using the crowd initialized query extent (based on maxAgentRadius) and the specified query filter type. The circle radius is only a guideline and in practice the returned point may be further away.",
        returns = "(Vector3)",
        type = "method"
      },
      GetDistanceToWall = {
        args = "(const Vector3& point, float radius, int queryFilterType, Vector3* hitPos = 0, Vector3* hitNormal = 0)",
        description = "Return distance to wall from a point using the crowd initialized query extent (based on maxAgentRadius) and the specified query filter type. Maximum search radius must be specified.",
        returns = "(float)",
        type = "method"
      },
      Raycast = {
        args = "(const Vector3& start, const Vector3& end, int queryFilterType, Vector3* hitNormal = 0)",
        description = "Perform a walkability raycast on the navigation mesh between start and end using the crowd initialized query extent (based on maxAgentRadius) and the specified query filter type. Return the point where a wall was hit, or the end point if no walls.",
        returns = "(Vector3)",
        type = "method"
      },
      GetMaxAgents = {
        args = "()",
        description = "Get the maximum number of agents.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxAgentRadius = {
        args = "()",
        description = "Get the maximum radius of any agent.",
        returns = "(float)",
        type = "method"
      },
      GetNavigationMesh = {
        args = "()",
        description = "Get the Navigation mesh assigned to the crowd.",
        returns = "(NavigationMesh*)",
        valuetype = "NavigationMesh",
        type = "method"
      },
      GetNumQueryFilterTypes = {
        args = "()",
        description = "Get the number of configured query filter types.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumAreas = {
        args = "(unsigned queryFilterType)",
        description = "Get the number of configured area in the specified query filter type.",
        returns = "(unsigned)",
        type = "method"
      },
      GetIncludeFlags = {
        args = "(unsigned queryFilterType)",
        description = "Get the include flags for the specified query filter type.",
        returns = "(short)",
        type = "method"
      },
      GetExcludeFlags = {
        args = "(unsigned queryFilterType)",
        description = "Get the exclude flags for the specified query filter type.",
        returns = "(short)",
        type = "method"
      },
      GetAreaCost = {
        args = "(unsigned queryFilterType, unsigned areaID)",
        description = "Get the cost of an area for the specified query filter type.",
        returns = "(float)",
        type = "method"
      },
      GetNumObstacleAvoidanceTypes = {
        args = "()",
        description = "Get the number of configured obstacle avoidance types.",
        returns = "(unsigned)",
        type = "method"
      },
      GetObstacleAvoidanceParams = {
        args = "(unsigned obstacleAvoidanceType)",
        description = "Get the params for the specified obstacle avoidance type.",
        returns = "(const CrowdObstacleAvoidanceParams&)",
        valuetype = "CrowdObstacleAvoidanceParams",
        type = "method"
      },
      maxAgents = {
        description = "int\nThe maximum number of agents the crowd can manage.",
        type = "value"
      },
      maxAgentRadius = {
        description = "float\nThe maximum radius of any agent that will be added to the crowd.",
        type = "value"
      },
      navigationMesh = {
        valuetype = "NavigationMesh",
        description = "NavigationMesh*\nNavigationMesh for which the crowd was created.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Cursor = {
    childs = {
      new = {
        args = "()",
        returns = "(Cursor*)",
        valuetype = "Cursor",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      DefineShape = {
        args = "(const String shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot)",
        description = "() DefineShape (CursorShape shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot)\nDefine a shape.",
        returns = "()",
        type = "method"
      },
      SetShape = {
        args = "(CursorShape shape)",
        description = "() SetShape (const String shape)\nSet current shape.",
        returns = "()",
        type = "method"
      },
      SetUseSystemShapes = {
        args = "(bool enable)",
        description = "Set whether to use system default shapes. Is only possible when the OS mouse cursor has been set visible from the Input subsystem.",
        returns = "()",
        type = "method"
      },
      GetShape = {
        args = "()",
        description = "Get current shape.",
        returns = "(String)",
        type = "method"
      },
      GetUseSystemShapes = {
        args = "()",
        description = "Return whether is using system default shapes.",
        returns = "(bool)",
        type = "method"
      },
      shape = {
        description = "String\nCurrent shape definition.",
        type = "value"
      },
      useSystemShapes = {
        description = "bool\nUse system default shapes flag.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CustomGeometry = {
    childs = {
      Clear = {
        args = "()",
        description = "Clear all geometries.",
        returns = "()",
        type = "method"
      },
      SetNumGeometries = {
        args = "(unsigned num)",
        description = "Set number of geometries.",
        returns = "()",
        type = "method"
      },
      SetDynamic = {
        args = "(bool enable)",
        description = "Set vertex buffer dynamic mode. A dynamic buffer should be faster to update frequently. Effective at the next Commit() call.",
        returns = "()",
        type = "method"
      },
      BeginGeometry = {
        args = "(unsigned index, PrimitiveType type)",
        description = "Begin defining a geometry. Clears existing vertices in that index.",
        returns = "()",
        type = "method"
      },
      DefineVertex = {
        args = "(const Vector3& position)",
        description = "Define a vertex position. This begins a new vertex.",
        returns = "()",
        type = "method"
      },
      DefineNormal = {
        args = "(const Vector3& normal)",
        description = "Define a vertex normal.",
        returns = "()",
        type = "method"
      },
      DefineTangent = {
        args = "(const Vector4& tangent)",
        description = "Define a vertex tangent.",
        returns = "()",
        type = "method"
      },
      DefineColor = {
        args = "(const Color& color)",
        description = "Define a vertex color.",
        returns = "()",
        type = "method"
      },
      DefineTexCoord = {
        args = "(const Vector2& texCoord)",
        description = "Define a vertex UV coordinate.",
        returns = "()",
        type = "method"
      },
      DefineGeometry = {
        args = "(unsigned index, PrimitiveType type, unsigned numVertices, bool hasNormals, bool hasColors, bool hasTexCoords, bool hasTangents)",
        returns = "()",
        type = "method"
      },
      Commit = {
        args = "()",
        description = "Update vertex buffer and calculate the bounding box. Call after finishing defining geometry.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumVertices = {
        args = "(unsigned index)",
        description = "Return number of vertices in a geometry.",
        returns = "(unsigned)",
        type = "method"
      },
      IsDynamic = {
        args = "()",
        description = "Return whether vertex buffer dynamic mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetVertex = {
        args = "(unsigned geometryIndex, unsigned vertexNum)",
        description = "Return a vertex in a geometry for editing, or null if out of bounds. After the edits are finished, calling Commit() updates  the vertex buffer.",
        returns = "(CustomGeometryVertex*)",
        valuetype = "CustomGeometryVertex",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numGeometries = {
        description = "unsigned",
        type = "value"
      },
      dynamic = {
        description = "bool\nVertex buffer dynamic flag.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  CustomGeometryVertex = {
    childs = {
      position = {
        description = "Vector3",
        type = "value"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      color = {
        description = "unsigned",
        type = "value"
      },
      texCoord = {
        description = "Vector2",
        type = "value"
      },
      tangent = {
        description = "Vector4",
        type = "value"
      },
    },
    type = "class"
  },
  Database = {
    childs = {
      Connect = {
        args = "(const String connectionString)",
        description = "Create new database connection. Return 0 if failed.",
        returns = "(DbConnection*)",
        valuetype = "DbConnection",
        type = "method"
      },
      Disconnect = {
        args = "(DbConnection* connection)",
        description = "Disconnect a database connection. The connection object pointer should not be used anymore after this.",
        returns = "()",
        type = "method"
      },
      IsPooling = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetPoolSize = {
        args = "()",
        description = "Get internal database connection pool size.",
        returns = "(unsigned)",
        type = "method"
      },
      SetPoolSize = {
        args = "(unsigned poolSize)",
        description = "Set internal database connection pool size.",
        returns = "()",
        type = "method"
      },
      pooling = {
        description = "(Readonly) bool",
        type = "value"
      },
      poolSize = {
        description = "unsigned\n%Database connection pool size. Default to 0 when using ODBC 3.0 or later as ODBC 3.0 driver manager could manage its own database connection pool.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DbConnection = {
    childs = {
      Finalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Execute = {
        args = "(const String sql, bool useCursorEvent = false)",
        returns = "(DbResult)",
        type = "method"
      },
      GetConnectionString = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      IsConnected = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      connectionString = {
        description = "(Readonly) const String",
        type = "value"
      },
      connected = {
        description = "(Readonly) bool",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DbResult = {
    childs = {
      GetNumColumns = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumAffectedRows = {
        args = "()",
        returns = "(long)",
        type = "method"
      },
      numColumns = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numRows = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numAffectedRows = {
        description = "(Readonly) long",
        type = "value"
      },
    },
    type = "class"
  },
  DebugHud = {
    childs = {
      Update = {
        args = "()",
        description = "Update. Called by HandlePostUpdate().",
        returns = "()",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set UI elements' style from an XML file.",
        returns = "()",
        type = "method"
      },
      SetMode = {
        args = "(unsigned mode)",
        description = "Set elements to show.",
        returns = "()",
        type = "method"
      },
      SetProfilerMaxDepth = {
        args = "(unsigned depth)",
        description = "Set maximum profiler block depth, default unlimited.",
        returns = "()",
        type = "method"
      },
      SetProfilerInterval = {
        args = "(float interval)",
        description = "Set profiler accumulation interval in seconds.",
        returns = "()",
        type = "method"
      },
      SetUseRendererStats = {
        args = "(bool enable)",
        description = "Set whether to show 3D geometry primitive/batch count only. Default false.",
        returns = "()",
        type = "method"
      },
      Toggle = {
        args = "(unsigned mode)",
        description = "Toggle elements.",
        returns = "()",
        type = "method"
      },
      ToggleAll = {
        args = "()",
        description = "Toggle all elements.",
        returns = "()",
        type = "method"
      },
      GetDefaultStyle = {
        args = "()",
        description = "Return the UI style file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetStatsText = {
        args = "()",
        description = "Return rendering stats text.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetModeText = {
        args = "()",
        description = "Return rendering mode text.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetProfilerText = {
        args = "()",
        description = "Return profiler text.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetMode = {
        args = "()",
        description = "Return currently shown elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetProfilerMaxDepth = {
        args = "()",
        description = "Return maximum profiler block depth.",
        returns = "(unsigned)",
        type = "method"
      },
      GetProfilerInterval = {
        args = "()",
        description = "Return profiler accumulation interval in seconds",
        returns = "(float)",
        type = "method"
      },
      GetUseRendererStats = {
        args = "()",
        description = "Return whether showing 3D geometry primitive/batch count only.",
        returns = "(bool)",
        type = "method"
      },
      SetAppStats = {
        args = "(const String label, const Variant stats)",
        description = "() SetAppStats (const String label, const String stats)\nSet application-specific stats.",
        returns = "()",
        type = "method"
      },
      ResetAppStats = {
        args = "(const String label)",
        description = "Reset application-specific stats. Return true if it was erased successfully.",
        returns = "(bool)",
        type = "method"
      },
      ClearAppStats = {
        args = "()",
        description = "Clear all application-specific stats.",
        returns = "()",
        type = "method"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*",
        type = "value"
      },
      statsText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nRendering stats text.",
        type = "value"
      },
      modeText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nRendering mode text.",
        type = "value"
      },
      profilerText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nProfiling information text.",
        type = "value"
      },
      mode = {
        description = "unsigned\nCurrent shown-element mode.",
        type = "value"
      },
      profilerMaxDepth = {
        description = "unsigned\nProfiler max block depth.",
        type = "value"
      },
      profilerInterval = {
        description = "float\nProfiler accumulation interval.",
        type = "value"
      },
      useRendererStats = {
        description = "bool\nShow 3D geometry primitive/batch count flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DebugRenderer = {
    childs = {
      SetLineAntiAlias = {
        args = "(bool enable)",
        description = "Set line antialiasing on/off. Default false.",
        returns = "()",
        type = "method"
      },
      SetView = {
        args = "(Camera* camera)",
        description = "Set the camera viewpoint. Call before rendering, or before adding geometry if you want to use culling.",
        returns = "()",
        type = "method"
      },
      AddLine = {
        args = "(const Vector3& start, const Vector3& end, const Color& color, bool depthTest = true)",
        description = "() AddLine (const Vector3& start, const Vector3& end, unsigned color, bool depthTest = true)\nAdd a line.",
        returns = "()",
        type = "method"
      },
      AddTriangle = {
        args = "(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Color& color, bool depthTest = true)",
        description = "() AddTriangle (const Vector3& v1, const Vector3& v2, const Vector3& v3, unsigned color, bool depthTest = true)\nAdd a solid triangle.",
        returns = "()",
        type = "method"
      },
      AddPolygon = {
        args = "(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, const Color& color, bool depthTest = true)",
        description = "() AddPolygon (const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, unsigned color, bool depthTest = true)\nAdd a solid quadrangular polygon.",
        returns = "()",
        type = "method"
      },
      AddNode = {
        args = "(Node* node, float scale = 1.0f, bool depthTest = true)",
        description = "Add a scene node represented as its coordinate axes.",
        returns = "()",
        type = "method"
      },
      AddBoundingBox = {
        args = "(const BoundingBox& box, const Color& color, bool depthTest = true, bool solid = false)",
        description = "() AddBoundingBox (const BoundingBox& box, const Matrix3x4& transform, const Color& color, bool depthTest = true, bool solid = false)\nAdd a bounding box.",
        returns = "()",
        type = "method"
      },
      AddFrustum = {
        args = "(const Frustum& frustum, const Color& color, bool depthTest = true)",
        description = "Add a frustum.",
        returns = "()",
        type = "method"
      },
      AddPolyhedron = {
        args = "(const Polyhedron& poly, const Color& color, bool depthTest = true)",
        description = "Add a polyhedron.",
        returns = "()",
        type = "method"
      },
      AddSphere = {
        args = "(const Sphere& sphere, const Color& color, bool depthTest = true)",
        description = "Add a sphere.",
        returns = "()",
        type = "method"
      },
      AddSkeleton = {
        args = "(const Skeleton& skeleton, const Color& color, bool depthTest = true)",
        description = "Add a skeleton.",
        returns = "()",
        type = "method"
      },
      AddTriangleMesh = {
        args = "(const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount, const Matrix3x4& transform, const Color& color, bool depthTest = true)",
        returns = "()",
        type = "method"
      },
      AddCircle = {
        args = "(const Vector3& center, const Vector3& normal, float radius, const Color& color, int steps = 64, bool depthTest = true)",
        description = "Add a circle.",
        returns = "()",
        type = "method"
      },
      AddCross = {
        args = "(const Vector3& center, float size, const Color& color, bool depthTest = true)",
        description = "Add a cross.",
        returns = "()",
        type = "method"
      },
      AddQuad = {
        args = "(const Vector3& center, float width, float height, const Color& color, bool depthTest = true)",
        description = "Add a quad on the XZ plane.",
        returns = "()",
        type = "method"
      },
      Render = {
        args = "()",
        description = "Update vertex buffer and render all debug lines. The viewport and rendertarget should be set before.",
        returns = "()",
        type = "method"
      },
      GetLineAntiAlias = {
        args = "()",
        description = "Return whether line antialiasing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetView = {
        args = "()",
        description = "Return the view transform.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetProjection = {
        args = "()",
        description = "Return the projection transform.",
        returns = "(const Matrix4&)",
        valuetype = "Matrix4",
        type = "method"
      },
      GetFrustum = {
        args = "()",
        description = "Return the view frustum.",
        returns = "(const Frustum&)",
        valuetype = "Frustum",
        type = "method"
      },
      IsInside = {
        args = "(const BoundingBox& box)",
        description = "Check whether a bounding box is inside the view frustum.",
        returns = "(bool)",
        type = "method"
      },
      lineAntiAlias = {
        description = "bool\nLine antialiasing flag.",
        type = "value"
      },
      view = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&\nView transform.",
        type = "value"
      },
      projection = {
        valuetype = "Matrix4",
        description = "(Readonly) Matrix4&\nProjection transform.",
        type = "value"
      },
      frustum = {
        valuetype = "Frustum",
        description = "(Readonly) Frustum&\nView frustum.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DecalSet = {
    childs = {
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material. The material should use a small negative depth bias to avoid Z-fighting.",
        returns = "()",
        type = "method"
      },
      SetMaxVertices = {
        args = "(unsigned num)",
        description = "Set maximum number of decal vertices.",
        returns = "()",
        type = "method"
      },
      SetMaxIndices = {
        args = "(unsigned num)",
        description = "Set maximum number of decal vertex indices.",
        returns = "()",
        type = "method"
      },
      SetOptimizeBufferSize = {
        args = "(bool enable)",
        description = "Set whether to optimize GPU buffer sizes according to current amount of decals. Default false, which will size the buffers according to the maximum vertices/indices. When true, buffers will be reallocated whenever decals are added/removed, which can be worse for performance.",
        returns = "()",
        type = "method"
      },
      AddDecal = {
        args = "(Drawable* target, const Vector3& worldPosition, const Quaternion& worldRotation, float size, float aspectRatio, float depth, const Vector2& topLeftUV, const Vector2& bottomRightUV, float timeToLive = 0.0f, float normalCutoff = 0.1f, unsigned subGeometry = M_MAX_UNSIGNED)",
        returns = "(bool)",
        type = "method"
      },
      RemoveDecals = {
        args = "(unsigned num)",
        description = "Remove n oldest decals.",
        returns = "()",
        type = "method"
      },
      RemoveAllDecals = {
        args = "()",
        description = "Remove all decals.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumDecals = {
        args = "()",
        description = "Return number of decals.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumVertices = {
        args = "()",
        description = "Retur number of vertices in the decals.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumIndices = {
        args = "()",
        description = "Retur number of vertex indices in the decals.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxVertices = {
        args = "()",
        description = "Return maximum number of decal vertices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxIndices = {
        args = "()",
        description = "Return maximum number of decal vertex indices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetOptimizeBufferSize = {
        args = "()",
        description = "Return whether is optimizing GPU buffer sizes according to current amount of decals.",
        returns = "(bool)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numDecals = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numVertices = {
        description = "(Readonly) unsigned\nVertices in the current decals.",
        type = "value"
      },
      numIndices = {
        description = "(Readonly) unsigned\nIndices in the current decals.",
        type = "value"
      },
      maxVertices = {
        description = "unsigned\nMaximum vertices.",
        type = "value"
      },
      maxIndices = {
        description = "unsigned\nMaximum indices.",
        type = "value"
      },
      optimizeBufferSize = {
        description = "bool\nOptimize buffer sizes flag.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Deserializer = {
    childs = {
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the stream.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name of the stream.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return a checksum if applicable.",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return current position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        description = "Return whether the end of stream has been reached.",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        description = "Read a 32-bit integer.",
        returns = "(int)",
        type = "method"
      },
      ReadInt64 = {
        args = "()",
        description = "Read a 64-bit integer.",
        returns = "(long)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        description = "Read a 16-bit integer.",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        description = "Read an 8-bit integer.",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        description = "Read a 32-bit unsigned integer.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUInt64 = {
        args = "()",
        description = "Read a 64-bit unsigned integer.",
        returns = "(long)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        description = "Read a 16-bit unsigned integer.",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        description = "Read an 8-bit unsigned integer.",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        description = "Read a bool.",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        description = "Read a float.",
        returns = "(float)",
        type = "method"
      },
      ReadDouble = {
        args = "()",
        description = "Read a double.",
        returns = "(double)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        description = "Read an IntRect.",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        description = "Read an IntVector2.",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadIntVector3 = {
        args = "()",
        description = "Read an IntVector3.",
        returns = "(IntVector3)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        description = "Read a Rect.",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        description = "Read a Vector2.",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        description = "Read a Vector3.",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        description = "Read a Vector3 packed into 3 x 16 bits with the specified maximum absolute range.",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        description = "Read a Vector4.",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        description = "Read a quaternion.",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        description = "Read a quaternion with each component packed in 16 bits.",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadMatrix3 = {
        args = "()",
        description = "Read a Matrix3.",
        returns = "(Matrix3)",
        type = "method"
      },
      ReadMatrix3x4 = {
        args = "()",
        description = "Read a Matrix3x4.",
        returns = "(Matrix3x4)",
        type = "method"
      },
      ReadMatrix4 = {
        args = "()",
        description = "Read a Matrix4.",
        returns = "(Matrix4)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        description = "Read a color.",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        description = "Read a bounding box.",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        description = "Read a null-terminated string.",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        description = "Read a four-letter file ID.",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        description = "Read a 32-bit StringHash.",
        returns = "(StringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        description = "Read a buffer with size encoded as VLE.",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        description = "Read a resource reference.",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        description = "Read a resource reference list.",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)\nRead a variant.",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        description = "Read a variant vector.",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        description = "Read a variant map.",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        description = "Read a variable-length encoded unsigned integer, which can use 29 bits maximum.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        description = "Read a 24-bit network object ID.",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        description = "Read a text line.",
        returns = "(String)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned\nStream position.",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned\nStream size.",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  Drawable = {
    childs = {
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Drawable2D = {
    childs = {
      SetLayer = {
        args = "(int layer)",
        description = "Set layer.",
        returns = "()",
        type = "method"
      },
      SetOrderInLayer = {
        args = "(int orderInLayer)",
        description = "Set order in layer.",
        returns = "()",
        type = "method"
      },
      GetLayer = {
        args = "()",
        description = "Return layer.",
        returns = "(int)",
        type = "method"
      },
      GetOrderInLayer = {
        args = "()",
        description = "Return order in layer.",
        returns = "(int)",
        type = "method"
      },
      layer = {
        description = "int\nLayer.",
        type = "value"
      },
      orderInLayer = {
        description = "int\nOrder in layer.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DropDownList = {
    childs = {
      new = {
        args = "()",
        returns = "(DropDownList*)",
        valuetype = "DropDownList",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      AddItem = {
        args = "(UIElement* item)",
        description = "Add item to the end of the list.",
        returns = "()",
        type = "method"
      },
      InsertItem = {
        args = "(unsigned index, UIElement* item)",
        description = "Insert item to a specific position.",
        returns = "()",
        type = "method"
      },
      RemoveItem = {
        args = "(UIElement* item)",
        description = "() RemoveItem (unsigned index)\nRemove specific item.",
        returns = "()",
        type = "method"
      },
      RemoveAllItems = {
        args = "()",
        description = "Remove all items.",
        returns = "()",
        type = "method"
      },
      SetSelection = {
        args = "(unsigned index)",
        description = "Set selection.",
        returns = "()",
        type = "method"
      },
      SetPlaceholderText = {
        args = "(const String text)",
        description = "Set place holder text. This is the text shown when there is no selection (-1) in drop down list. Note that if the list has items, the default is to show the first item, so the \"no selection\" state has to be set explicitly.",
        returns = "()",
        type = "method"
      },
      SetResizePopup = {
        args = "(bool enable)",
        description = "Set whether popup should be automatically resized to match the dropdown button width.",
        returns = "()",
        type = "method"
      },
      GetNumItems = {
        args = "()",
        description = "Return number of items.",
        returns = "(unsigned)",
        type = "method"
      },
      GetItem = {
        args = "(unsigned index)",
        description = "Return item at index.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetItems = {
        args = "()",
        description = "Return all items.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      GetSelection = {
        args = "()",
        description = "Return selection index, or M_MAX_UNSIGNED if none selected.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelectedItem = {
        args = "()",
        description = "Return selected item, or null if none selected.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetListView = {
        args = "()",
        description = "Return listview element.",
        returns = "(ListView*)",
        valuetype = "ListView",
        type = "method"
      },
      GetPlaceholder = {
        args = "()",
        description = "Return selected item placeholder element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetPlaceholderText = {
        args = "()",
        description = "Return place holder text.",
        returns = "(const String)",
        type = "method"
      },
      GetResizePopup = {
        args = "()",
        description = "Return whether popup should be automatically resized.",
        returns = "(bool)",
        type = "method"
      },
      numItems = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      selection = {
        description = "unsigned",
        type = "value"
      },
      selectedItem = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      listView = {
        valuetype = "ListView",
        description = "(Readonly) ListView*\nListview element.",
        type = "value"
      },
      placeholder = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nSelected item placeholder element.",
        type = "value"
      },
      placeholderText = {
        description = "String",
        type = "value"
      },
      resizePopup = {
        description = "bool\nResize popup flag.",
        type = "value"
      },
      SetPopup = {
        args = "(UIElement* element)",
        description = "Set popup element to show on selection.",
        returns = "()",
        type = "method"
      },
      SetPopupOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPopupOffset (int x, int y)\nSet popup element offset.",
        returns = "()",
        type = "method"
      },
      ShowPopup = {
        args = "(bool enable)",
        description = "Force the popup to show or hide.",
        returns = "()",
        type = "method"
      },
      SetAccelerator = {
        args = "(int key, int qualifiers)",
        description = "Set accelerator key (set zero key code to disable.)",
        returns = "()",
        type = "method"
      },
      GetPopup = {
        args = "()",
        description = "Return popup element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetPopupOffset = {
        args = "()",
        description = "Return popup element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetShowPopup = {
        args = "()",
        description = "Return whether popup is open.",
        returns = "(bool)",
        type = "method"
      },
      GetAcceleratorKey = {
        args = "()",
        description = "Return accelerator key code, 0 if disabled.",
        returns = "(int)",
        type = "method"
      },
      GetAcceleratorQualifiers = {
        args = "()",
        description = "Return accelerator qualifiers.",
        returns = "(int)",
        type = "method"
      },
      popup = {
        valuetype = "UIElement",
        description = "UIElement*\nPopup element.",
        type = "value"
      },
      popupOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPopup element offset.",
        type = "value"
      },
      showPopup = {
        description = "bool\nShow popup flag.",
        type = "value"
      },
      acceleratorKey = {
        description = "(Readonly) int\nAccelerator key code.",
        type = "value"
      },
      acceleratorQualifiers = {
        description = "(Readonly) int\nAccelerator qualifiers.",
        type = "value"
      },
      SetPressedOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedOffset (int x, int y)\nSet offset to image rectangle used when pressed.",
        returns = "()",
        type = "method"
      },
      SetPressedChildOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedChildOffset (int x, int y)\nSet offset of child elements when pressed.",
        returns = "()",
        type = "method"
      },
      SetRepeat = {
        args = "(float delay, float rate)",
        description = "Set repeat properties. Rate 0 (default) disables repeat.",
        returns = "()",
        type = "method"
      },
      SetRepeatDelay = {
        args = "(float delay)",
        description = "Set repeat delay.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set repeat rate.",
        returns = "()",
        type = "method"
      },
      GetPressedOffset = {
        args = "()",
        description = "Return pressed image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPressedChildOffset = {
        args = "()",
        description = "Return offset of child elements when pressed.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetRepeatDelay = {
        args = "()",
        description = "Return repeat delay.",
        returns = "(float)",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return repeat rate.",
        returns = "(float)",
        type = "method"
      },
      IsPressed = {
        args = "()",
        description = "Return whether is currently pressed.",
        returns = "(bool)",
        type = "method"
      },
      pressedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed image offset.",
        type = "value"
      },
      pressedChildOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed label offset.",
        type = "value"
      },
      repeatDelay = {
        description = "float\nRepeat delay.",
        type = "value"
      },
      repeatRate = {
        description = "float\nRepeat rate.",
        type = "value"
      },
      pressed = {
        description = "(Readonly) bool\nCurrent pressed state.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  DynamicNavigationMesh = {
    childs = {
      SetDrawObstacles = {
        args = "(bool enable)",
        description = "Draw debug geometry for Obstacles.",
        returns = "()",
        type = "method"
      },
      SetMaxLayers = {
        args = "(unsigned maxLayers)",
        description = "Set the maximum number of layers that navigation construction can create.",
        returns = "()",
        type = "method"
      },
      SetMaxObstacles = {
        args = "(unsigned maxObstacles)",
        description = "Set the maximum number of obstacles allowed.",
        returns = "()",
        type = "method"
      },
      GetDrawObstacles = {
        args = "()",
        description = "Return whether to draw Obstacles.",
        returns = "(bool)",
        type = "method"
      },
      GetMaxLayers = {
        args = "()",
        description = "Return the maximum number of layers permitted to build.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxObstacles = {
        args = "()",
        description = "Return the maximum number of obstacles allowed.",
        returns = "(unsigned)",
        type = "method"
      },
      drawObstacles = {
        description = "bool",
        type = "value"
      },
      maxObstacles = {
        description = "int",
        type = "value"
      },
      maxLayers = {
        description = "unsigned",
        type = "value"
      },
      SetTileSize = {
        args = "(int size)",
        description = "Set tile size.",
        returns = "()",
        type = "method"
      },
      SetCellSize = {
        args = "(float size)",
        description = "Set cell size.",
        returns = "()",
        type = "method"
      },
      SetCellHeight = {
        args = "(float height)",
        description = "Set cell height.",
        returns = "()",
        type = "method"
      },
      SetAgentHeight = {
        args = "(float height)",
        description = "Set navigation agent height.",
        returns = "()",
        type = "method"
      },
      SetAgentRadius = {
        args = "(float radius)",
        description = "Set navigation agent radius.",
        returns = "()",
        type = "method"
      },
      SetAgentMaxClimb = {
        args = "(float maxClimb)",
        description = "Set navigation agent max vertical climb.",
        returns = "()",
        type = "method"
      },
      SetAgentMaxSlope = {
        args = "(float maxSlope)",
        description = "Set navigation agent max slope.",
        returns = "()",
        type = "method"
      },
      SetRegionMinSize = {
        args = "(float size)",
        description = "Set region minimum size.",
        returns = "()",
        type = "method"
      },
      SetRegionMergeSize = {
        args = "(float size)",
        description = "Set region merge size.",
        returns = "()",
        type = "method"
      },
      SetEdgeMaxLength = {
        args = "(float length)",
        description = "Set edge max length.",
        returns = "()",
        type = "method"
      },
      SetEdgeMaxError = {
        args = "(float error)",
        description = "Set edge max error.",
        returns = "()",
        type = "method"
      },
      SetDetailSampleDistance = {
        args = "(float distance)",
        description = "Set detail sampling distance.",
        returns = "()",
        type = "method"
      },
      SetDetailSampleMaxError = {
        args = "(float error)",
        description = "Set detail sampling maximum error.",
        returns = "()",
        type = "method"
      },
      SetPadding = {
        args = "(const Vector3& padding)",
        description = "Set padding of the navigation mesh bounding box. Having enough padding allows to add geometry on the extremities of the navigation mesh when doing partial rebuilds.",
        returns = "()",
        type = "method"
      },
      SetAreaCost = {
        args = "(unsigned areaID, float cost)",
        description = "Set the cost of an area.",
        returns = "()",
        type = "method"
      },
      Build = {
        args = "()",
        description = "(bool) Build (const BoundingBox& boundingBox)\nRebuild the navigation mesh. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetPartitionType = {
        args = "(NavmeshPartitionType aType)",
        description = "Set the partition type used for polygon generation.",
        returns = "()",
        type = "method"
      },
      SetDrawOffMeshConnections = {
        args = "(bool enable)",
        description = "Draw debug geometry for OffMeshConnection components.",
        returns = "()",
        type = "method"
      },
      SetDrawNavAreas = {
        args = "(bool enable)",
        description = "Draw debug geometry for NavArea components.",
        returns = "()",
        type = "method"
      },
      FindNearestPoint = {
        args = "(const Vector3& point)",
        description = "(Vector3) FindNearestPoint (const Vector3& point, const Vector3& extents)",
        returns = "(Vector3)",
        type = "method"
      },
      MoveAlongSurface = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(Vector3) MoveAlongSurface (const Vector3& start, const Vector3& end, const Vector3& extents, int maxVisited = 3)",
        returns = "(Vector3)",
        type = "method"
      },
      FindPath = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(const PODVector<Vector3>&) FindPath (const Vector3& start, const Vector3& end, const Vector3& extents)",
        returns = "(const PODVector<Vector3>&)",
        valuetype = "PODVector<Vector3>",
        type = "method"
      },
      GetRandomPoint = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetRandomPointInCircle = {
        args = "(const Vector3& center, float radius)",
        description = "(Vector3) GetRandomPointInCircle (const Vector3& center, float radius, const Vector3& extents)",
        returns = "(Vector3)",
        type = "method"
      },
      GetDistanceToWall = {
        args = "(const Vector3& point, float radius)",
        description = "(float) GetDistanceToWall (const Vector3& point, float radius, const Vector3& extents)",
        returns = "(float)",
        type = "method"
      },
      Raycast = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(Vector3) Raycast (const Vector3& start, const Vector3& end, const Vector3& extents)",
        returns = "(Vector3)",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      GetTileSize = {
        args = "()",
        description = "Return tile size.",
        returns = "(int)",
        type = "method"
      },
      GetCellSize = {
        args = "()",
        description = "Return cell size.",
        returns = "(float)",
        type = "method"
      },
      GetCellHeight = {
        args = "()",
        description = "Return cell height.",
        returns = "(float)",
        type = "method"
      },
      GetAgentHeight = {
        args = "()",
        description = "Return navigation agent height.",
        returns = "(float)",
        type = "method"
      },
      GetAgentRadius = {
        args = "()",
        description = "Return navigation agent radius.",
        returns = "(float)",
        type = "method"
      },
      GetAgentMaxClimb = {
        args = "()",
        description = "Return navigation agent max vertical climb.",
        returns = "(float)",
        type = "method"
      },
      GetAgentMaxSlope = {
        args = "()",
        description = "Return navigation agent max slope.",
        returns = "(float)",
        type = "method"
      },
      GetRegionMinSize = {
        args = "()",
        description = "Return region minimum size.",
        returns = "(float)",
        type = "method"
      },
      GetRegionMergeSize = {
        args = "()",
        description = "Return region merge size.",
        returns = "(float)",
        type = "method"
      },
      GetEdgeMaxLength = {
        args = "()",
        description = "Return edge max length.",
        returns = "(float)",
        type = "method"
      },
      GetEdgeMaxError = {
        args = "()",
        description = "Return edge max error.",
        returns = "(float)",
        type = "method"
      },
      GetDetailSampleDistance = {
        args = "()",
        description = "Return detail sampling distance.",
        returns = "(float)",
        type = "method"
      },
      GetDetailSampleMaxError = {
        args = "()",
        description = "Return detail sampling maximum error.",
        returns = "(float)",
        type = "method"
      },
      GetPadding = {
        args = "()",
        description = "Return navigation mesh bounding box padding.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetAreaCost = {
        args = "(unsigned areaID)",
        description = "Get the current cost of an area",
        returns = "(float)",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether has been initialized with valid navigation data.",
        returns = "(bool)",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box of the navigation mesh.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world space bounding box of the navigation mesh.",
        returns = "(BoundingBox)",
        type = "method"
      },
      GetNumTiles = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      GetPartitionType = {
        args = "()",
        description = "Return Partition Type.",
        returns = "(NavmeshPartitionType)",
        type = "method"
      },
      GetDrawOffMeshConnections = {
        args = "()",
        description = "Return whether to draw OffMeshConnection components.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawNavAreas = {
        args = "()",
        description = "Return whether to draw NavArea components.",
        returns = "(bool)",
        type = "method"
      },
      tileSize = {
        description = "int\nTile size.",
        type = "value"
      },
      cellSize = {
        description = "float\nCell size.",
        type = "value"
      },
      cellHeight = {
        description = "float\nCell height.",
        type = "value"
      },
      agentHeight = {
        description = "float\nNavigation agent height.",
        type = "value"
      },
      agentRadius = {
        description = "float\nNavigation agent radius.",
        type = "value"
      },
      agentMaxClimb = {
        description = "float\nNavigation agent max vertical climb.",
        type = "value"
      },
      agentMaxSlope = {
        description = "float\nNavigation agent max slope.",
        type = "value"
      },
      regionMinSize = {
        description = "float\nRegion minimum size.",
        type = "value"
      },
      regionMergeSize = {
        description = "float\nRegion merge size.",
        type = "value"
      },
      edgeMaxLength = {
        description = "float\nEdge max length.",
        type = "value"
      },
      edgeMaxError = {
        description = "float\nEdge max error.",
        type = "value"
      },
      detailSampleDistance = {
        description = "float\nDetail sampling distance.",
        type = "value"
      },
      detailSampleMaxError = {
        description = "float\nDetail sampling maximum error.",
        type = "value"
      },
      padding = {
        valuetype = "Vector3",
        description = "Vector3&\nBounding box padding.",
        type = "value"
      },
      partitionType = {
        description = "NavmeshPartitionType\nType of the heightfield partitioning.",
        type = "value"
      },
      drawOffMeshConnections = {
        description = "bool\nDebug draw OffMeshConnection components.",
        type = "value"
      },
      drawNavAreas = {
        description = "bool\nDebug draw NavArea components.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&\nWhole navigation mesh bounding box.",
        type = "value"
      },
      worldBoundingBox = {
        description = "(Readonly) BoundingBox",
        type = "value"
      },
      numTiles = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Engine = {
    childs = {
      RunFrame = {
        args = "()",
        description = "Run one frame.",
        returns = "()",
        type = "method"
      },
      CreateConsole = {
        args = "()",
        description = "Create the console and return it. May return null if engine configuration does not allow creation (headless mode.)",
        returns = "(Console*)",
        valuetype = "Console",
        type = "method"
      },
      CreateDebugHud = {
        args = "()",
        description = "Create the debug hud.",
        returns = "(DebugHud*)",
        valuetype = "DebugHud",
        type = "method"
      },
      SetMinFps = {
        args = "(int fps)",
        description = "Set minimum frames per second. If FPS goes lower than this, time will appear to slow down.",
        returns = "()",
        type = "method"
      },
      SetMaxFps = {
        args = "(int fps)",
        description = "Set maximum frames per second. The engine will sleep if FPS is higher than this.",
        returns = "()",
        type = "method"
      },
      SetMaxInactiveFps = {
        args = "(int fps)",
        description = "Set maximum frames per second when the application does not have input focus.",
        returns = "()",
        type = "method"
      },
      SetTimeStepSmoothing = {
        args = "(int frames)",
        description = "Set how many frames to average for timestep smoothing. Default is 2. 1 disables smoothing.",
        returns = "()",
        type = "method"
      },
      SetPauseMinimized = {
        args = "(bool enable)",
        description = "Set whether to pause update events and audio when minimized.",
        returns = "()",
        type = "method"
      },
      SetAutoExit = {
        args = "(bool enable)",
        description = "Set whether to exit automatically on exit request (window close button.)",
        returns = "()",
        type = "method"
      },
      Exit = {
        args = "()",
        description = "Close the graphics window and set the exit flag. No-op on iOS, as an iOS application can not legally exit.",
        returns = "()",
        type = "method"
      },
      DumpProfiler = {
        args = "()",
        description = "Dump profiling information to the log.",
        returns = "()",
        type = "method"
      },
      DumpResources = {
        args = "(bool dumpFileName = false)",
        description = "Dump information of all resources to the log.",
        returns = "()",
        type = "method"
      },
      DumpMemory = {
        args = "()",
        description = "Dump information of all memory allocations to the log. Supported in MSVC debug mode only.",
        returns = "()",
        type = "method"
      },
      GetMinFps = {
        args = "()",
        description = "Return the minimum frames per second.",
        returns = "(int)",
        type = "method"
      },
      GetMaxFps = {
        args = "()",
        description = "Return the maximum frames per second.",
        returns = "(int)",
        type = "method"
      },
      GetMaxInactiveFps = {
        args = "()",
        description = "Return the maximum frames per second when the application does not have input focus.",
        returns = "(int)",
        type = "method"
      },
      GetTimeStepSmoothing = {
        args = "()",
        description = "Return how many frames to average for timestep smoothing.",
        returns = "(int)",
        type = "method"
      },
      GetPauseMinimized = {
        args = "()",
        description = "Return whether to pause update events and audio when minimized.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoExit = {
        args = "()",
        description = "Return whether to exit automatically on exit request.",
        returns = "(bool)",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether engine has been initialized.",
        returns = "(bool)",
        type = "method"
      },
      IsExiting = {
        args = "()",
        description = "Return whether exit has been requested.",
        returns = "(bool)",
        type = "method"
      },
      IsHeadless = {
        args = "()",
        description = "Return whether the engine has been created in headless mode.",
        returns = "(bool)",
        type = "method"
      },
      minFps = {
        description = "int\nMinimum frames per second.",
        type = "value"
      },
      maxFps = {
        description = "int\nMaximum frames per second.",
        type = "value"
      },
      maxInactiveFps = {
        description = "int\nMaximum frames per second when the application does not have input focus.",
        type = "value"
      },
      timeStepSmoothing = {
        description = "int\nHow many frames to average for the smoothed timestep.",
        type = "value"
      },
      pauseMinimized = {
        description = "bool\nPause when minimized flag.",
        type = "value"
      },
      autoExit = {
        description = "bool\nAuto-exit flag.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool\nInitialized flag.",
        type = "value"
      },
      exiting = {
        description = "(Readonly) bool\nExiting flag.",
        type = "value"
      },
      headless = {
        description = "(Readonly) bool\nHeadless mode flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  File = {
    childs = {
      new = {
        args = "()",
        description = "(File*) new (const String fileName, FileMode mode = FILE_READ),\n(File*) new (PackageFile* package, const String fileName)",
        returns = "(File*)",
        valuetype = "File",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Open = {
        args = "(const String fileName, FileMode mode = FILE_READ)",
        description = "(bool) Open (PackageFile* package, const String fileName)\nOpen a filesystem file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Close = {
        args = "()",
        description = "Close the file.",
        returns = "()",
        type = "method"
      },
      Flush = {
        args = "()",
        description = "Flush any buffered output to the file.",
        returns = "()",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Change the file name. Used by the resource system.",
        returns = "()",
        type = "method"
      },
      GetMode = {
        args = "()",
        description = "Return the open mode.",
        returns = "(FileMode)",
        type = "method"
      },
      IsOpen = {
        args = "()",
        description = "Return whether is open.",
        returns = "(bool)",
        type = "method"
      },
      GetHandle = {
        args = "()",
        description = "Return the file handle.",
        returns = "(void*)",
        type = "method"
      },
      IsPackaged = {
        args = "()",
        description = "Return whether the file originates from a package.",
        returns = "(bool)",
        type = "method"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the file.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return the file name.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return a checksum of the file contents using the SDBM hash algorithm.",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      ReadInt64 = {
        args = "()",
        returns = "(long)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUInt64 = {
        args = "()",
        returns = "(long)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      ReadDouble = {
        args = "()",
        returns = "(double)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadIntVector3 = {
        args = "()",
        returns = "(IntVector3)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ReadMatrix3x4 = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      ReadMatrix4 = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        returns = "(bool)",
        type = "method"
      },
      WriteInt64 = {
        args = "(long value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt64 = {
        args = "(long value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        returns = "(bool)",
        type = "method"
      },
      WriteDouble = {
        args = "(double value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector3 = {
        args = "(const IntVector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3 = {
        args = "(const Matrix3& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3x4 = {
        args = "(const Matrix3x4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix4 = {
        args = "(const Matrix4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      mode = {
        description = "(Readonly) FileMode\nOpen mode.",
        type = "value"
      },
      open = {
        description = "(Readonly) bool",
        type = "value"
      },
      packaged = {
        description = "(Readonly) bool",
        type = "value"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned\nContent checksum.",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FileSelector = {
    childs = {
      new = {
        args = "()",
        returns = "(FileSelector*)",
        valuetype = "FileSelector",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set fileselector UI style.",
        returns = "()",
        type = "method"
      },
      SetTitle = {
        args = "(const String text)",
        description = "Set title text.",
        returns = "()",
        type = "method"
      },
      SetButtonTexts = {
        args = "(const String okText, const String cancelText)",
        description = "Set button texts.",
        returns = "()",
        type = "method"
      },
      SetPath = {
        args = "(const String path)",
        description = "Set current path.",
        returns = "()",
        type = "method"
      },
      SetFileName = {
        args = "(const String fileName)",
        description = "Set current filename.",
        returns = "()",
        type = "method"
      },
      SetFilters = {
        args = "(const Vector<String>& filters, unsigned defaultIndex)",
        returns = "()",
        type = "method"
      },
      SetDirectoryMode = {
        args = "(bool enable)",
        description = "Set directory selection mode. Default false.",
        returns = "()",
        type = "method"
      },
      UpdateElements = {
        args = "()",
        description = "Update elements to layout properly. Call this after manually adjusting the sub-elements.",
        returns = "()",
        type = "method"
      },
      GetDefaultStyle = {
        args = "()",
        description = "Return the UI style file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetWindow = {
        args = "()",
        description = "Return fileselector window.",
        returns = "(Window*)",
        valuetype = "Window",
        type = "method"
      },
      GetTitleText = {
        args = "()",
        description = "Return window title text element.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetFileList = {
        args = "()",
        description = "Return file list.",
        returns = "(ListView*)",
        valuetype = "ListView",
        type = "method"
      },
      GetPathEdit = {
        args = "()",
        description = "Return path editor.",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      GetFileNameEdit = {
        args = "()",
        description = "Return filename editor.",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      GetFilterList = {
        args = "()",
        description = "Return filter dropdown.",
        returns = "(DropDownList*)",
        valuetype = "DropDownList",
        type = "method"
      },
      GetOKButton = {
        args = "()",
        description = "Return OK button.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetCancelButton = {
        args = "()",
        description = "Return cancel button.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetCloseButton = {
        args = "()",
        description = "Return close button.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetTitle = {
        args = "()",
        description = "Return window title.",
        returns = "(const String)",
        type = "method"
      },
      GetPath = {
        args = "()",
        description = "Return current path.",
        returns = "(const String)",
        type = "method"
      },
      GetFileName = {
        args = "()",
        description = "Return current filename.",
        returns = "(const String)",
        type = "method"
      },
      GetFilter = {
        args = "()",
        description = "Return current filter.",
        returns = "(const String)",
        type = "method"
      },
      GetFilterIndex = {
        args = "()",
        description = "Return current filter index.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDirectoryMode = {
        args = "()",
        description = "Return directory mode flag.",
        returns = "(bool)",
        type = "method"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*",
        type = "value"
      },
      window = {
        valuetype = "Window",
        description = "(Readonly) Window*\nFileselector window.",
        type = "value"
      },
      titleText = {
        valuetype = "Text",
        description = "(Readonly) Text*\nWindow title text.",
        type = "value"
      },
      fileList = {
        valuetype = "ListView",
        description = "(Readonly) ListView*\nFile list.",
        type = "value"
      },
      pathEdit = {
        valuetype = "LineEdit",
        description = "(Readonly) LineEdit*\nPath editor.",
        type = "value"
      },
      fileNameEdit = {
        valuetype = "LineEdit",
        description = "(Readonly) LineEdit*\nFilename editor.",
        type = "value"
      },
      filterList = {
        valuetype = "DropDownList",
        description = "(Readonly) DropDownList*\nFilter dropdown.",
        type = "value"
      },
      OKButton = {
        valuetype = "Button",
        description = "(Readonly) Button*",
        type = "value"
      },
      cancelButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nCancel button.",
        type = "value"
      },
      closeButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nClose button.",
        type = "value"
      },
      title = {
        description = "String",
        type = "value"
      },
      path = {
        description = "String\nCurrent directory.",
        type = "value"
      },
      fileName = {
        description = "String",
        type = "value"
      },
      filter = {
        description = "(Readonly) String",
        type = "value"
      },
      filterIndex = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      directoryMode = {
        description = "bool\nDirectory mode flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FileSelectorEntry = {
    childs = {
      name = {
        description = "String",
        type = "value"
      },
      directory = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  FileSystem = {
    childs = {
      SetCurrentDir = {
        args = "(const String pathName)",
        description = "Set the current working directory.",
        returns = "(bool)",
        type = "method"
      },
      CreateDir = {
        args = "(const String pathName)",
        description = "Create a directory.",
        returns = "(bool)",
        type = "method"
      },
      SetExecuteConsoleCommands = {
        args = "(bool enable)",
        description = "Set whether to execute engine console commands as OS-specific system command.",
        returns = "()",
        type = "method"
      },
      SystemCommand = {
        args = "(const String commandLine, bool redirectStdOutToLog = false)",
        description = "Run a program using the command interpreter, block until it exits and return the exit code. Will fail if any allowed paths are defined.",
        returns = "(int)",
        type = "method"
      },
      SystemRun = {
        args = "(const String fileName, const Vector<String>& arguments)",
        returns = "(int)",
        type = "method"
      },
      SystemCommandAsync = {
        args = "(const String commandLine)",
        description = "Run a program using the command interpreter asynchronously. Return a request ID or M_MAX_UNSIGNED if failed. The exit code will be posted together with the request ID in an AsyncExecFinished event. Will fail if any allowed paths are defined.",
        returns = "(unsigned)",
        type = "method"
      },
      SystemRunAsync = {
        args = "(const String fileName, const Vector<String>& arguments)",
        returns = "(unsigned)",
        type = "method"
      },
      SystemOpen = {
        args = "(const String fileName, const String mode = String::EMPTY)",
        description = "Open a file in an external program, with mode such as \"edit\" optionally specified. Will fail if any allowed paths are defined.",
        returns = "(bool)",
        type = "method"
      },
      Copy = {
        args = "(const String srcFileName, const String destFileName)",
        description = "Copy a file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Rename = {
        args = "(const String srcFileName, const String destFileName)",
        description = "Rename a file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Delete = {
        args = "(const String fileName)",
        description = "Delete a file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetLastModifiedTime = {
        args = "(const String fileName, unsigned newTime)",
        description = "Set a file's last modified time as seconds since 1.1.1970. Return true on success.",
        returns = "(bool)",
        type = "method"
      },
      GetCurrentDir = {
        args = "()",
        description = "Return the absolute current working directory.",
        returns = "(String)",
        type = "method"
      },
      GetExecuteConsoleCommands = {
        args = "()",
        description = "Return whether is executing engine console commands as OS-specific system command.",
        returns = "(bool)",
        type = "method"
      },
      HasRegisteredPaths = {
        args = "()",
        description = "Return whether paths have been registered.",
        returns = "(bool)",
        type = "method"
      },
      CheckAccess = {
        args = "(const String pathName)",
        description = "Check if a path is allowed to be accessed. If no paths are registered, all are allowed.",
        returns = "(bool)",
        type = "method"
      },
      GetLastModifiedTime = {
        args = "(const String fileName)",
        description = "Returns the file's last modified time as seconds since 1.1.1970, or 0 if can not be accessed.",
        returns = "(unsigned)",
        type = "method"
      },
      FileExists = {
        args = "(const String fileName)",
        description = "Check if a file exists.",
        returns = "(bool)",
        type = "method"
      },
      DirExists = {
        args = "(const String pathName)",
        description = "Check if a directory exists.",
        returns = "(bool)",
        type = "method"
      },
      ScanDir = {
        args = "(const String pathName, const String filter, unsigned flags, bool recursive)",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "method"
      },
      GetProgramDir = {
        args = "()",
        description = "Return the program's directory.",
        returns = "(String)",
        type = "method"
      },
      GetUserDocumentsDir = {
        args = "()",
        description = "Return the user documents directory.",
        returns = "(String)",
        type = "method"
      },
      GetAppPreferencesDir = {
        args = "(const String org, const String app)",
        description = "Return the application preferences directory.",
        returns = "(String)",
        type = "method"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  FocusParameters = {
    childs = {
      new = {
        args = "()",
        description = "(FocusParameters*) new (bool focus, bool nonUniform, bool autoSize, float quantize, float minView)",
        returns = "(FocusParameters*)",
        valuetype = "FocusParameters",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      nonUniform = {
        description = "bool",
        type = "value"
      },
      autoSize = {
        description = "bool",
        type = "value"
      },
      quantize = {
        description = "float",
        type = "value"
      },
      minView = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Font = {
    childs = {
      SetAbsoluteGlyphOffset = {
        args = "(const IntVector2& offset)",
        description = "Set absolute (in pixels) position adjustment for glyphs.",
        returns = "()",
        type = "method"
      },
      SetScaledGlyphOffset = {
        args = "(const Vector2& offset)",
        description = "Set point size scaled position adjustment for glyphs.",
        returns = "()",
        type = "method"
      },
      GetAbsoluteGlyphOffset = {
        args = "()",
        description = "Return absolute position adjustment for glyphs.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetScaledGlyphOffset = {
        args = "()",
        description = "Return point size scaled position adjustment for glyphs.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetTotalGlyphOffset = {
        args = "(int pointSize)",
        description = "Return the total effective offset for a point size.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetFontType = {
        args = "()",
        description = "Return font type.",
        returns = "(FontType)",
        type = "method"
      },
      IsSDFFont = {
        args = "()",
        description = "Is signed distance field font.",
        returns = "(bool)",
        type = "method"
      },
      absoluteGlyphOffset = {
        description = "IntVector2",
        type = "value"
      },
      scaledGlyphOffset = {
        description = "Vector2",
        type = "value"
      },
      fontType = {
        description = "(Readonly) FontType\nFont type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Frustum = {
    childs = {
      new = {
        args = "()",
        description = "(Frustum*) new (const Frustum& frustum)",
        returns = "(Frustum*)",
        valuetype = "Frustum",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(float fov, float aspectRatio, float zoom, float nearZ, float farZ)",
        description = "() Define (float fov, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform),\n() Define (const Vector3& near, const Vector3& far),\n() Define (const Vector3& near, const Vector3& far, const Matrix3x4& transform),\n() Define (const BoundingBox& box),\n() Define (const BoundingBox& box, const Matrix3x4& transform),\n() Define (const Matrix4& projection)",
        returns = "()",
        type = "method"
      },
      DefineOrtho = {
        args = "(float orthoSize, float aspectRatio, float zoom, float nearZ, float farZ)",
        description = "() DefineOrtho (float orthoSize, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform)",
        returns = "()",
        type = "method"
      },
      DefineSplit = {
        args = "(const Matrix4& projection, float near, float far)",
        description = "Define a split (limited) frustum from a projection matrix, with near & far distances specified.",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform)\nTransform by a 3x3 matrix.",
        returns = "()",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "(Intersection) IsInside (const Sphere& sphere),\n(Intersection) IsInside (const BoundingBox& box)\nTest if a point is inside or outside.",
        returns = "(Intersection)",
        type = "method"
      },
      IsInsideFast = {
        args = "(const Sphere& sphere)",
        description = "(Intersection) IsInsideFast (const BoundingBox& box)",
        returns = "(Intersection)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(Frustum) Transformed (const Matrix3x4& transform)",
        returns = "(Frustum)",
        type = "method"
      },
      Projected = {
        args = "(const Matrix4& transform)",
        returns = "(Rect)",
        type = "method"
      },
      UpdatePlanes = {
        args = "()",
        returns = "()",
        type = "method"
      },
    },
    type = "class"
  },
  Geometry = {
    childs = {
      new = {
        args = "()",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetNumVertexBuffers = {
        args = "(unsigned num)",
        description = "Set number of vertex buffers.",
        returns = "(bool)",
        type = "method"
      },
      SetVertexBuffer = {
        args = "(unsigned index, VertexBuffer* buffer)",
        description = "Set a vertex buffer by index.",
        returns = "(bool)",
        type = "method"
      },
      SetIndexBuffer = {
        args = "(IndexBuffer* buffer)",
        description = "Set the index buffer.",
        returns = "()",
        type = "method"
      },
      SetDrawRange = {
        args = "(PrimitiveType type, unsigned indexStart, unsigned indexCount, bool getUsedVertexRange = true)",
        description = "(bool) SetDrawRange (PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned vertexStart, unsigned vertexCount, bool checkIllegal = true)\nSet the draw range.",
        returns = "(bool)",
        type = "method"
      },
      SetLodDistance = {
        args = "(float distance)",
        description = "Set the LOD distance.",
        returns = "()",
        type = "method"
      },
      GetNumVertexBuffers = {
        args = "()",
        description = "Return number of vertex buffers.",
        returns = "(unsigned)",
        type = "method"
      },
      GetVertexBuffer = {
        args = "(unsigned index)",
        description = "Return vertex buffer by index.",
        returns = "(VertexBuffer*)",
        valuetype = "VertexBuffer",
        type = "method"
      },
      GetIndexBuffer = {
        args = "()",
        description = "Return the index buffer.",
        returns = "(IndexBuffer*)",
        valuetype = "IndexBuffer",
        type = "method"
      },
      GetPrimitiveType = {
        args = "()",
        description = "Return primitive type.",
        returns = "(PrimitiveType)",
        type = "method"
      },
      GetIndexStart = {
        args = "()",
        description = "Return start index.",
        returns = "(unsigned)",
        type = "method"
      },
      GetIndexCount = {
        args = "()",
        description = "Return number of indices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetVertexStart = {
        args = "()",
        description = "Return first used vertex.",
        returns = "(unsigned)",
        type = "method"
      },
      GetVertexCount = {
        args = "()",
        description = "Return number of used vertices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLodDistance = {
        args = "()",
        description = "Return LOD distance.",
        returns = "(float)",
        type = "method"
      },
      IsEmpty = {
        args = "()",
        description = "Return whether has empty draw range.",
        returns = "(bool)",
        type = "method"
      },
      numVertexBuffers = {
        description = "unsigned",
        type = "value"
      },
      indexBuffer = {
        valuetype = "IndexBuffer",
        description = "IndexBuffer*\nIndex buffer.",
        type = "value"
      },
      primitiveType = {
        description = "(Readonly) PrimitiveType\nPrimitive type.",
        type = "value"
      },
      indexStart = {
        description = "(Readonly) unsigned\nStart index.",
        type = "value"
      },
      indexCount = {
        description = "(Readonly) unsigned\nNumber of indices.",
        type = "value"
      },
      vertexStart = {
        description = "(Readonly) unsigned\nFirst used vertex.",
        type = "value"
      },
      vertexCount = {
        description = "(Readonly) unsigned\nNumber of used vertices.",
        type = "value"
      },
      lodDistance = {
        description = "float\nLOD distance.",
        type = "value"
      },
      empty = {
        description = "(Readonly) bool",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Graphics = {
    childs = {
      SetWindowTitle = {
        args = "(const String windowTitle)",
        description = "Set window title.",
        returns = "()",
        type = "method"
      },
      SetWindowIcon = {
        args = "(Image* windowIcon)",
        description = "Set window icon.",
        returns = "()",
        type = "method"
      },
      SetWindowPosition = {
        args = "(const IntVector2& position)",
        description = "() SetWindowPosition (int x, int y)\nSet window position. Sets initial position if window is not created yet.",
        returns = "()",
        type = "method"
      },
      SetMode = {
        args = "(int width, int height, bool fullscreen, bool borderless, bool resizable, bool highDPI, bool vsync, bool tripleBuffer, int multiSample, int monitor, int refreshRate)",
        description = "(bool) SetMode (int width, int height)\nSet screen resolution only. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        description = "Set whether the main window uses sRGB conversion on write.",
        returns = "()",
        type = "method"
      },
      SetDither = {
        args = "(bool enable)",
        description = "Set whether rendering output is dithered. Default true on OpenGL. No effect on Direct3D.",
        returns = "()",
        type = "method"
      },
      SetFlushGPU = {
        args = "(bool enable)",
        description = "Set whether to flush the GPU command buffer to prevent multiple frames being queued and uneven frame timesteps. Default off, may decrease performance if enabled. Not currently implemented on OpenGL.",
        returns = "()",
        type = "method"
      },
      SetOrientations = {
        args = "(const String orientations)",
        description = "Set allowed screen orientations as a space-separated list of \"LandscapeLeft\", \"LandscapeRight\", \"Portrait\" and \"PortraitUpsideDown\". Affects currently only iOS platform.",
        returns = "()",
        type = "method"
      },
      ToggleFullscreen = {
        args = "()",
        description = "Toggle between full screen and windowed mode. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Maximize = {
        args = "()",
        description = "Maximize the window.",
        returns = "()",
        type = "method"
      },
      Minimize = {
        args = "()",
        description = "Minimize the window.",
        returns = "()",
        type = "method"
      },
      Close = {
        args = "()",
        description = "Close the window.",
        returns = "()",
        type = "method"
      },
      TakeScreenShot = {
        args = "(Image& destImage)",
        description = "Take a screenshot. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      BeginDumpShaders = {
        args = "(const String fileName)",
        description = "Begin dumping shader variation names to an XML file for precaching.",
        returns = "()",
        type = "method"
      },
      EndDumpShaders = {
        args = "()",
        description = "End dumping shader variations names.",
        returns = "()",
        type = "method"
      },
      PrecacheShaders = {
        args = "(Deserializer& source)",
        description = "() PrecacheShaders (const String fileName)\nPrecache shader variations from an XML file generated with BeginDumpShaders().",
        returns = "()",
        type = "method"
      },
      SetShaderCacheDir = {
        args = "(const String path)",
        description = "Set shader cache directory, Direct3D only. This can either be an absolute path or a path within the resource system.",
        returns = "()",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether rendering initialized.",
        returns = "(bool)",
        type = "method"
      },
      GetExternalWindow = {
        args = "()",
        description = "Return OS-specific external window handle. Null if not in use.",
        returns = "(void*)",
        type = "method"
      },
      GetWindowTitle = {
        args = "()",
        description = "Return window title.",
        returns = "(const String)",
        type = "method"
      },
      GetApiName = {
        args = "()",
        description = "Return graphics API name.",
        returns = "(const String)",
        type = "method"
      },
      GetWindowPosition = {
        args = "()",
        description = "Return window position.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return window width in pixels.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return window height in pixels.",
        returns = "(int)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        description = "Return multisample mode (1 = no multisampling.)",
        returns = "(int)",
        type = "method"
      },
      GetSize = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      GetFullscreen = {
        args = "()",
        description = "Return whether window is fullscreen.",
        returns = "(bool)",
        type = "method"
      },
      GetResizable = {
        args = "()",
        description = "Return whether window is resizable.",
        returns = "(bool)",
        type = "method"
      },
      GetBorderless = {
        args = "()",
        description = "Return whether window is borderless.",
        returns = "(bool)",
        type = "method"
      },
      GetVSync = {
        args = "()",
        description = "Return whether vertical sync is on.",
        returns = "(bool)",
        type = "method"
      },
      GetMonitor = {
        args = "()",
        description = "Return the current monitor index. Effective on in fullscreen",
        returns = "(int)",
        type = "method"
      },
      GetRefreshRate = {
        args = "()",
        description = "Return refresh rate when using vsync in fullscreen",
        returns = "(int)",
        type = "method"
      },
      GetTripleBuffer = {
        args = "()",
        description = "Return whether triple buffering is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        description = "Return whether the main window is using sRGB conversion on write.",
        returns = "(bool)",
        type = "method"
      },
      GetDither = {
        args = "()",
        description = "Return whether rendering output is dithered.",
        returns = "(bool)",
        type = "method"
      },
      GetFlushGPU = {
        args = "()",
        description = "Return whether the GPU command buffer is flushed each frame.",
        returns = "(bool)",
        type = "method"
      },
      GetOrientations = {
        args = "()",
        description = "Return allowed screen orientations.",
        returns = "(const String)",
        type = "method"
      },
      IsDeviceLost = {
        args = "()",
        description = "Return whether graphics context is lost and can not render or load GPU resources.",
        returns = "(bool)",
        type = "method"
      },
      GetNumPrimitives = {
        args = "()",
        description = "Return number of primitives drawn this frame.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumBatches = {
        args = "()",
        description = "Return number of batches drawn this frame.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDummyColorFormat = {
        args = "()",
        description = "Return dummy color texture format for shadow maps. Is \"NULL\" (consume no video memory) if supported.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMapFormat = {
        args = "()",
        description = "Return shadow map depth texture format, or 0 if not supported.",
        returns = "(unsigned)",
        type = "method"
      },
      GetHiresShadowMapFormat = {
        args = "()",
        description = "Return 24-bit shadow map depth texture format, or 0 if not supported.",
        returns = "(unsigned)",
        type = "method"
      },
      GetInstancingSupport = {
        args = "()",
        description = "Return whether hardware instancing is supported.",
        returns = "(bool)",
        type = "method"
      },
      GetLightPrepassSupport = {
        args = "()",
        description = "Return whether light pre-pass rendering is supported.",
        returns = "(bool)",
        type = "method"
      },
      GetDeferredSupport = {
        args = "()",
        description = "Return whether deferred rendering is supported.",
        returns = "(bool)",
        type = "method"
      },
      GetHardwareShadowSupport = {
        args = "()",
        description = "Return whether shadow map depth compare is done in hardware.",
        returns = "(bool)",
        type = "method"
      },
      GetReadableDepthSupport = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetSRGBSupport = {
        args = "()",
        description = "Return whether sRGB conversion on texture sampling is supported.",
        returns = "(bool)",
        type = "method"
      },
      GetSRGBWriteSupport = {
        args = "()",
        description = "Return whether sRGB conversion on rendertarget writing is supported.",
        returns = "(bool)",
        type = "method"
      },
      GetDesktopResolution = {
        args = "(int monitor)",
        description = "Return the desktop resolution.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetMonitorCount = {
        args = "()",
        description = "Return the number of currently connected monitors.",
        returns = "(int)",
        type = "method"
      },
      GetShaderCacheDir = {
        args = "()",
        description = "Return shader cache directory, Direct3D only.",
        returns = "(const String)",
        type = "method"
      },
      GetAlphaFormat = {
        args = "()",
        description = "Return the API-specific alpha texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLuminanceFormat = {
        args = "()",
        description = "Return the API-specific luminance texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLuminanceAlphaFormat = {
        args = "()",
        description = "Return the API-specific luminance alpha texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGBFormat = {
        args = "()",
        description = "Return the API-specific RGB texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGBAFormat = {
        args = "()",
        description = "Return the API-specific RGBA texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGBA16Format = {
        args = "()",
        description = "Return the API-specific RGBA 16-bit texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGBAFloat16Format = {
        args = "()",
        description = "Return the API-specific RGBA 16-bit float texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGBAFloat32Format = {
        args = "()",
        description = "Return the API-specific RGBA 32-bit float texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRG16Format = {
        args = "()",
        description = "Return the API-specific RG 16-bit texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGFloat16Format = {
        args = "()",
        description = "Return the API-specific RG 16-bit float texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRGFloat32Format = {
        args = "()",
        description = "Return the API-specific RG 32-bit float texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFloat16Format = {
        args = "()",
        description = "Return the API-specific single channel 16-bit float texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFloat32Format = {
        args = "()",
        description = "Return the API-specific single channel 32-bit float texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLinearDepthFormat = {
        args = "()",
        description = "Return the API-specific linear depth texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDepthStencilFormat = {
        args = "()",
        description = "Return the API-specific hardware depth-stencil texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetReadableDepthFormat = {
        args = "()",
        description = "Return whether a readable hardware depth format is available.\nReturn the API-specific readable hardware depth format, or 0 if not supported.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFormat = {
        args = "(const String formatName)",
        description = "Return the API-specific texture format from a textual description, for example \"rgb\".",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxBones = {
        args = "()",
        description = "Return maximum number of supported bones for skinning.",
        returns = "(unsigned)",
        type = "method"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      windowTitle = {
        description = "String\nWindow title.",
        type = "value"
      },
      apiName = {
        description = "(Readonly) String\nGraphics API name.",
        type = "value"
      },
      windowPosition = {
        description = "IntVector2",
        type = "value"
      },
      width = {
        description = "(Readonly) int\nWindow width in pixels.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nWindow height in pixels.",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int\nMultisampling mode.",
        type = "value"
      },
      size = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      fullscreen = {
        description = "(Readonly) bool\nFullscreen flag.",
        type = "value"
      },
      resizable = {
        description = "(Readonly) bool\nResizable flag.",
        type = "value"
      },
      borderless = {
        description = "(Readonly) bool\nBorderless flag.",
        type = "value"
      },
      vSync = {
        description = "(Readonly) bool",
        type = "value"
      },
      refreshRate = {
        description = "(Readonly) int\nRefresh rate in Hz. Only used in fullscreen, 0 when windowed",
        type = "value"
      },
      monitor = {
        description = "(Readonly) int\nMonitor index. Only used in fullscreen, 0 when windowed",
        type = "value"
      },
      tripleBuffer = {
        description = "(Readonly) bool\nTriple buffering flag.",
        type = "value"
      },
      sRGB = {
        description = "bool\nsRGB conversion on write flag for the main window.",
        type = "value"
      },
      dither = {
        description = "bool",
        type = "value"
      },
      flushGPU = {
        description = "bool\nFlush GPU command buffer flag.",
        type = "value"
      },
      orientations = {
        description = "String\nAllowed screen orientations.",
        type = "value"
      },
      deviceLost = {
        description = "(Readonly) bool",
        type = "value"
      },
      numPrimitives = {
        description = "(Readonly) unsigned\nNumber of primitives this frame.",
        type = "value"
      },
      numBatches = {
        description = "(Readonly) unsigned\nNumber of batches this frame.",
        type = "value"
      },
      dummyColorFormat = {
        description = "(Readonly) unsigned\nShadow map dummy color texture format.",
        type = "value"
      },
      shadowMapFormat = {
        description = "(Readonly) unsigned\nShadow map depth texture format.",
        type = "value"
      },
      hiresShadowMapFormat = {
        description = "(Readonly) unsigned\nShadow map 24-bit depth texture format.",
        type = "value"
      },
      instancingSupport = {
        description = "(Readonly) bool\nInstancing support flag.",
        type = "value"
      },
      lightPrepassSupport = {
        description = "(Readonly) bool\nLight pre-pass rendering support flag.",
        type = "value"
      },
      deferredSupport = {
        description = "(Readonly) bool\nDeferred rendering support flag.",
        type = "value"
      },
      hardwareShadowSupport = {
        description = "(Readonly) bool\nHardware shadow map depth compare support flag.",
        type = "value"
      },
      readableDepthSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      sRGBSupport = {
        description = "(Readonly) bool\nsRGB conversion on read support flag.",
        type = "value"
      },
      sRGBWriteSupport = {
        description = "(Readonly) bool\nsRGB conversion on write support flag.",
        type = "value"
      },
      monitorCount = {
        description = "(Readonly) int",
        type = "value"
      },
      shaderCacheDir = {
        description = "String\nCache directory for Direct3D binary shaders.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  HierarchyContainer = {
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    type = "class"
  },
  HttpRequest = {
    childs = {
      GetURL = {
        args = "()",
        description = "Return URL used in the request.",
        returns = "(const String)",
        type = "method"
      },
      GetVerb = {
        args = "()",
        description = "Return verb used in the request. Default GET if empty verb specified on construction.",
        returns = "(const String)",
        type = "method"
      },
      GetError = {
        args = "()",
        description = "Return error. Only non-empty in the error state.",
        returns = "(String)",
        type = "method"
      },
      GetState = {
        args = "()",
        description = "Return connection state.\nReturn whether connection is in the open state.",
        returns = "(HttpRequestState)",
        type = "method"
      },
      GetAvailableSize = {
        args = "()",
        description = "Return amount of bytes in the read buffer.",
        returns = "(unsigned)",
        type = "method"
      },
      IsOpen = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      IsEof = {
        args = "()",
        description = "Return whether all response data has been read.",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      ReadDouble = {
        args = "()",
        returns = "(double)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadIntVector3 = {
        args = "()",
        returns = "(IntVector3)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ReadMatrix3x4 = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      ReadMatrix4 = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      URL = {
        description = "(Readonly) String",
        type = "value"
      },
      verb = {
        description = "(Readonly) String\nVerb.",
        type = "value"
      },
      error = {
        description = "(Readonly) String\nError string. Empty if no error.",
        type = "value"
      },
      state = {
        description = "(Readonly) HttpRequestState\nConnection state.",
        type = "value"
      },
      availableSize = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      open = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  IKConstraint = {
    childs = {
      GetStiffness = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      SetStiffness = {
        args = "(float stiffness)",
        returns = "()",
        type = "method"
      },
      GetStretchiness = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      SetStretchiness = {
        args = "(float stretchiness)",
        returns = "()",
        type = "method"
      },
      GetLengthConstraints = {
        args = "()",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      SetLengthConstraints = {
        args = "(const Vector2& lengthConstraints)",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  IKEffector = {
    childs = {
      GetTargetNode = {
        args = "()",
        description = "Retrieves the node that is being used as a target. Can be NULL.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      SetTargetNode = {
        args = "(Node* targetNode)",
        returns = "()",
        type = "method"
      },
      GetTargetName = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SetTargetName = {
        args = "(const String nodeName)",
        returns = "()",
        type = "method"
      },
      GetTargetPosition = {
        args = "()",
        description = "Returns the current target position in world space.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      SetTargetPosition = {
        args = "(const Vector3& targetPosition)",
        description = "Sets the current target position. If the effector has a target node then this will have no effect.",
        returns = "()",
        type = "method"
      },
      GetTargetRotation = {
        args = "()",
        description = "Gets the current target rotation in world space.",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      SetTargetRotation = {
        args = "(const Quaternion& targetRotation)",
        description = "Sets the current target rotation. If the effector has a target node then this will have no effect.",
        returns = "()",
        type = "method"
      },
      GetChainLength = {
        args = "()",
        description = "Returns the number of segments that will be affected by this effector. 0 Means all nodes between this effector and the next IKSolver.",
        returns = "(unsigned)",
        type = "method"
      },
      SetChainLength = {
        args = "(unsigned chainLength)",
        description = "Sets the number of segments that will be affected. 0 Means all nodes between this effector and the next IKSolver.",
        returns = "()",
        type = "method"
      },
      GetWeight = {
        args = "()",
        description = "How strongly the effector affects the solution.",
        returns = "(float)",
        type = "method"
      },
      SetWeight = {
        args = "(float weight)",
        returns = "()",
        type = "method"
      },
      GetRotationWeight = {
        args = "()",
        description = "How strongly the target node's rotation influences the solution",
        returns = "(float)",
        type = "method"
      },
      SetRotationWeight = {
        args = "(float weight)",
        returns = "()",
        type = "method"
      },
      GetRotationDecay = {
        args = "()",
        description = "Retrieves the rotation decay factor. See SetRotationDecay() for info.",
        returns = "(float)",
        type = "method"
      },
      SetRotationDecay = {
        args = "(float decay)",
        returns = "()",
        type = "method"
      },
      WeightedNlerpEnabled = {
        args = "()",
        description = "Whether or not to nlerp instead of lerp when transitioning with the weight parameter",
        returns = "(bool)",
        type = "method"
      },
      EnableWeightedNlerp = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      InheritParentRotationEnabled = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      EnableInheritParentRotation = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      targetNode = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      targetName = {
        description = "String",
        type = "value"
      },
      targetPosition = {
        description = "Vector3",
        type = "value"
      },
      targetRotation = {
        description = "Quaternion",
        type = "value"
      },
      chainLength = {
        description = "unsigned",
        type = "value"
      },
      weight = {
        description = "float",
        type = "value"
      },
      rotationWeight = {
        description = "float",
        type = "value"
      },
      rotationDecay = {
        description = "float",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  IKSolver = {
    childs = {
      GetAlgorithm = {
        args = "()",
        description = "Returns the active algorithm",
        returns = "(IKSolver::Algorithm)",
        type = "method"
      },
      SetAlgorithm = {
        args = "(IKSolver::Algorithm algorithm)",
        returns = "()",
        type = "method"
      },
      GetMaximumIterations = {
        args = "()",
        description = "Returns the configured maximum number of iterations.",
        returns = "(unsigned)",
        type = "method"
      },
      SetMaximumIterations = {
        args = "(unsigned iterations)",
        returns = "()",
        type = "method"
      },
      GetTolerance = {
        args = "()",
        description = "Returns the configured tolerance.",
        returns = "(float)",
        type = "method"
      },
      SetTolerance = {
        args = "(float tolerance)",
        returns = "()",
        type = "method"
      },
      BoneRotationsEnabled = {
        args = "()",
        description = "Whether or not rotations should be calculated.",
        returns = "(bool)",
        type = "method"
      },
      EnableBoneRotations = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      TargetRotationEnabled = {
        args = "()",
        description = "Whether or not target rotation is enabled",
        returns = "(bool)",
        type = "method"
      },
      EnableTargetRotation = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      ContinuousSolvingEnabled = {
        args = "()",
        description = "Whether or not continuous solving is enabled or not.",
        returns = "(bool)",
        type = "method"
      },
      EnableContinuousSolving = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      UpdatePoseEnabled = {
        args = "()",
        description = "Whether or not the initial pose is updated for every solution",
        returns = "(bool)",
        type = "method"
      },
      EnableUpdatePose = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      AutoSolveEnabled = {
        args = "()",
        description = "Whether or not the solver should be invoked automatically",
        returns = "(bool)",
        type = "method"
      },
      EnableAutoSolve = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      Solve = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ResetToInitialPose = {
        args = "()",
        returns = "()",
        type = "method"
      },
      UpdateInitialPose = {
        args = "()",
        returns = "()",
        type = "method"
      },
      MarkSolverTreeDirty = {
        args = "()",
        description = "Causes the solver tree to be rebuilt before solving the next time.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        returns = "()",
        type = "method"
      },
      algorithm = {
        description = "IKSolver::Algorithm",
        type = "value"
      },
      maximumIterations = {
        description = "unsigned",
        type = "value"
      },
      tolerance = {
        description = "float",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Image = {
    childs = {
      new = {
        args = "()",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(int width, int height, unsigned components)",
        description = "(bool) SetSize (int width, int height, int depth, unsigned components)\nSet 2D size and number of color components. Old image data will be destroyed and new data is undefined. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetPixel = {
        args = "(int x, int y, const Color& color)",
        description = "() SetPixel (int x, int y, int z, const Color& color)\nSet a 2D pixel.",
        returns = "()",
        type = "method"
      },
      SetPixelInt = {
        args = "(int x, int y, unsigned uintColor)",
        description = "() SetPixelInt (int x, int y, int z, unsigned uintColor)\nSet a 2D pixel with an integer color. R component is in the 8 lowest bits.",
        returns = "()",
        type = "method"
      },
      LoadColorLUT = {
        args = "(Deserializer& source)",
        description = "(bool) LoadColorLUT (const String fileName)\nLoad as color LUT. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FlipHorizontal = {
        args = "()",
        description = "Flip image horizontally. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FlipVertical = {
        args = "()",
        description = "Flip image vertically. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Resize = {
        args = "(int width, int height)",
        description = "Resize image by bilinear resampling. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Clear = {
        args = "(const Color& color)",
        description = "Clear the image with a color.",
        returns = "()",
        type = "method"
      },
      ClearInt = {
        args = "(unsigned uintColor)",
        description = "Clear the image with an integer color. R component is in the 8 lowest bits.",
        returns = "()",
        type = "method"
      },
      SaveBMP = {
        args = "(const String fileName)",
        description = "Save in BMP format. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SavePNG = {
        args = "(const String fileName)",
        description = "Save in PNG format. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveTGA = {
        args = "(const String fileName)",
        description = "Save in TGA format. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveJPG = {
        args = "(const String fileName, int quality)",
        description = "Save in JPG format with compression quality. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveDDS = {
        args = "(const String fileName)",
        description = "Save in DDS format. Only uncompressed RGBA images are supported. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetPixel = {
        args = "(int x, int y)",
        description = "(Color) GetPixel (int x, int y, int z)\nReturn a 2D pixel color.",
        returns = "(Color)",
        type = "method"
      },
      GetPixelInt = {
        args = "(int x, int y)",
        description = "(unsigned) GetPixelInt (int x, int y, int z)\nReturn a 2D pixel integer color. R component is in the 8 lowest bits.",
        returns = "(unsigned)",
        type = "method"
      },
      GetPixelBilinear = {
        args = "(float x, float y)",
        description = "Return a bilinearly sampled 2D pixel color. X and Y have the range 0-1.",
        returns = "(Color)",
        type = "method"
      },
      GetPixelTrilinear = {
        args = "(float x, float y, float z)",
        description = "Return a trilinearly sampled 3D pixel color. X, Y and Z have the range 0-1.",
        returns = "(Color)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetDepth = {
        args = "()",
        description = "Return depth.",
        returns = "(int)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of color components.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetCompressedFormat = {
        args = "()",
        description = "Return compressed format.",
        returns = "(CompressedFormat)",
        type = "method"
      },
      GetNumCompressedLevels = {
        args = "()",
        description = "Return number of compressed mip levels. Returns 0 if the image is has not been loaded from a source file containing multiple mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSubimage = {
        args = "(const IntRect& rect)",
        description = "Return subimage from the image by the defined rect or null if failed. 3D images are not supported. You must free the subimage yourself.",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      IsCubemap = {
        args = "()",
        description = "Whether this texture is detected as a cubemap, only relevant for DDS.",
        returns = "(bool)",
        type = "method"
      },
      IsArray = {
        args = "()",
        description = "Whether this texture has been detected as a volume, only relevant for DDS.",
        returns = "(bool)",
        type = "method"
      },
      IsSRGB = {
        args = "()",
        description = "Whether this texture is in sRGB, only relevant for DDS.",
        returns = "(bool)",
        type = "method"
      },
      width = {
        description = "(Readonly) int\nWidth.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nHeight.",
        type = "value"
      },
      depth = {
        description = "(Readonly) int\nDepth.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned\nNumber of color components.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      compressedFormat = {
        description = "(Readonly) CompressedFormat\nCompressed format.",
        type = "value"
      },
      numCompressedLevels = {
        description = "(Readonly) unsigned\nNumber of compressed mip levels.",
        type = "value"
      },
      cubemap = {
        description = "(Readonly) bool\nCubemap status if DDS.",
        type = "value"
      },
      array = {
        description = "(Readonly) bool\nTexture array status if DDS.",
        type = "value"
      },
      sRGB = {
        description = "(Readonly) bool\nData is sRGB.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  IndexBuffer = {
    childs = {
      new = {
        args = "()",
        returns = "(IndexBuffer*)",
        valuetype = "IndexBuffer",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetShadowed = {
        args = "(bool enable)",
        description = "Enable shadowing in CPU memory. Shadowing is forced on if the graphics subsystem does not exist.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(unsigned indexCount, bool largeIndices, bool dynamic = false)",
        description = "Set size and vertex elements and dynamic mode. Previous data will be lost.",
        returns = "(bool)",
        type = "method"
      },
      SetData = {
        args = "(VectorBuffer& data)",
        returns = "(bool)",
        type = "method"
      },
      SetDataRange = {
        args = "(VectorBuffer& data, unsigned start, unsigned count, bool discard = false)",
        returns = "(bool)",
        type = "method"
      },
      GetData = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      IsShadowed = {
        args = "()",
        description = "Return whether CPU memory shadowing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsDynamic = {
        args = "()",
        description = "Return whether is dynamic.",
        returns = "(bool)",
        type = "method"
      },
      GetIndexCount = {
        args = "()",
        description = "Return number of indices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetIndexSize = {
        args = "()",
        description = "Return index size in bytes.",
        returns = "(unsigned)",
        type = "method"
      },
      shadowed = {
        description = "bool\nShadowed flag.",
        type = "value"
      },
      dynamic = {
        description = "(Readonly) bool\nDynamic flag.",
        type = "value"
      },
      indexCount = {
        description = "(Readonly) unsigned\nNumber of indices.",
        type = "value"
      },
      indexSize = {
        description = "(Readonly) unsigned\nIndex size.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Input = {
    childs = {
      SetToggleFullscreen = {
        args = "(bool enable)",
        description = "Set whether ALT-ENTER fullscreen toggle is enabled.",
        returns = "()",
        type = "method"
      },
      SetMouseVisible = {
        args = "(bool enable, bool suppressEvent = false)",
        description = "Set whether the operating system mouse cursor is visible. When not visible (default), is kept centered to prevent leaving the window. Mouse visibility event can be suppressed-- this also recalls any unsuppressed SetMouseVisible which can be returned by ResetMouseVisible().",
        returns = "()",
        type = "method"
      },
      SetMouseGrabbed = {
        args = "(bool grab, bool suppressEvent = false)",
        description = "Set whether the mouse is currently being grabbed by an operation.",
        returns = "()",
        type = "method"
      },
      SetMouseMode = {
        args = "(MouseMode mode, bool suppressEvent = false)",
        returns = "()",
        type = "method"
      },
      IsMouseLocked = {
        args = "()",
        description = "Return whether the mouse is locked to the window",
        returns = "(bool)",
        type = "method"
      },
      AddScreenJoystick = {
        args = "(XMLFile* layoutFile = 0, XMLFile* styleFile = 0)",
        returns = "(int)",
        type = "method"
      },
      RemoveScreenJoystick = {
        args = "(int id)",
        returns = "(bool)",
        type = "method"
      },
      SetScreenJoystickVisible = {
        args = "(int id, bool enable)",
        returns = "()",
        type = "method"
      },
      SetScreenKeyboardVisible = {
        args = "(bool enable)",
        description = "Show or hide on-screen keyboard on platforms that support it. When shown, keypresses from it are delivered as key events.",
        returns = "()",
        type = "method"
      },
      SetTouchEmulation = {
        args = "(bool enable)",
        description = "Set touch emulation by mouse. Only available on desktop platforms. When enabled, actual mouse events are no longer sent and the mouse cursor is forced visible.",
        returns = "()",
        type = "method"
      },
      RecordGesture = {
        args = "()",
        description = "Begin recording a touch gesture. Return true if successful. The E_GESTURERECORDED event (which contains the ID for the new gesture) will be sent when recording finishes.",
        returns = "(bool)",
        type = "method"
      },
      SaveGestures = {
        args = "(File* dest)",
        description = "(bool) SaveGestures (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      SaveGesture = {
        args = "(File* dest, unsigned gestureID)",
        description = "(bool) SaveGesture (const String fileName, unsigned gestureID)",
        returns = "(bool)",
        type = "method"
      },
      LoadGestures = {
        args = "(File* source)",
        description = "(unsigned) LoadGestures (const String fileName)",
        returns = "(unsigned)",
        type = "method"
      },
      RemoveGesture = {
        args = "(unsigned gestureID)",
        description = "Remove an in-memory gesture by ID. Return true if was found.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllGestures = {
        args = "()",
        description = "Remove all in-memory gestures.",
        returns = "()",
        type = "method"
      },
      SetMousePosition = {
        args = "(const IntVector2& position)",
        description = "Set the mouse cursor position. Uses the backbuffer (Graphics width/height) coordinates.",
        returns = "()",
        type = "method"
      },
      CenterMousePosition = {
        args = "()",
        description = "Center the mouse position.",
        returns = "()",
        type = "method"
      },
      GetKeyFromName = {
        args = "(const String name)",
        description = "Return keycode from key name.",
        returns = "(int)",
        type = "method"
      },
      GetKeyFromScancode = {
        args = "(int scancode)",
        description = "Return keycode from scancode.",
        returns = "(int)",
        type = "method"
      },
      GetKeyName = {
        args = "(int key)",
        description = "Return name of key from keycode.",
        returns = "(String)",
        type = "method"
      },
      GetScancodeFromKey = {
        args = "(int key)",
        description = "Return scancode from keycode.",
        returns = "(int)",
        type = "method"
      },
      GetScancodeFromName = {
        args = "(const String name)",
        description = "Return scancode from key name.",
        returns = "(int)",
        type = "method"
      },
      GetScancodeName = {
        args = "(int scancode)",
        description = "Return name of key from scancode.",
        returns = "(String)",
        type = "method"
      },
      GetKeyDown = {
        args = "(int key)",
        description = "Check if a key is held down.",
        returns = "(bool)",
        type = "method"
      },
      GetKeyPress = {
        args = "(int key)",
        description = "Check if a key has been pressed on this frame.",
        returns = "(bool)",
        type = "method"
      },
      GetScancodeDown = {
        args = "(int scancode)",
        description = "Check if a key is held down by scancode.",
        returns = "(bool)",
        type = "method"
      },
      GetScancodePress = {
        args = "(int scancode)",
        description = "Check if a key has been pressed on this frame by scancode.",
        returns = "(bool)",
        type = "method"
      },
      GetMouseButtonDown = {
        args = "(int button)",
        description = "Check if a mouse button is held down.",
        returns = "(bool)",
        type = "method"
      },
      GetMouseButtonPress = {
        args = "(int button)",
        description = "Check if a mouse button has been pressed on this frame.",
        returns = "(bool)",
        type = "method"
      },
      GetQualifierDown = {
        args = "(int qualifier)",
        description = "Check if a qualifier key is held down.",
        returns = "(bool)",
        type = "method"
      },
      GetQualifierPress = {
        args = "(int qualifier)",
        description = "Check if a qualifier key has been pressed on this frame.",
        returns = "(bool)",
        type = "method"
      },
      GetQualifiers = {
        args = "()",
        description = "Return the currently held down qualifiers.",
        returns = "(int)",
        type = "method"
      },
      GetMousePosition = {
        args = "()",
        description = "Return mouse position within window. Should only be used with a visible mouse cursor. Uses the backbuffer (Graphics width/height) coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetMouseMove = {
        args = "()",
        description = "Return mouse movement since last frame.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetMouseMoveX = {
        args = "()",
        description = "Return horizontal mouse movement since last frame.",
        returns = "(int)",
        type = "method"
      },
      GetMouseMoveY = {
        args = "()",
        description = "Return vertical mouse movement since last frame.",
        returns = "(int)",
        type = "method"
      },
      GetMouseMoveWheel = {
        args = "()",
        description = "Return mouse wheel movement since last frame.",
        returns = "(int)",
        type = "method"
      },
      GetInputScale = {
        args = "()",
        description = "Return input coordinate scaling. Should return non-unity on High DPI display.",
        returns = "(Vector2)",
        type = "method"
      },
      GetNumTouches = {
        args = "()",
        description = "Return number of active finger touches.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTouch = {
        args = "(unsigned index)",
        description = "Return active finger touch by index.",
        returns = "(TouchState*)",
        valuetype = "TouchState",
        type = "method"
      },
      GetNumJoysticks = {
        args = "()",
        description = "Return number of connected joysticks.",
        returns = "(unsigned)",
        type = "method"
      },
      GetJoystick = {
        args = "(int id)",
        returns = "(JoystickState*)",
        valuetype = "JoystickState",
        type = "method"
      },
      GetJoystickByIndex = {
        args = "(unsigned index)",
        description = "Return joystick state by index, or null if does not exist. 0 = first connected joystick.",
        returns = "(JoystickState*)",
        valuetype = "JoystickState",
        type = "method"
      },
      GetJoystickByName = {
        args = "(const String name)",
        description = "Return joystick state by name, or null if does not exist.",
        returns = "(JoystickState*)",
        valuetype = "JoystickState",
        type = "method"
      },
      GetToggleFullscreen = {
        args = "()",
        description = "Return whether fullscreen toggle is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetScreenKeyboardSupport = {
        args = "()",
        description = "Return whether on-screen keyboard is supported.",
        returns = "(bool)",
        type = "method"
      },
      IsScreenJoystickVisible = {
        args = "(int id)",
        returns = "(bool)",
        type = "method"
      },
      IsScreenKeyboardVisible = {
        args = "()",
        description = "Return whether on-screen keyboard is being shown.",
        returns = "(bool)",
        type = "method"
      },
      GetTouchEmulation = {
        args = "()",
        description = "Return whether touch emulation is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsMouseVisible = {
        args = "()",
        description = "Return whether the operating system mouse cursor is visible.",
        returns = "(bool)",
        type = "method"
      },
      IsMouseGrabbed = {
        args = "()",
        description = "Return whether the mouse is currently being grabbed by an operation.",
        returns = "(bool)",
        type = "method"
      },
      GetMouseMode = {
        args = "()",
        description = "Return the mouse mode.",
        returns = "(MouseMode)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether application window has input focus.",
        returns = "(bool)",
        type = "method"
      },
      IsMinimized = {
        args = "()",
        description = "Return whether application window is minimized.",
        returns = "(bool)",
        type = "method"
      },
      qualifiers = {
        description = "(Readonly) int",
        type = "value"
      },
      mousePosition = {
        description = "IntVector2",
        type = "value"
      },
      mouseMove = {
        description = "(Readonly) IntVector2\nMouse movement since last frame.",
        type = "value"
      },
      mouseMoveX = {
        description = "(Readonly) int",
        type = "value"
      },
      mouseMoveY = {
        description = "(Readonly) int",
        type = "value"
      },
      mouseMoveWheel = {
        description = "(Readonly) int\nMouse wheel movement since last frame.",
        type = "value"
      },
      inputScale = {
        description = "(Readonly) Vector2\nInput coordinate scaling. Non-unity when window and backbuffer have different sizes (e.g. Retina display.)",
        type = "value"
      },
      numTouches = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numJoysticks = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      toggleFullscreen = {
        description = "(Readonly) bool\nFullscreen toggle flag.",
        type = "value"
      },
      screenKeyboardSupport = {
        description = "(Readonly) bool",
        type = "value"
      },
      mouseMode = {
        description = "MouseMode\nDetermines the mode of mouse behaviour.",
        type = "value"
      },
      screenKeyboardVisible = {
        description = "bool",
        type = "value"
      },
      touchEmulation = {
        description = "bool\nTouch emulation mode flag.",
        type = "value"
      },
      mouseVisible = {
        description = "bool\nOperating system mouse cursor visible flag.",
        type = "value"
      },
      mouseGrabbed = {
        description = "bool\nFlag to indicate the mouse is being grabbed by an operation. Subsystems like UI that uses mouse should temporarily ignore the mouse hover or click events.",
        type = "value"
      },
      mouseLocked = {
        description = "(Readonly) bool",
        type = "value"
      },
      focus = {
        description = "(Readonly) bool",
        type = "value"
      },
      minimized = {
        description = "(Readonly) bool\nMinimized flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  IntRect = {
    childs = {
      new = {
        args = "()",
        description = "(IntRect*) new (int left, int top, int right, int bottom)",
        returns = "(IntRect*)",
        valuetype = "IntRect",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      Width = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      Height = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      IsInside = {
        args = "(const IntVector2& point)",
        returns = "(Intersection)",
        type = "method"
      },
      left = {
        description = "int",
        type = "value"
      },
      top = {
        description = "int",
        type = "value"
      },
      right = {
        description = "int",
        type = "value"
      },
      bottom = {
        description = "int",
        type = "value"
      },
      ZERO = {
        description = "const IntRect",
        type = "value"
      },
      size = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
    },
    type = "class"
  },
  IntVector2 = {
    childs = {
      new = {
        args = "()",
        description = "(IntVector2*) new (int x, int y),\n(IntVector2*) new (const IntVector2& rhs)",
        returns = "(IntVector2*)",
        valuetype = "IntVector2",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ToHash = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      Length = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      x = {
        description = "int",
        type = "value"
      },
      y = {
        description = "int",
        type = "value"
      },
      ZERO = {
        description = "const IntVector2",
        type = "value"
      },
    },
    type = "class"
  },
  IntVector3 = {
    childs = {
      new = {
        args = "()",
        description = "(IntVector3*) new (int x, int y, int z),\n(IntVector3*) new (const IntVector3& rhs)",
        returns = "(IntVector3*)",
        valuetype = "IntVector3",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ToHash = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      Length = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      x = {
        description = "int",
        type = "value"
      },
      y = {
        description = "int",
        type = "value"
      },
      z = {
        description = "int",
        type = "value"
      },
      ZERO = {
        description = "const IntVector3",
        type = "value"
      },
      LEFT = {
        description = "const IntVector3",
        type = "value"
      },
      RIGHT = {
        description = "const IntVector3",
        type = "value"
      },
      UP = {
        description = "const IntVector3",
        type = "value"
      },
      DOWN = {
        description = "const IntVector3",
        type = "value"
      },
      FORWARD = {
        description = "const IntVector3",
        type = "value"
      },
      BACK = {
        description = "const IntVector3",
        type = "value"
      },
      ONE = {
        description = "const IntVector3",
        type = "value"
      },
    },
    type = "class"
  },
  JSONFile = {
    childs = {
      new = {
        args = "()",
        returns = "(JSONFile*)",
        valuetype = "JSONFile",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      FromString = {
        args = "(const String source)",
        description = "Deserialize from a string. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root value.\nReturn root value.",
        returns = "(const JSONValue&)",
        valuetype = "JSONValue",
        type = "method"
      },
      Save = {
        args = "(const String fileName, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  JSONValue = {
    childs = {
      new = {
        args = "()",
        description = "(JSONValue*) new (bool value),\n(JSONValue*) new (const char* value),\n(JSONValue*) new (double value),\n(JSONValue*) new (const JSONArray& value),\n(JSONValue*) new (const JSONObject& value),\n(JSONValue*) new (const JSONValue& value)",
        returns = "(JSONValue*)",
        valuetype = "JSONValue",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetBool = {
        args = "(bool value)",
        returns = "()",
        type = "method"
      },
      SetInt = {
        args = "(int value)",
        returns = "()",
        type = "method"
      },
      SetUint = {
        args = "(unsigned value)",
        returns = "()",
        type = "method"
      },
      SetFloat = {
        args = "(float value)",
        returns = "()",
        type = "method"
      },
      SetDouble = {
        args = "(double value)",
        returns = "()",
        type = "method"
      },
      SetString = {
        args = "(const String value)",
        returns = "()",
        type = "method"
      },
      SetArray = {
        args = "(const JSONArray& value)",
        returns = "()",
        type = "method"
      },
      SetObject = {
        args = "(const JSONObject& value)",
        returns = "()",
        type = "method"
      },
      GetValueType = {
        args = "()",
        returns = "(JSONValueType)",
        type = "method"
      },
      GetNumberType = {
        args = "()",
        returns = "(JSONNumberType)",
        type = "method"
      },
      GetValueTypeName = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      GetNumberTypeName = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      IsNull = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsNumber = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsString = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsArray = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsObject = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetDouble = {
        args = "()",
        returns = "(double)",
        type = "method"
      },
      GetString = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetArray = {
        args = "()",
        returns = "(const JSONArray&)",
        valuetype = "JSONArray",
        type = "method"
      },
      GetObject = {
        args = "()",
        returns = "(const JSONObject&)",
        valuetype = "JSONObject",
        type = "method"
      },
      Push = {
        args = "(const JSONValue& value)",
        returns = "()",
        type = "method"
      },
      Pop = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Insert = {
        args = "(unsigned pos, const JSONValue& value)",
        returns = "()",
        type = "method"
      },
      Erase = {
        args = "(unsigned pos, unsigned length = 1)",
        description = "(bool) Erase (const String key)",
        returns = "()",
        type = "method"
      },
      Resize = {
        args = "(unsigned newSize)",
        returns = "()",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      Set = {
        args = "(const String key, const JSONValue& value)",
        returns = "()",
        type = "method"
      },
      Get = {
        args = "(const String key)",
        returns = "(const JSONValue&)",
        valuetype = "JSONValue",
        type = "method"
      },
      Contains = {
        args = "(const String key)",
        returns = "(bool)",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      EMPTY = {
        description = "const JSONValue",
        type = "value"
      },
      emptyArray = {
        description = "const JSONArray",
        type = "value"
      },
      emptyObject = {
        description = "const JSONObject",
        type = "value"
      },
      null = {
        description = "(Readonly) bool",
        type = "value"
      },
      valueType = {
        description = "(Readonly) JSONValueType",
        type = "value"
      },
      numberType = {
        description = "(Readonly) JSONNumberType",
        type = "value"
      },
      valueTypeName = {
        description = "(Readonly) String",
        type = "value"
      },
      numberTypeName = {
        description = "(Readonly) String",
        type = "value"
      },
    },
    type = "class"
  },
  JoystickState = {
    childs = {
      IsController = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetNumButtons = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumAxes = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumHats = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetButtonDown = {
        args = "(unsigned index)",
        returns = "(bool)",
        type = "method"
      },
      GetButtonPress = {
        args = "(unsigned index)",
        returns = "(bool)",
        type = "method"
      },
      GetAxisPosition = {
        args = "(unsigned index)",
        returns = "(float)",
        type = "method"
      },
      GetHatPosition = {
        args = "(unsigned index)",
        returns = "(int)",
        type = "method"
      },
      name = {
        description = "const String",
        type = "value"
      },
      joystickID = {
        description = "const int",
        type = "value"
      },
      controller = {
        description = "(Readonly) bool",
        type = "value"
      },
      numButtons = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numAxes = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numHats = {
        description = "(Readonly) unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  Light = {
    childs = {
      SetLightType = {
        args = "(LightType type)",
        description = "Set light type.",
        returns = "()",
        type = "method"
      },
      SetPerVertex = {
        args = "(bool enable)",
        description = "Set vertex lighting mode.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color.",
        returns = "()",
        type = "method"
      },
      SetTemperature = {
        args = "(float temperature)",
        description = "Set temperature of the light in Kelvin. Modulates the light color when \"use physical values\" is enabled.",
        returns = "()",
        type = "method"
      },
      SetRadius = {
        args = "(float redius)",
        description = "Set area light radius. Greater than zero activates area light mode. Works only with PBR shaders.",
        returns = "()",
        type = "method"
      },
      SetLength = {
        args = "(float length)",
        description = "Set tube area light length. Works only with PBR shaders.",
        returns = "()",
        type = "method"
      },
      SetUsePhysicalValues = {
        args = "(bool enable)",
        description = "Set use physical light values.",
        returns = "()",
        type = "method"
      },
      SetSpecularIntensity = {
        args = "(float intensity)",
        description = "Set specular intensity. Zero disables specular calculations.",
        returns = "()",
        type = "method"
      },
      SetBrightness = {
        args = "(float brightness)",
        description = "Set light brightness multiplier. Both the color and specular intensity are multiplied with this. When \"use physical values\" is enabled, the value is specified in lumens.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set range.",
        returns = "()",
        type = "method"
      },
      SetFov = {
        args = "(float fov)",
        description = "Set spotlight field of view.",
        returns = "()",
        type = "method"
      },
      SetAspectRatio = {
        args = "(float aspectRatio)",
        description = "Set spotlight aspect ratio.",
        returns = "()",
        type = "method"
      },
      SetFadeDistance = {
        args = "(float distance)",
        description = "Set fade out start distance.",
        returns = "()",
        type = "method"
      },
      SetShadowFadeDistance = {
        args = "(float distance)",
        description = "Set shadow fade out start distance. Only has effect if shadow distance is also non-zero.",
        returns = "()",
        type = "method"
      },
      SetShadowBias = {
        args = "(const BiasParameters& parameters)",
        description = "Set shadow depth bias parameters.",
        returns = "()",
        type = "method"
      },
      SetShadowCascade = {
        args = "(const CascadeParameters& parameters)",
        description = "Set directional light cascaded shadow parameters.",
        returns = "()",
        type = "method"
      },
      SetShadowFocus = {
        args = "(const FocusParameters& parameters)",
        description = "Set shadow map focusing parameters.",
        returns = "()",
        type = "method"
      },
      SetShadowIntensity = {
        args = "(float intensity)",
        description = "Set light intensity in shadow between 0.0 - 1.0. 0.0 (the default) gives fully dark shadows.",
        returns = "()",
        type = "method"
      },
      SetShadowResolution = {
        args = "(float resolution)",
        description = "Set shadow resolution between 0.25 - 1.0. Determines the shadow map to use.",
        returns = "()",
        type = "method"
      },
      SetShadowNearFarRatio = {
        args = "(float nearFarRatio)",
        description = "Set shadow camera near/far clip distance ratio for spot and point lights. Does not affect directional lights, since they are orthographic and have near clip 0.",
        returns = "()",
        type = "method"
      },
      SetShadowMaxExtrusion = {
        args = "(float extrusion)",
        description = "Set maximum shadow extrusion for directional lights. The actual extrusion will be the smaller of this and camera far clip. Default 1000.",
        returns = "()",
        type = "method"
      },
      SetRampTexture = {
        args = "(Texture* texture)",
        description = "Set range attenuation texture.",
        returns = "()",
        type = "method"
      },
      SetShapeTexture = {
        args = "(Texture* texture)",
        description = "Set spotlight attenuation texture.",
        returns = "()",
        type = "method"
      },
      GetLightType = {
        args = "()",
        description = "Return light type.",
        returns = "(LightType)",
        type = "method"
      },
      GetPerVertex = {
        args = "()",
        description = "Return vertex lighting mode.",
        returns = "(bool)",
        type = "method"
      },
      GetColor = {
        args = "()",
        description = "Return color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetTemperature = {
        args = "()",
        description = "Return the temperature of the light in Kelvin.",
        returns = "(float)",
        type = "method"
      },
      GetRadius = {
        args = "()",
        description = "Return area light mode radius. Works only with PBR shaders.",
        returns = "(float)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return area tube light length. Works only with PBR shaders.",
        returns = "(float)",
        type = "method"
      },
      GetSpecularIntensity = {
        args = "()",
        description = "Return specular intensity.",
        returns = "(float)",
        type = "method"
      },
      GetBrightness = {
        args = "()",
        description = "Return brightness multiplier. Specified in lumens when \"use physical values\" is enabled.",
        returns = "(float)",
        type = "method"
      },
      GetEffectiveColor = {
        args = "()",
        description = "Return effective color, multiplied by brightness and affected by temperature when \"use physical values\" is enabled. Alpha is always 1 so that can compare against the default black color to detect a light with no effect.\nReturn whether light has negative (darkening) color.",
        returns = "(Color)",
        type = "method"
      },
      GetColorFromTemperature = {
        args = "()",
        description = "Return the color value of the temperature in Kelvin.",
        returns = "(Color)",
        type = "method"
      },
      GetUsePhysicalValues = {
        args = "()",
        description = "Return if light uses temperature and brightness in lumens.",
        returns = "(bool)",
        type = "method"
      },
      GetEffectiveSpecularIntensity = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return range.",
        returns = "(float)",
        type = "method"
      },
      GetFov = {
        args = "()",
        description = "Return spotlight field of view.",
        returns = "(float)",
        type = "method"
      },
      GetAspectRatio = {
        args = "()",
        description = "Return spotlight aspect ratio.",
        returns = "(float)",
        type = "method"
      },
      GetFadeDistance = {
        args = "()",
        description = "Return fade start distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowFadeDistance = {
        args = "()",
        description = "Return shadow fade start distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowBias = {
        args = "()",
        description = "Return shadow depth bias parameters.",
        returns = "(const BiasParameters&)",
        valuetype = "BiasParameters",
        type = "method"
      },
      GetShadowCascade = {
        args = "()",
        description = "Return directional light cascaded shadow parameters.",
        returns = "(const CascadeParameters&)",
        valuetype = "CascadeParameters",
        type = "method"
      },
      GetShadowFocus = {
        args = "()",
        description = "Return shadow map focus parameters.",
        returns = "(const FocusParameters&)",
        valuetype = "FocusParameters",
        type = "method"
      },
      GetShadowIntensity = {
        args = "()",
        description = "Return light intensity in shadow.",
        returns = "(float)",
        type = "method"
      },
      GetShadowResolution = {
        args = "()",
        description = "Return shadow resolution.",
        returns = "(float)",
        type = "method"
      },
      GetShadowNearFarRatio = {
        args = "()",
        description = "Return shadow camera near/far clip distance ratio.",
        returns = "(float)",
        type = "method"
      },
      GetShadowMaxExtrusion = {
        args = "()",
        description = "Return maximum shadow extrusion distance for directional lights.",
        returns = "(float)",
        type = "method"
      },
      GetRampTexture = {
        args = "()",
        description = "Return range attenuation texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetShapeTexture = {
        args = "()",
        description = "Return spotlight attenuation texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetFrustum = {
        args = "()",
        description = "Return spotlight frustum.",
        returns = "(Frustum)",
        type = "method"
      },
      GetNumShadowSplits = {
        args = "()",
        description = "Return number of shadow map cascade splits for a directional light, considering also graphics API limitations.",
        returns = "(int)",
        type = "method"
      },
      IsNegative = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      lightType = {
        description = "LightType",
        type = "value"
      },
      perVertex = {
        description = "bool",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      temperature = {
        description = "float",
        type = "value"
      },
      radius = {
        description = "float",
        type = "value"
      },
      length = {
        description = "float",
        type = "value"
      },
      usePhysicalValues = {
        description = "bool",
        type = "value"
      },
      specularIntensity = {
        description = "float",
        type = "value"
      },
      brightness = {
        description = "float",
        type = "value"
      },
      range = {
        description = "float",
        type = "value"
      },
      fov = {
        description = "float",
        type = "value"
      },
      aspectRatio = {
        description = "float",
        type = "value"
      },
      fadeDistance = {
        description = "float",
        type = "value"
      },
      shadowFadeDistance = {
        description = "float",
        type = "value"
      },
      shadowBias = {
        valuetype = "BiasParameters",
        description = "BiasParameters&",
        type = "value"
      },
      shadowCascade = {
        valuetype = "CascadeParameters",
        description = "CascadeParameters&",
        type = "value"
      },
      shadowFocus = {
        valuetype = "FocusParameters",
        description = "FocusParameters&",
        type = "value"
      },
      shadowIntensity = {
        description = "float",
        type = "value"
      },
      shadowResolution = {
        description = "float",
        type = "value"
      },
      shadowNearFarRatio = {
        description = "float",
        type = "value"
      },
      shadowMaxExtrusion = {
        description = "float",
        type = "value"
      },
      rampTexture = {
        valuetype = "Texture",
        description = "Texture*",
        type = "value"
      },
      shapeTexture = {
        valuetype = "Texture",
        description = "Texture*",
        type = "value"
      },
      frustum = {
        description = "(Readonly) Frustum",
        type = "value"
      },
      numShadowSplits = {
        description = "(Readonly) int",
        type = "value"
      },
      negative = {
        description = "(Readonly) bool",
        type = "value"
      },
      effectiveColor = {
        description = "(Readonly) Color",
        type = "value"
      },
      effectiveSpecularIntensity = {
        description = "(Readonly) float",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  LineEdit = {
    childs = {
      new = {
        args = "()",
        returns = "(LineEdit*)",
        valuetype = "LineEdit",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetText = {
        args = "(const String text)",
        description = "Set text.",
        returns = "()",
        type = "method"
      },
      SetCursorPosition = {
        args = "(unsigned position)",
        description = "Set cursor position.",
        returns = "()",
        type = "method"
      },
      SetCursorBlinkRate = {
        args = "(float rate)",
        description = "Set cursor blink rate. 0 disables blinking.",
        returns = "()",
        type = "method"
      },
      SetMaxLength = {
        args = "(unsigned length)",
        description = "Set maximum text length. 0 for unlimited.",
        returns = "()",
        type = "method"
      },
      SetEchoCharacter = {
        args = "(unsigned c)",
        description = "Set echo character for password entry and such. 0 (default) shows the actual text.",
        returns = "()",
        type = "method"
      },
      SetCursorMovable = {
        args = "(bool enable)",
        description = "Set whether can move cursor with arrows or mouse, default true.",
        returns = "()",
        type = "method"
      },
      SetTextSelectable = {
        args = "(bool enable)",
        description = "Set whether selections are allowed, default true.",
        returns = "()",
        type = "method"
      },
      SetTextCopyable = {
        args = "(bool enable)",
        description = "Set whether copy-paste operations are allowed, default true.",
        returns = "()",
        type = "method"
      },
      GetText = {
        args = "()",
        description = "Return text.",
        returns = "(const String)",
        type = "method"
      },
      GetCursorPosition = {
        args = "()",
        description = "Return cursor position.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCursorBlinkRate = {
        args = "()",
        description = "Return cursor blink rate.",
        returns = "(float)",
        type = "method"
      },
      GetMaxLength = {
        args = "()",
        description = "Return maximum text length.",
        returns = "(unsigned)",
        type = "method"
      },
      GetEchoCharacter = {
        args = "()",
        description = "Return echo character.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCursorMovable = {
        args = "()",
        description = "Return whether can move cursor with arrows or mouse.",
        returns = "(bool)",
        type = "method"
      },
      IsTextSelectable = {
        args = "()",
        description = "Return whether selections are allowed.",
        returns = "(bool)",
        type = "method"
      },
      IsTextCopyable = {
        args = "()",
        description = "Return whether copy-paste operations are allowed.",
        returns = "(bool)",
        type = "method"
      },
      GetTextElement = {
        args = "()",
        description = "Return text element.",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      GetCursor = {
        args = "()",
        description = "Return cursor element.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      text = {
        description = "String\nText element.",
        type = "value"
      },
      cursorPosition = {
        description = "unsigned\nText edit cursor position.",
        type = "value"
      },
      cursorBlinkRate = {
        description = "float\nCursor blink rate.",
        type = "value"
      },
      maxLength = {
        description = "unsigned\nMaximum text length.",
        type = "value"
      },
      echoCharacter = {
        description = "unsigned\nEcho character.",
        type = "value"
      },
      cursorMovable = {
        description = "bool\nCursor movable flag.",
        type = "value"
      },
      textSelectable = {
        description = "bool\nText selectable flag.",
        type = "value"
      },
      textCopyable = {
        description = "bool\nCopy-paste enable flag.",
        type = "value"
      },
      textElement = {
        valuetype = "Text",
        description = "(Readonly) Text*",
        type = "value"
      },
      cursor = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nCursor element.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ListView = {
    childs = {
      new = {
        args = "()",
        returns = "(ListView*)",
        valuetype = "ListView",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      AddItem = {
        args = "(UIElement* item)",
        description = "Add item to the end of the list.",
        returns = "()",
        type = "method"
      },
      InsertItem = {
        args = "(unsigned index, UIElement* item, UIElement* parentItem = 0)",
        description = "And if the index is lesser than the index of the parent item itself then the new item is inserted before the first child item.",
        returns = "()",
        type = "method"
      },
      RemoveItem = {
        args = "(UIElement* item, unsigned index = 0)",
        description = "() RemoveItem (unsigned index)\nRemove specific item, starting search at the specified index if provided. In hierarchy mode will also remove any children.",
        returns = "()",
        type = "method"
      },
      RemoveAllItems = {
        args = "()",
        description = "Remove all items.",
        returns = "()",
        type = "method"
      },
      SetSelection = {
        args = "(unsigned index)",
        description = "Set selection.",
        returns = "()",
        type = "method"
      },
      SetSelections = {
        args = "(const PODVector<unsigned>& indices)",
        returns = "()",
        type = "method"
      },
      AddSelection = {
        args = "(unsigned index)",
        description = "Add item to the selection, multiselect mode only.",
        returns = "()",
        type = "method"
      },
      RemoveSelection = {
        args = "(unsigned index)",
        description = "Remove item from the selection.",
        returns = "()",
        type = "method"
      },
      ToggleSelection = {
        args = "(unsigned index)",
        description = "Toggle selection of an item.",
        returns = "()",
        type = "method"
      },
      ChangeSelection = {
        args = "(int delta, bool additive = false)",
        description = "Move selection by a delta and clamp at list ends. If additive (multiselect only), will add to the existing selection.",
        returns = "()",
        type = "method"
      },
      ClearSelection = {
        args = "()",
        description = "Clear selection.",
        returns = "()",
        type = "method"
      },
      SetHighlightMode = {
        args = "(HighlightMode mode)",
        description = "Set selected items' highlight mode.",
        returns = "()",
        type = "method"
      },
      SetMultiselect = {
        args = "(bool enable)",
        description = "Enable multiselect.",
        returns = "()",
        type = "method"
      },
      SetHierarchyMode = {
        args = "(bool enable)",
        description = "All items in the list will be lost during mode change.",
        returns = "()",
        type = "method"
      },
      SetBaseIndent = {
        args = "(int baseIndent)",
        description = "Set base indent, i.e. the indent level of the ultimate parent item.",
        returns = "()",
        type = "method"
      },
      SetClearSelectionOnDefocus = {
        args = "(bool enable)",
        description = "Enable clearing of selection on defocus.",
        returns = "()",
        type = "method"
      },
      SetSelectOnClickEnd = {
        args = "(bool enable)",
        description = "Enable reacting to click end instead of click start for item selection. Default false.",
        returns = "()",
        type = "method"
      },
      Expand = {
        args = "(unsigned index, bool enable, bool recursive = false)",
        description = "Expand item at index. Only has effect in hierarchy mode.",
        returns = "()",
        type = "method"
      },
      ToggleExpand = {
        args = "(unsigned index, bool recursive = false)",
        description = "Toggle item's expanded flag at index. Only has effect in hierarchy mode.",
        returns = "()",
        type = "method"
      },
      GetNumItems = {
        args = "()",
        description = "Return number of items.",
        returns = "(unsigned)",
        type = "method"
      },
      GetItem = {
        args = "(unsigned index)",
        description = "Return item at index.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetItems = {
        args = "()",
        description = "Return all items.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      FindItem = {
        args = "(UIElement* item)",
        description = "Return index of item, or M_MAX_UNSIGNED If not found.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelection = {
        args = "()",
        description = "Return first selected index, or M_MAX_UNSIGNED if none selected.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelections = {
        args = "()",
        description = "Return all selected indices.",
        returns = "(const PODVector<unsigned>&)",
        valuetype = "PODVector<unsigned>",
        type = "method"
      },
      CopySelectedItemsToClipboard = {
        args = "()",
        description = "Copy selected items to system clipboard. Currently only applicable to Text items.",
        returns = "()",
        type = "method"
      },
      GetSelectedItem = {
        args = "()",
        description = "Return first selected item, or null if none selected.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetSelectedItems = {
        args = "()",
        description = "Return all selected items.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      IsSelected = {
        args = "(unsigned index)",
        description = "Return whether an item at index is seleccted.",
        returns = "(bool)",
        type = "method"
      },
      IsExpanded = {
        args = "(unsigned index)",
        description = "Return whether an item at index has its children expanded (in hierarchy mode only).",
        returns = "(bool)",
        type = "method"
      },
      GetHighlightMode = {
        args = "()",
        description = "Return highlight mode.",
        returns = "(HighlightMode)",
        type = "method"
      },
      GetMultiselect = {
        args = "()",
        description = "Return whether multiselect enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetClearSelectionOnDefocus = {
        args = "()",
        description = "Return whether selection is cleared on defocus.",
        returns = "(bool)",
        type = "method"
      },
      GetSelectOnClickEnd = {
        args = "()",
        description = "Return whether reacts to click end instead of click start for item selection.",
        returns = "(bool)",
        type = "method"
      },
      GetHierarchyMode = {
        args = "()",
        description = "Return whether hierarchy mode enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetBaseIndent = {
        args = "()",
        description = "Return base indent.",
        returns = "(int)",
        type = "method"
      },
      numItems = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      selection = {
        description = "unsigned",
        type = "value"
      },
      selectedItem = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      highlightMode = {
        description = "HighlightMode\nHighlight mode.",
        type = "value"
      },
      multiselect = {
        description = "bool\nMultiselect flag.",
        type = "value"
      },
      clearSelectionOnDefocus = {
        description = "bool\nClear selection on defocus flag.",
        type = "value"
      },
      selectOnClickEnd = {
        description = "bool\nReact to click end instead of click start flag.",
        type = "value"
      },
      hierarchyMode = {
        description = "bool\nHierarchy mode flag.",
        type = "value"
      },
      baseIndent = {
        description = "int\nBase indent, used in hierarchy mode only.",
        type = "value"
      },
      SetContentElement = {
        args = "(UIElement* element)",
        description = "Set content element.",
        returns = "()",
        type = "method"
      },
      SetViewPosition = {
        args = "(const IntVector2& position)",
        description = "() SetViewPosition (int x, int y)\nSet view offset from the top-left corner.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsVisible = {
        args = "(bool horizontal, bool vertical)",
        description = "Set scrollbars' visibility manually. Disables scrollbar autoshow/hide.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsAutoVisible = {
        args = "(bool enable)",
        description = "Set whether to automatically show/hide scrollbars. Default true.",
        returns = "()",
        type = "method"
      },
      SetScrollStep = {
        args = "(float step)",
        description = "Set arrow key scroll step. Also sets it on the scrollbars.",
        returns = "()",
        type = "method"
      },
      SetPageStep = {
        args = "(float step)",
        description = "Set arrow key page step.",
        returns = "()",
        type = "method"
      },
      SetScrollDeceleration = {
        args = "(float deceleration)",
        description = "Set scroll deceleration.",
        returns = "()",
        type = "method"
      },
      SetScrollSnapEpsilon = {
        args = "(float snap)",
        description = "Set scroll snap epsilon",
        returns = "()",
        type = "method"
      },
      SetAutoDisableChildren = {
        args = "(bool disable)",
        description = "Set whether child elements should be disabled while touch scrolling.",
        returns = "()",
        type = "method"
      },
      SetAutoDisableThreshold = {
        args = "(float amount)",
        description = "Set how much touch movement is needed to trigger child element disabling.",
        returns = "()",
        type = "method"
      },
      GetViewPosition = {
        args = "()",
        description = "Return view offset from the top-left corner.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetContentElement = {
        args = "()",
        description = "Return content element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetHorizontalScrollBar = {
        args = "()",
        description = "Return horizontal scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetVerticalScrollBar = {
        args = "()",
        description = "Return vertical scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetScrollPanel = {
        args = "()",
        description = "Return scroll panel.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetScrollBarsAutoVisible = {
        args = "()",
        description = "Return whether scrollbars are automatically shown/hidden.",
        returns = "(bool)",
        type = "method"
      },
      GetScrollStep = {
        args = "()",
        description = "Return arrow key scroll step.",
        returns = "(float)",
        type = "method"
      },
      GetPageStep = {
        args = "()",
        description = "Return arrow key page step.",
        returns = "(float)",
        type = "method"
      },
      GetScrollDeceleration = {
        args = "()",
        description = "Return scroll deceleration.",
        returns = "(float)",
        type = "method"
      },
      GetScrollSnapEpsilon = {
        args = "()",
        description = "Return scroll snap epsilon",
        returns = "(float)",
        type = "method"
      },
      GetAutoDisableChildren = {
        args = "()",
        description = "Return whether child element will be disabled while touch scrolling.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoDisableThreshold = {
        args = "()",
        description = "Return how much touch movement is needed to trigger child element disabling.",
        returns = "(float)",
        type = "method"
      },
      viewPosition = {
        valuetype = "IntVector2",
        description = "IntVector2&\nCurrent view offset from the top-left corner.",
        type = "value"
      },
      contentElement = {
        valuetype = "UIElement",
        description = "UIElement*\nContent element.",
        type = "value"
      },
      horizontalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nHorizontal scroll bar.",
        type = "value"
      },
      verticalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nVertical scroll bar.",
        type = "value"
      },
      scrollPanel = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nScroll panel element.",
        type = "value"
      },
      scrollBarsAutoVisible = {
        description = "bool\nAutomatically show/hide scrollbars flag.",
        type = "value"
      },
      scrollStep = {
        description = "float",
        type = "value"
      },
      pageStep = {
        description = "float\nArrow key page step.",
        type = "value"
      },
      scrollDeceleration = {
        description = "float\nScroll deceleration",
        type = "value"
      },
      scrollSnapEpsilon = {
        description = "float\nScroll snap epsilon",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Localization = {
    childs = {
      GetNumLanguages = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetLanguageIndex = {
        args = "()",
        description = "(int) GetLanguageIndex (const String language)\nReturn the index number of current language. The index is determined by the order of loading.",
        returns = "(int)",
        type = "method"
      },
      GetLanguage = {
        args = "()",
        description = "(String) GetLanguage (int index)\nReturn the name of current language.",
        returns = "(String)",
        type = "method"
      },
      SetLanguage = {
        args = "(const String language)",
        description = "() SetLanguage (int index)\nSet current language.",
        returns = "()",
        type = "method"
      },
      Get = {
        args = "(const String id)",
        description = "Return a string in the current language. Returns String::EMPTY if id is empty. Returns id if translation is not found and logs a warning.",
        returns = "(String)",
        type = "method"
      },
      Reset = {
        args = "()",
        description = "Clear all loaded strings.",
        returns = "()",
        type = "method"
      },
      LoadJSON = {
        args = "(const JSONValue& source)",
        description = "Load strings from JSONValue.",
        returns = "()",
        type = "method"
      },
      LoadJSONFile = {
        args = "(const String name)",
        description = "Load strings from JSONFile. The file should be UTF8 without BOM.",
        returns = "()",
        type = "method"
      },
      numLanguages = {
        description = "(Readonly) int",
        type = "value"
      },
      languageIndex = {
        description = "(Readonly) int\nIndex of current language.",
        type = "value"
      },
      language = {
        description = "(Readonly) String",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Log = {
    childs = {
      Open = {
        args = "(const String fileName)",
        description = "Open the log file.",
        returns = "()",
        type = "method"
      },
      Close = {
        args = "()",
        description = "Close the log file.",
        returns = "()",
        type = "method"
      },
      SetLevel = {
        args = "(int level)",
        description = "Set logging level.",
        returns = "()",
        type = "method"
      },
      SetTimeStamp = {
        args = "(bool enable)",
        description = "Set whether to timestamp log messages.",
        returns = "()",
        type = "method"
      },
      SetQuiet = {
        args = "(bool quiet)",
        description = "Set quiet mode ie. only print error entries to standard error stream (which is normally redirected to console also). Output to log file is not affected by this mode.",
        returns = "()",
        type = "method"
      },
      GetLevel = {
        args = "()",
        description = "Return logging level.",
        returns = "(int)",
        type = "method"
      },
      GetTimeStamp = {
        args = "()",
        description = "Return whether log messages are timestamped.",
        returns = "(bool)",
        type = "method"
      },
      GetLastMessage = {
        args = "()",
        description = "Return last log message.",
        returns = "(String)",
        type = "method"
      },
      IsQuiet = {
        args = "()",
        description = "Return whether log is in quiet mode (only errors printed to standard error stream).",
        returns = "(bool)",
        type = "method"
      },
      Write = {
        args = "(int level, const String message)",
        description = "Write to the log. If logging level is higher than the level of the message, the message is ignored.",
        returns = "()",
        type = "method"
      },
      WriteRaw = {
        args = "(const String message, bool error = false)",
        description = "Write raw output to the log.",
        returns = "()",
        type = "method"
      },
      level = {
        description = "int\nLogging level.",
        type = "value"
      },
      timeStamp = {
        description = "bool\nTimestamp log messages flag.",
        type = "value"
      },
      quiet = {
        description = "bool\nQuiet mode flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  LuaScriptInstance = {
    childs = {
      CreateObject = {
        args = "(const String scriptObjectType)",
        description = "(bool) CreateObject (LuaFile* scriptFile, const String scriptObjectType)\nCreate script object. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetScriptFile = {
        args = "(LuaFile* scriptFile)",
        description = "Set script file.",
        returns = "()",
        type = "method"
      },
      SetScriptObjectType = {
        args = "(const String scriptObjectType)",
        description = "Set script object type.",
        returns = "()",
        type = "method"
      },
      SubscribeToEvent = {
        args = "(const String eventName, void* functionOrFunctionName)",
        description = "() SubscribeToEvent (void* sender, const String eventName, void* functionOrFunctionName)",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromEvent = {
        args = "(const String eventName)",
        description = "() UnsubscribeFromEvent (Object* sender, const String eventName)",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromEvents = {
        args = "(Object* sender)",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromAllEvents = {
        args = "()",
        returns = "()",
        type = "method"
      },
      UnsubscribeFromAllEventsExcept = {
        args = "(const Vector<String>& exceptionNames)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      GetScriptFile = {
        args = "()",
        description = "Return script file.",
        returns = "(LuaFile*)",
        valuetype = "LuaFile",
        type = "method"
      },
      GetScriptObjectType = {
        args = "()",
        description = "Return script object type.",
        returns = "(const String)",
        type = "method"
      },
      scriptFile = {
        valuetype = "LuaFile",
        description = "const LuaFile*\nScript file.",
        type = "value"
      },
      scriptObjectType = {
        description = "const String\nScript object type.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Material = {
    childs = {
      new = {
        args = "()",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetNumTechniques = {
        args = "(unsigned num)",
        description = "Set number of techniques.",
        returns = "()",
        type = "method"
      },
      SetTechnique = {
        args = "(unsigned index, Technique* tech, unsigned qualityLevel = 0, float lodDistance = 0.0f)",
        description = "Set technique.",
        returns = "()",
        type = "method"
      },
      SetVertexShaderDefines = {
        args = "(const String defines)",
        description = "Set additional vertex shader defines. Separate multiple defines with spaces. Setting defines at the material level causes technique(s) to be cloned as necessary.",
        returns = "()",
        type = "method"
      },
      SetPixelShaderDefines = {
        args = "(const String defines)",
        description = "Set additional pixel shader defines. Separate multiple defines with spaces. Setting defines at the material level causes technique(s) to be cloned as necessary.",
        returns = "()",
        type = "method"
      },
      SetShaderParameter = {
        args = "(const String name, const Variant& value)",
        description = "Set shader parameter.",
        returns = "()",
        type = "method"
      },
      SetShaderParameterAnimation = {
        args = "(const String name, ValueAnimation* animation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetShaderParameterAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set shader parameter animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetShaderParameterAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set shader parameter animation speed.",
        returns = "()",
        type = "method"
      },
      SetTexture = {
        args = "(TextureUnit unit, Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetUVTransform = {
        args = "(const Vector2& offset, float rotation, const Vector2& repeat)",
        description = "() SetUVTransform (const Vector2& offset, float rotation, float repeat)\nSet texture coordinate transform.",
        returns = "()",
        type = "method"
      },
      SetCullMode = {
        args = "(CullMode mode)",
        description = "Set culling mode.",
        returns = "()",
        type = "method"
      },
      SetShadowCullMode = {
        args = "(CullMode mode)",
        description = "Set culling mode for shadows.",
        returns = "()",
        type = "method"
      },
      SetFillMode = {
        args = "(FillMode mode)",
        description = "Set polygon fill mode. Interacts with the camera's fill mode setting so that the \"least filled\" mode will be used.",
        returns = "()",
        type = "method"
      },
      SetDepthBias = {
        args = "(const BiasParameters& parameters)",
        description = "Set depth bias parameters for depth write and compare. Note that the normal offset parameter is not used and will not be saved, as it affects only shadow map sampling during light rendering.",
        returns = "()",
        type = "method"
      },
      SetAlphaToCoverage = {
        args = "(bool enable)",
        description = "Set alpha-to-coverage mode on all passes.",
        returns = "()",
        type = "method"
      },
      SetLineAntiAlias = {
        args = "(bool enable)",
        description = "Set line antialiasing on/off. Has effect only on models that consist of line lists.",
        returns = "()",
        type = "method"
      },
      SetRenderOrder = {
        args = "(char renderOrder)",
        returns = "()",
        type = "method"
      },
      SetOcclusion = {
        args = "(bool enable)",
        description = "Set whether to use in occlusion rendering. Default true.",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* scene)",
        description = "Associate the material with a scene to ensure that shader parameter animation happens in sync with scene update, respecting the scene time scale. If no scene is set, the global update events will be used.",
        returns = "()",
        type = "method"
      },
      RemoveShaderParameter = {
        args = "(const String name)",
        description = "Remove shader parameter.",
        returns = "()",
        type = "method"
      },
      ReleaseShaders = {
        args = "()",
        description = "Reset all shader pointers.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone the material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      SortTechniques = {
        args = "()",
        description = "Ensure that material techniques are listed in correct order.",
        returns = "()",
        type = "method"
      },
      MarkForAuxView = {
        args = "(unsigned frameNumber)",
        description = "Mark material for auxiliary view rendering.",
        returns = "()",
        type = "method"
      },
      GetNumTechniques = {
        args = "()",
        description = "Return number of techniques.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTechnique = {
        args = "(unsigned index)",
        description = "Return technique by index.",
        returns = "(Technique*)",
        valuetype = "Technique",
        type = "method"
      },
      GetPass = {
        args = "(unsigned index, const String passName)",
        description = "Return pass by technique index and pass name.",
        returns = "(Pass*)",
        valuetype = "Pass",
        type = "method"
      },
      GetTexture = {
        args = "(TextureUnit unit)",
        description = "Return texture by unit.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetVertexShaderDefines = {
        args = "()",
        description = "Return additional vertex shader defines.",
        returns = "(const String)",
        type = "method"
      },
      GetPixelShaderDefines = {
        args = "()",
        description = "Return additional pixel shader defines.",
        returns = "(const String)",
        type = "method"
      },
      GetShaderParameterAnimation = {
        args = "(const String name)",
        description = "Return shader parameter animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetShaderParameterAnimationWrapMode = {
        args = "(const String name)",
        description = "Return shader parameter animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetShaderParameterAnimationSpeed = {
        args = "(const String name)",
        description = "Return shader parameter animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetCullMode = {
        args = "()",
        description = "Return normal culling mode.",
        returns = "(CullMode)",
        type = "method"
      },
      GetShadowCullMode = {
        args = "()",
        description = "Return culling mode for shadows.",
        returns = "(CullMode)",
        type = "method"
      },
      GetFillMode = {
        args = "()",
        description = "Return polygon fill mode.",
        returns = "(FillMode)",
        type = "method"
      },
      GetDepthBias = {
        args = "()",
        description = "Return depth bias.",
        returns = "(const BiasParameters&)",
        valuetype = "BiasParameters",
        type = "method"
      },
      GetAlphaToCoverage = {
        args = "()",
        description = "Return alpha-to-coverage mode.",
        returns = "(bool)",
        type = "method"
      },
      GetLineAntiAlias = {
        args = "()",
        description = "Return whether line antialiasing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetRenderOrder = {
        args = "()",
        description = "Return render order.",
        returns = "(char)",
        type = "method"
      },
      GetOcclusion = {
        args = "()",
        description = "Return whether should render occlusion.",
        returns = "(bool)",
        type = "method"
      },
      GetSpecular = {
        args = "()",
        description = "Return whether should render specular.",
        returns = "(bool)",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene associated with the material for shader parameter animation updates.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      vertexShaderDefines = {
        description = "String\nVertex shader defines.",
        type = "value"
      },
      pixelShaderDefines = {
        description = "String\nPixel shader defines.",
        type = "value"
      },
      cullMode = {
        description = "CullMode\nNormal culling mode.",
        type = "value"
      },
      shadowCullMode = {
        description = "CullMode\nCulling mode for shadow rendering.",
        type = "value"
      },
      fillMode = {
        description = "FillMode\nPolygon fill mode.",
        type = "value"
      },
      depthBias = {
        description = "BiasParameters\nDepth bias parameters.",
        type = "value"
      },
      alphaToCoverage = {
        description = "bool\nAlpha-to-coverage flag.",
        type = "value"
      },
      lineAntiAlias = {
        description = "bool\nLine antialiasing flag.",
        type = "value"
      },
      renderOrder = {
        description = "char\nRender order value.",
        type = "value"
      },
      occlusion = {
        description = "bool\nRender occlusion flag.",
        type = "value"
      },
      specular = {
        description = "(Readonly) bool\nSpecular lighting flag.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*\nAssociated scene for shader parameter animation updates.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Matrix3 = {
    childs = {
      new = {
        args = "()",
        description = "(Matrix3*) new (const Matrix3& matrix),\n(Matrix3*) new (float v00, float v01, float v02, float v10, float v11, float v12, float v20, float v21, float v22)",
        returns = "(Matrix3*)",
        valuetype = "Matrix3",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector3& scale)",
        description = "() SetScale (float scale)",
        returns = "()",
        type = "method"
      },
      Scale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Transpose = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Scaled = {
        args = "(const Vector3& scale)",
        returns = "(Matrix3)",
        type = "method"
      },
      Equals = {
        args = "(const Matrix3& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      m00 = {
        description = "float",
        type = "value"
      },
      m01 = {
        description = "float",
        type = "value"
      },
      m02 = {
        description = "float",
        type = "value"
      },
      m10 = {
        description = "float",
        type = "value"
      },
      m11 = {
        description = "float",
        type = "value"
      },
      m12 = {
        description = "float",
        type = "value"
      },
      m20 = {
        description = "float",
        type = "value"
      },
      m21 = {
        description = "float",
        type = "value"
      },
      m22 = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Matrix3",
        type = "value"
      },
      IDENTITY = {
        description = "const Matrix3",
        type = "value"
      },
    },
    type = "class"
  },
  Matrix3x4 = {
    childs = {
      new = {
        args = "()",
        description = "(Matrix3x4*) new (const Matrix3x4& matrix),\n(Matrix3x4*) new (const Matrix3& matrix),\n(Matrix3x4*) new (const Matrix4& matrix),\n(Matrix3x4*) new (float v00, float v01, float v02, float v03, float v10, float v11, float v12, float v13, float v20, float v21, float v22, float v23),\n(Matrix3x4*) new (const Vector3& translation, const Quaternion& rotation, float scale),\n(Matrix3x4*) new (const Vector3& translation, const Quaternion& rotation, const Vector3& scale)",
        returns = "(Matrix3x4*)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTranslation = {
        args = "(const Vector3& translation)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Matrix3& rotation)",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector3& scale)",
        description = "() SetScale (float scale)",
        returns = "()",
        type = "method"
      },
      ToMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ToMatrix4 = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      RotationMatrix = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Translation = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Rotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      Scale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Equals = {
        args = "(const Matrix3x4& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Decompose = {
        args = "(Vector3& translation, Quaternion& rotation, Vector3& scale)",
        returns = "()",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      m00 = {
        description = "float",
        type = "value"
      },
      m01 = {
        description = "float",
        type = "value"
      },
      m02 = {
        description = "float",
        type = "value"
      },
      m03 = {
        description = "float",
        type = "value"
      },
      m10 = {
        description = "float",
        type = "value"
      },
      m11 = {
        description = "float",
        type = "value"
      },
      m12 = {
        description = "float",
        type = "value"
      },
      m13 = {
        description = "float",
        type = "value"
      },
      m20 = {
        description = "float",
        type = "value"
      },
      m21 = {
        description = "float",
        type = "value"
      },
      m22 = {
        description = "float",
        type = "value"
      },
      m23 = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Matrix3x4",
        type = "value"
      },
      IDENTITY = {
        description = "const Matrix3x4",
        type = "value"
      },
    },
    type = "class"
  },
  Matrix4 = {
    childs = {
      new = {
        args = "()",
        description = "(Matrix4*) new (const Matrix4& matrix),\n(Matrix4*) new (const Matrix3& matrix),\n(Matrix4*) new (float v00, float v01, float v02, float v03, float v10, float v11, float v12, float v13, float v20, float v21, float v22, float v23, float v30, float v31, float v32, float v33)",
        returns = "(Matrix4*)",
        valuetype = "Matrix4",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTranslation = {
        args = "(const Vector3& translation)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Matrix3& rotation)",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector3& scale)",
        description = "() SetScale (float scale)",
        returns = "()",
        type = "method"
      },
      ToMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      RotationMatrix = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Translation = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Rotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      Scale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Transpose = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      Equals = {
        args = "(const Matrix4& rhs)",
        returns = "(bool)",
        type = "method"
      },
      Decompose = {
        args = "(Vector3& translation, Quaternion& rotation, Vector3& scale)",
        returns = "()",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      m00 = {
        description = "float",
        type = "value"
      },
      m01 = {
        description = "float",
        type = "value"
      },
      m02 = {
        description = "float",
        type = "value"
      },
      m03 = {
        description = "float",
        type = "value"
      },
      m10 = {
        description = "float",
        type = "value"
      },
      m11 = {
        description = "float",
        type = "value"
      },
      m12 = {
        description = "float",
        type = "value"
      },
      m13 = {
        description = "float",
        type = "value"
      },
      m20 = {
        description = "float",
        type = "value"
      },
      m21 = {
        description = "float",
        type = "value"
      },
      m22 = {
        description = "float",
        type = "value"
      },
      m23 = {
        description = "float",
        type = "value"
      },
      m30 = {
        description = "float",
        type = "value"
      },
      m31 = {
        description = "float",
        type = "value"
      },
      m32 = {
        description = "float",
        type = "value"
      },
      m33 = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Matrix4",
        type = "value"
      },
      IDENTITY = {
        description = "const Matrix4",
        type = "value"
      },
    },
    type = "class"
  },
  Menu = {
    childs = {
      new = {
        args = "()",
        returns = "(Menu*)",
        valuetype = "Menu",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetPopup = {
        args = "(UIElement* element)",
        description = "Set popup element to show on selection.",
        returns = "()",
        type = "method"
      },
      SetPopupOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPopupOffset (int x, int y)\nSet popup element offset.",
        returns = "()",
        type = "method"
      },
      ShowPopup = {
        args = "(bool enable)",
        description = "Force the popup to show or hide.",
        returns = "()",
        type = "method"
      },
      SetAccelerator = {
        args = "(int key, int qualifiers)",
        description = "Set accelerator key (set zero key code to disable.)",
        returns = "()",
        type = "method"
      },
      GetPopup = {
        args = "()",
        description = "Return popup element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetPopupOffset = {
        args = "()",
        description = "Return popup element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetShowPopup = {
        args = "()",
        description = "Return whether popup is open.",
        returns = "(bool)",
        type = "method"
      },
      GetAcceleratorKey = {
        args = "()",
        description = "Return accelerator key code, 0 if disabled.",
        returns = "(int)",
        type = "method"
      },
      GetAcceleratorQualifiers = {
        args = "()",
        description = "Return accelerator qualifiers.",
        returns = "(int)",
        type = "method"
      },
      popup = {
        valuetype = "UIElement",
        description = "UIElement*\nPopup element.",
        type = "value"
      },
      popupOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPopup element offset.",
        type = "value"
      },
      showPopup = {
        description = "bool\nShow popup flag.",
        type = "value"
      },
      acceleratorKey = {
        description = "(Readonly) int\nAccelerator key code.",
        type = "value"
      },
      acceleratorQualifiers = {
        description = "(Readonly) int\nAccelerator qualifiers.",
        type = "value"
      },
      SetPressedOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedOffset (int x, int y)\nSet offset to image rectangle used when pressed.",
        returns = "()",
        type = "method"
      },
      SetPressedChildOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetPressedChildOffset (int x, int y)\nSet offset of child elements when pressed.",
        returns = "()",
        type = "method"
      },
      SetRepeat = {
        args = "(float delay, float rate)",
        description = "Set repeat properties. Rate 0 (default) disables repeat.",
        returns = "()",
        type = "method"
      },
      SetRepeatDelay = {
        args = "(float delay)",
        description = "Set repeat delay.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set repeat rate.",
        returns = "()",
        type = "method"
      },
      GetPressedOffset = {
        args = "()",
        description = "Return pressed image offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPressedChildOffset = {
        args = "()",
        description = "Return offset of child elements when pressed.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetRepeatDelay = {
        args = "()",
        description = "Return repeat delay.",
        returns = "(float)",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return repeat rate.",
        returns = "(float)",
        type = "method"
      },
      IsPressed = {
        args = "()",
        description = "Return whether is currently pressed.",
        returns = "(bool)",
        type = "method"
      },
      pressedOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed image offset.",
        type = "value"
      },
      pressedChildOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPressed label offset.",
        type = "value"
      },
      repeatDelay = {
        description = "float\nRepeat delay.",
        type = "value"
      },
      repeatRate = {
        description = "float\nRepeat rate.",
        type = "value"
      },
      pressed = {
        description = "(Readonly) bool\nCurrent pressed state.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  MessageBox = {
    childs = {
      new = {
        args = "(const String messageString = String::EMPTY, const String titleString = String::EMPTY, XMLFile* layoutFile = 0, XMLFile* styleFile = 0)",
        returns = "(MessageBox*)",
        valuetype = "MessageBox",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetTitle = {
        args = "(const String text)",
        description = "Set title text. No-ops if there is no title text element.",
        returns = "()",
        type = "method"
      },
      SetMessage = {
        args = "(const String text)",
        description = "Set message text. No-ops if there is no message text element.",
        returns = "()",
        type = "method"
      },
      GetTitle = {
        args = "()",
        description = "Return title text. Return empty string if there is no title text element.",
        returns = "(const String)",
        type = "method"
      },
      GetMessage = {
        args = "()",
        description = "Return message text. Return empty string if there is no message text element.",
        returns = "(const String)",
        type = "method"
      },
      GetWindow = {
        args = "()",
        description = "Return dialog window.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      title = {
        description = "String",
        type = "value"
      },
      message = {
        description = "String",
        type = "value"
      },
      window = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*\nUI element containing the whole UI layout. Typically it is a Window element type.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Model = {
    childs = {
      new = {
        args = "()",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone the model. The geometry data is deep-copied and can be modified in the clone without affecting the original.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      SetBoundingBox = {
        args = "(const BoundingBox& box)",
        description = "Set local-space bounding box.",
        returns = "()",
        type = "method"
      },
      SetVertexBuffers = {
        args = "(const Vector<SharedPtr<VertexBuffer> >& buffers, const PODVector<unsigned>& morphRangeStarts, const PODVector<unsigned>& morphRangeCounts)",
        returns = "(bool)",
        type = "method"
      },
      SetIndexBuffers = {
        args = "(const Vector<SharedPtr<IndexBuffer> >& buffers)",
        returns = "(bool)",
        type = "method"
      },
      SetNumGeometries = {
        args = "(unsigned num)",
        description = "Set number of geometries.",
        returns = "()",
        type = "method"
      },
      SetNumGeometryLodLevels = {
        args = "(unsigned index, unsigned num)",
        description = "Set number of LOD levels in a geometry.",
        returns = "(bool)",
        type = "method"
      },
      SetGeometry = {
        args = "(unsigned index, unsigned lodLevel, Geometry* geometry)",
        description = "Set geometry.",
        returns = "(bool)",
        type = "method"
      },
      SetGeometryCenter = {
        args = "(unsigned index, const Vector3& center)",
        description = "Set geometry center.",
        returns = "(bool)",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetSkeleton = {
        args = "()",
        description = "Return skeleton.",
        returns = "(Skeleton&)",
        valuetype = "Skeleton",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumGeometryLodLevels = {
        args = "(unsigned index)",
        description = "Return number of LOD levels in geometry.",
        returns = "(unsigned)",
        type = "method"
      },
      GetGeometry = {
        args = "(unsigned index, unsigned lodLevel)",
        description = "Return geometry by index and LOD level. The LOD level is clamped if out of range.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetGeometryCenter = {
        args = "(unsigned index)",
        description = "Return geometry center by index.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetNumMorphs = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetMorph = {
        args = "(const String name)",
        description = "(const ModelMorph*) GetMorph (StringHash nameHash),\n(const ModelMorph*) GetMorph (unsigned index)",
        returns = "(const ModelMorph*)",
        valuetype = "ModelMorph",
        type = "method"
      },
      GetMorphRangeStart = {
        args = "(unsigned bufferIndex)",
        returns = "(unsigned)",
        type = "method"
      },
      GetMorphRangeCount = {
        args = "(unsigned bufferIndex)",
        returns = "(unsigned)",
        type = "method"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "BoundingBox&",
        type = "value"
      },
      skeleton = {
        description = "(Readonly) Skeleton",
        type = "value"
      },
      numGeometries = {
        description = "unsigned",
        type = "value"
      },
      numMorphs = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  NamedPipe = {
    childs = {
      new = {
        args = "()",
        description = "(NamedPipe*) new (const String pipeName, bool isServer)",
        returns = "(NamedPipe*)",
        valuetype = "NamedPipe",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Open = {
        args = "(const String pipeName, bool isServer)",
        description = "Open the pipe in either server or client mode. If already open, the existing pipe is closed. For a client end to open successfully the server end must already to be open. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Close = {
        args = "()",
        description = "Close the pipe. Note that once a client has disconnected, the server needs to close and reopen the pipe so that another client can connect. At least on Windows this is not possible to detect automatically, so the communication protocol should include a \"bye\" message to handle this situation.",
        returns = "()",
        type = "method"
      },
      IsOpen = {
        args = "()",
        description = "Return whether is open.",
        returns = "(bool)",
        type = "method"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return the pipe name.",
        returns = "(const String)",
        type = "method"
      },
      IsEof = {
        args = "()",
        description = "Return whether pipe has no data available.",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      ReadDouble = {
        args = "()",
        returns = "(double)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadIntVector3 = {
        args = "()",
        returns = "(IntVector3)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ReadMatrix3x4 = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      ReadMatrix4 = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        returns = "(bool)",
        type = "method"
      },
      WriteDouble = {
        args = "(double value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector3 = {
        args = "(const IntVector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3 = {
        args = "(const Matrix3& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3x4 = {
        args = "(const Matrix3x4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix4 = {
        args = "(const Matrix4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
      open = {
        description = "(Readonly) bool",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  NavArea = {
    childs = {
      GetAreaID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      SetAreaID = {
        args = "(unsigned tolua_var_3)",
        description = "Set the area id for this volume.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Get the bounding box of this navigation area, in local space.",
        returns = "(BoundingBox)",
        type = "method"
      },
      SetBoundingBox = {
        args = "(const BoundingBox& bnds)",
        description = "Set the bounding box of this area, in local space.",
        returns = "()",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Get the bounds of this navigation area in world space.",
        returns = "(BoundingBox)",
        type = "method"
      },
      areaID = {
        description = "unsigned\nArea id to assign to the marked area.",
        type = "value"
      },
      boundingBox = {
        description = "BoundingBox\nBounds of area to mark.",
        type = "value"
      },
      worldBoundingBox = {
        description = "(Readonly) BoundingBox",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Navigable = {
    childs = {
      SetRecursive = {
        args = "(bool enable)",
        description = "Set whether geometry is automatically collected from child nodes. Default true.",
        returns = "()",
        type = "method"
      },
      IsRecursive = {
        args = "()",
        description = "Return whether geometry is automatically collected from child nodes.",
        returns = "(bool)",
        type = "method"
      },
      recursive = {
        description = "bool\nRecursive flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  NavigationGeometryInfo = {
    childs = {
      component = {
        valuetype = "Component",
        description = "Component*",
        type = "value"
      },
      lodLevel = {
        description = "unsigned",
        type = "value"
      },
      transform = {
        description = "Matrix3x4",
        type = "value"
      },
      boundingBox = {
        description = "BoundingBox",
        type = "value"
      },
    },
    type = "class"
  },
  NavigationMesh = {
    childs = {
      SetTileSize = {
        args = "(int size)",
        description = "Set tile size.",
        returns = "()",
        type = "method"
      },
      SetCellSize = {
        args = "(float size)",
        description = "Set cell size.",
        returns = "()",
        type = "method"
      },
      SetCellHeight = {
        args = "(float height)",
        description = "Set cell height.",
        returns = "()",
        type = "method"
      },
      SetAgentHeight = {
        args = "(float height)",
        description = "Set navigation agent height.",
        returns = "()",
        type = "method"
      },
      SetAgentRadius = {
        args = "(float radius)",
        description = "Set navigation agent radius.",
        returns = "()",
        type = "method"
      },
      SetAgentMaxClimb = {
        args = "(float maxClimb)",
        description = "Set navigation agent max vertical climb.",
        returns = "()",
        type = "method"
      },
      SetAgentMaxSlope = {
        args = "(float maxSlope)",
        description = "Set navigation agent max slope.",
        returns = "()",
        type = "method"
      },
      SetRegionMinSize = {
        args = "(float size)",
        description = "Set region minimum size.",
        returns = "()",
        type = "method"
      },
      SetRegionMergeSize = {
        args = "(float size)",
        description = "Set region merge size.",
        returns = "()",
        type = "method"
      },
      SetEdgeMaxLength = {
        args = "(float length)",
        description = "Set edge max length.",
        returns = "()",
        type = "method"
      },
      SetEdgeMaxError = {
        args = "(float error)",
        description = "Set edge max error.",
        returns = "()",
        type = "method"
      },
      SetDetailSampleDistance = {
        args = "(float distance)",
        description = "Set detail sampling distance.",
        returns = "()",
        type = "method"
      },
      SetDetailSampleMaxError = {
        args = "(float error)",
        description = "Set detail sampling maximum error.",
        returns = "()",
        type = "method"
      },
      SetPadding = {
        args = "(const Vector3& padding)",
        description = "Set padding of the navigation mesh bounding box. Having enough padding allows to add geometry on the extremities of the navigation mesh when doing partial rebuilds.",
        returns = "()",
        type = "method"
      },
      SetAreaCost = {
        args = "(unsigned areaID, float cost)",
        description = "Set the cost of an area.",
        returns = "()",
        type = "method"
      },
      Build = {
        args = "()",
        description = "(bool) Build (const BoundingBox& boundingBox)\nRebuild the navigation mesh. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetPartitionType = {
        args = "(NavmeshPartitionType aType)",
        description = "Set the partition type used for polygon generation.",
        returns = "()",
        type = "method"
      },
      SetDrawOffMeshConnections = {
        args = "(bool enable)",
        description = "Draw debug geometry for OffMeshConnection components.",
        returns = "()",
        type = "method"
      },
      SetDrawNavAreas = {
        args = "(bool enable)",
        description = "Draw debug geometry for NavArea components.",
        returns = "()",
        type = "method"
      },
      FindNearestPoint = {
        args = "(const Vector3& point)",
        description = "(Vector3) FindNearestPoint (const Vector3& point, const Vector3& extents)",
        returns = "(Vector3)",
        type = "method"
      },
      MoveAlongSurface = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(Vector3) MoveAlongSurface (const Vector3& start, const Vector3& end, const Vector3& extents, int maxVisited = 3)",
        returns = "(Vector3)",
        type = "method"
      },
      FindPath = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(const PODVector<Vector3>&) FindPath (const Vector3& start, const Vector3& end, const Vector3& extents)",
        returns = "(const PODVector<Vector3>&)",
        valuetype = "PODVector<Vector3>",
        type = "method"
      },
      GetRandomPoint = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetRandomPointInCircle = {
        args = "(const Vector3& center, float radius)",
        description = "(Vector3) GetRandomPointInCircle (const Vector3& center, float radius, const Vector3& extents)",
        returns = "(Vector3)",
        type = "method"
      },
      GetDistanceToWall = {
        args = "(const Vector3& point, float radius)",
        description = "(float) GetDistanceToWall (const Vector3& point, float radius, const Vector3& extents)",
        returns = "(float)",
        type = "method"
      },
      Raycast = {
        args = "(const Vector3& start, const Vector3& end)",
        description = "(Vector3) Raycast (const Vector3& start, const Vector3& end, const Vector3& extents)",
        returns = "(Vector3)",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      GetTileSize = {
        args = "()",
        description = "Return tile size.",
        returns = "(int)",
        type = "method"
      },
      GetCellSize = {
        args = "()",
        description = "Return cell size.",
        returns = "(float)",
        type = "method"
      },
      GetCellHeight = {
        args = "()",
        description = "Return cell height.",
        returns = "(float)",
        type = "method"
      },
      GetAgentHeight = {
        args = "()",
        description = "Return navigation agent height.",
        returns = "(float)",
        type = "method"
      },
      GetAgentRadius = {
        args = "()",
        description = "Return navigation agent radius.",
        returns = "(float)",
        type = "method"
      },
      GetAgentMaxClimb = {
        args = "()",
        description = "Return navigation agent max vertical climb.",
        returns = "(float)",
        type = "method"
      },
      GetAgentMaxSlope = {
        args = "()",
        description = "Return navigation agent max slope.",
        returns = "(float)",
        type = "method"
      },
      GetRegionMinSize = {
        args = "()",
        description = "Return region minimum size.",
        returns = "(float)",
        type = "method"
      },
      GetRegionMergeSize = {
        args = "()",
        description = "Return region merge size.",
        returns = "(float)",
        type = "method"
      },
      GetEdgeMaxLength = {
        args = "()",
        description = "Return edge max length.",
        returns = "(float)",
        type = "method"
      },
      GetEdgeMaxError = {
        args = "()",
        description = "Return edge max error.",
        returns = "(float)",
        type = "method"
      },
      GetDetailSampleDistance = {
        args = "()",
        description = "Return detail sampling distance.",
        returns = "(float)",
        type = "method"
      },
      GetDetailSampleMaxError = {
        args = "()",
        description = "Return detail sampling maximum error.",
        returns = "(float)",
        type = "method"
      },
      GetPadding = {
        args = "()",
        description = "Return navigation mesh bounding box padding.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetAreaCost = {
        args = "(unsigned areaID)",
        description = "Get the current cost of an area",
        returns = "(float)",
        type = "method"
      },
      IsInitialized = {
        args = "()",
        description = "Return whether has been initialized with valid navigation data.",
        returns = "(bool)",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box of the navigation mesh.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world space bounding box of the navigation mesh.",
        returns = "(BoundingBox)",
        type = "method"
      },
      GetNumTiles = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      GetPartitionType = {
        args = "()",
        description = "Return Partition Type.",
        returns = "(NavmeshPartitionType)",
        type = "method"
      },
      GetDrawOffMeshConnections = {
        args = "()",
        description = "Return whether to draw OffMeshConnection components.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawNavAreas = {
        args = "()",
        description = "Return whether to draw NavArea components.",
        returns = "(bool)",
        type = "method"
      },
      tileSize = {
        description = "int\nTile size.",
        type = "value"
      },
      cellSize = {
        description = "float\nCell size.",
        type = "value"
      },
      cellHeight = {
        description = "float\nCell height.",
        type = "value"
      },
      agentHeight = {
        description = "float\nNavigation agent height.",
        type = "value"
      },
      agentRadius = {
        description = "float\nNavigation agent radius.",
        type = "value"
      },
      agentMaxClimb = {
        description = "float\nNavigation agent max vertical climb.",
        type = "value"
      },
      agentMaxSlope = {
        description = "float\nNavigation agent max slope.",
        type = "value"
      },
      regionMinSize = {
        description = "float\nRegion minimum size.",
        type = "value"
      },
      regionMergeSize = {
        description = "float\nRegion merge size.",
        type = "value"
      },
      edgeMaxLength = {
        description = "float\nEdge max length.",
        type = "value"
      },
      edgeMaxError = {
        description = "float\nEdge max error.",
        type = "value"
      },
      detailSampleDistance = {
        description = "float\nDetail sampling distance.",
        type = "value"
      },
      detailSampleMaxError = {
        description = "float\nDetail sampling maximum error.",
        type = "value"
      },
      padding = {
        valuetype = "Vector3",
        description = "Vector3&\nBounding box padding.",
        type = "value"
      },
      partitionType = {
        description = "NavmeshPartitionType\nType of the heightfield partitioning.",
        type = "value"
      },
      drawOffMeshConnections = {
        description = "bool\nDebug draw OffMeshConnection components.",
        type = "value"
      },
      drawNavAreas = {
        description = "bool\nDebug draw NavArea components.",
        type = "value"
      },
      initialized = {
        description = "(Readonly) bool",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&\nWhole navigation mesh bounding box.",
        type = "value"
      },
      worldBoundingBox = {
        description = "(Readonly) BoundingBox",
        type = "value"
      },
      numTiles = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Network = {
    childs = {
      Connect = {
        args = "(const String address, short port, Scene* scene)",
        description = "(bool) Connect (const String address, short port, Scene* scene, const VariantMap& identity)",
        returns = "(bool)",
        type = "method"
      },
      Disconnect = {
        args = "(int waitMSec = 0)",
        description = "Disconnect the connection to the server. If wait time is non-zero, will block while waiting for disconnect to finish.",
        returns = "()",
        type = "method"
      },
      StartServer = {
        args = "(short port)",
        returns = "(bool)",
        type = "method"
      },
      StopServer = {
        args = "()",
        description = "Stop the server.",
        returns = "()",
        type = "method"
      },
      BroadcastMessage = {
        args = "(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0)",
        description = "Broadcast a message with content ID to all client connections.",
        returns = "()",
        type = "method"
      },
      BroadcastRemoteEvent = {
        args = "(StringHash eventType, bool inOrder)",
        description = "() BroadcastRemoteEvent (StringHash eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (const String eventType, bool inOrder),\n() BroadcastRemoteEvent (const String eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Scene* scene, StringHash eventType, bool inOrder),\n() BroadcastRemoteEvent (Scene* scene, StringHash eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Scene* scene, const String eventType, bool inOrder),\n() BroadcastRemoteEvent (Scene* scene, const String eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Node* node, StringHash eventType, bool inOrder),\n() BroadcastRemoteEvent (Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData),\n() BroadcastRemoteEvent (Node* node, const String eventType, bool inOrder),\n() BroadcastRemoteEvent (Node* node, const String eventType, bool inOrder, const VariantMap& eventData)\nBroadcast a remote event to all client connections.",
        returns = "()",
        type = "method"
      },
      SetUpdateFps = {
        args = "(int fps)",
        description = "Set network update FPS.",
        returns = "()",
        type = "method"
      },
      SetSimulatedLatency = {
        args = "(int ms)",
        description = "Set simulated latency in milliseconds. This adds a fixed delay before sending each packet.",
        returns = "()",
        type = "method"
      },
      SetSimulatedPacketLoss = {
        args = "(float loss)",
        description = "Set simulated packet loss probability between 0.0 - 1.0.",
        returns = "()",
        type = "method"
      },
      RegisterRemoteEvent = {
        args = "(StringHash eventType)",
        description = "() RegisterRemoteEvent (const String eventType)\nRegister a remote event as allowed to be received. There is also a fixed blacklist of events that can not be allowed in any case, such as ConsoleCommand.",
        returns = "()",
        type = "method"
      },
      UnregisterRemoteEvent = {
        args = "(StringHash eventType)",
        description = "() UnregisterRemoteEvent (const String eventType)\nUnregister a remote event as allowed to received.",
        returns = "()",
        type = "method"
      },
      UnregisterAllRemoteEvents = {
        args = "()",
        description = "Unregister all remote events.",
        returns = "()",
        type = "method"
      },
      SetPackageCacheDir = {
        args = "(const String path)",
        description = "Set the package download cache directory.",
        returns = "()",
        type = "method"
      },
      SendPackageToClients = {
        args = "(Scene* scene, PackageFile* package)",
        description = "Trigger all client connections in the specified scene to download a package file from the server. Can be used to download additional resource packages when clients are already joined in the scene. The package must have been added as a requirement to the scene, or else the eventual download will fail.",
        returns = "()",
        type = "method"
      },
      MakeHttpRequest = {
        args = "(const String url, const String verb = String::EMPTY)",
        description = "(HttpRequest*) MakeHttpRequest (const String url, const String verb, const Vector<String>& headers, const String postData = String::EMPTY)",
        returns = "(HttpRequest*)",
        valuetype = "HttpRequest",
        type = "method"
      },
      GetUpdateFps = {
        args = "()",
        description = "Return network update FPS.",
        returns = "(int)",
        type = "method"
      },
      GetSimulatedLatency = {
        args = "()",
        description = "Return simulated latency in milliseconds.",
        returns = "(int)",
        type = "method"
      },
      GetSimulatedPacketLoss = {
        args = "()",
        description = "Return simulated packet loss probability.",
        returns = "(float)",
        type = "method"
      },
      GetServerConnection = {
        args = "()",
        description = "Return the connection to the server. Null if not connected.",
        returns = "(Connection*)",
        valuetype = "Connection",
        type = "method"
      },
      IsServerRunning = {
        args = "()",
        description = "Return whether the server is running.",
        returns = "(bool)",
        type = "method"
      },
      CheckRemoteEvent = {
        args = "(StringHash eventType)",
        description = "Return whether a remote event is allowed to be received.",
        returns = "(bool)",
        type = "method"
      },
      GetPackageCacheDir = {
        args = "()",
        description = "Return the package download cache directory.",
        returns = "(const String)",
        type = "method"
      },
      updateFps = {
        description = "int\nUpdate FPS.",
        type = "value"
      },
      simulatedLatency = {
        description = "int\nSimulated latency (send delay) in milliseconds.",
        type = "value"
      },
      simulatedPacketLoss = {
        description = "float\nSimulated packet loss probability between 0.0 - 1.0.",
        type = "value"
      },
      serverConnection = {
        valuetype = "Connection",
        description = "(Readonly) Connection*\nClient's server connection.",
        type = "value"
      },
      serverRunning = {
        description = "(Readonly) bool",
        type = "value"
      },
      packageCacheDir = {
        description = "String\nPackage cache directory.",
        type = "value"
      },
    },
    type = "class"
  },
  NetworkPriority = {
    childs = {
      SetBasePriority = {
        args = "(float priority)",
        description = "Set base priority. Default 100 (send updates at full frequency.)",
        returns = "()",
        type = "method"
      },
      SetDistanceFactor = {
        args = "(float factor)",
        description = "Set priority reduction distance factor. Default 0 (no effect.)",
        returns = "()",
        type = "method"
      },
      SetMinPriority = {
        args = "(float priority)",
        description = "Set minimum priority. Default 0 (no updates when far away enough.)",
        returns = "()",
        type = "method"
      },
      SetAlwaysUpdateOwner = {
        args = "(bool enable)",
        description = "Set whether updates to owner should be sent always at full rate. Default true.",
        returns = "()",
        type = "method"
      },
      GetBasePriority = {
        args = "()",
        description = "Return base priority.",
        returns = "(float)",
        type = "method"
      },
      GetDistanceFactor = {
        args = "()",
        description = "Return priority reduction distance factor.",
        returns = "(float)",
        type = "method"
      },
      GetMinPriority = {
        args = "()",
        description = "Return minimum priority.",
        returns = "(float)",
        type = "method"
      },
      GetAlwaysUpdateOwner = {
        args = "()",
        description = "Return whether updates to owner should be sent always at full rate.",
        returns = "(bool)",
        type = "method"
      },
      CheckUpdate = {
        args = "(float distance, float accumulator)",
        description = "Increment and check priority accumulator. Return true if should update. Called by Connection.",
        returns = "(bool)",
        type = "method"
      },
      basePriority = {
        description = "float\nBase priority.",
        type = "value"
      },
      distanceFactor = {
        description = "float\nPriority reduction distance factor.",
        type = "value"
      },
      minPriority = {
        description = "float\nMinimum priority.",
        type = "value"
      },
      alwaysUpdateOwner = {
        description = "bool\nUpdate owner at full rate flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Node = {
    childs = {
      new = {
        args = "()",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SaveXML = {
        args = "(File* dest, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      SaveJSON = {
        args = "(File* dest, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name of the scene node. Names are not required to be unique.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set position in parent space. If the scene node is on the root level (is child of the scene itself), this is same as world space.",
        returns = "()",
        type = "method"
      },
      SetPosition2D = {
        args = "(const Vector2& position)",
        description = "() SetPosition2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rotation in parent space.",
        returns = "()",
        type = "method"
      },
      SetRotation2D = {
        args = "(float rotation)",
        returns = "()",
        type = "method"
      },
      SetDirection = {
        args = "(const Vector3& direction)",
        description = "Set forward direction in parent space. Positive Z axis equals identity rotation.",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(float scale)",
        description = "() SetScale (const Vector3& scale)\nSet uniform scale in parent space.",
        returns = "()",
        type = "method"
      },
      SetScale2D = {
        args = "(const Vector2& scale)",
        description = "() SetScale2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale),\n() SetTransform (const Vector3& position, const Quaternion& rotation, float scale),\n() SetTransform (const Matrix3x4& transform)\nSet both position and rotation in parent space as an atomic operation. This is faster than setting position and rotation separately.",
        returns = "()",
        type = "method"
      },
      SetTransform2D = {
        args = "(const Vector2& position, float rotation)",
        description = "() SetTransform2D (const Vector2& position, float rotation, const Vector2& scale),\n() SetTransform2D (const Vector2& position, float rotation, float scale)",
        returns = "()",
        type = "method"
      },
      SetWorldPosition = {
        args = "(const Vector3& position)",
        returns = "()",
        type = "method"
      },
      SetWorldPosition2D = {
        args = "(const Vector2& position)",
        description = "() SetWorldPosition2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetWorldRotation = {
        args = "(const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetWorldRotation2D = {
        args = "(float rotation)",
        returns = "()",
        type = "method"
      },
      SetWorldDirection = {
        args = "(const Vector3& direction)",
        returns = "()",
        type = "method"
      },
      SetWorldScale = {
        args = "(float scale)",
        description = "() SetWorldScale (const Vector3& scale)",
        returns = "()",
        type = "method"
      },
      SetWorldScale2D = {
        args = "(const Vector2& scale)",
        description = "() SetWorldScale2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetWorldTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetWorldTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale),\n() SetWorldTransform (const Vector3& position, const Quaternion& rotation, float scale)",
        returns = "()",
        type = "method"
      },
      SetWorldTransform2D = {
        args = "(const Vector2& position, float rotation)",
        description = "() SetWorldTransform2D (const Vector2& position, float rotation, const Vector2& scale),\n() SetWorldTransform2D (const Vector2& position, float rotation, float scale)",
        returns = "()",
        type = "method"
      },
      Translate = {
        args = "(const Vector3& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Translate2D = {
        args = "(const Vector2& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Rotate = {
        args = "(const Quaternion& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Rotate2D = {
        args = "(float delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      RotateAround = {
        args = "(const Vector3& point, const Quaternion& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      RotateAround2D = {
        args = "(const Vector2& point, float delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Pitch = {
        args = "(float angle, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Yaw = {
        args = "(float angle, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Roll = {
        args = "(float angle, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      LookAt = {
        args = "(const Vector3& target)",
        description = "(bool) LookAt (const Vector3& target, const Vector3& upAxis, TransformSpace space = TS_WORLD)",
        returns = "(bool)",
        type = "method"
      },
      Scale = {
        args = "(float scale)",
        description = "() Scale (const Vector3& scale)",
        returns = "()",
        type = "method"
      },
      Scale2D = {
        args = "(const Vector2& scale)",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetOwner = {
        args = "(Connection* owner)",
        returns = "()",
        type = "method"
      },
      MarkDirty = {
        args = "()",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0, bool temporary = false)",
        description = "(Node*) CreateChild (unsigned id, CreateMode mode, bool temporary = false)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      CreateTemporaryChild = {
        args = "(const String name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      AddChild = {
        args = "(Node* node, unsigned index = M_MAX_UNSIGNED)",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(Node* node)",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        returns = "()",
        type = "method"
      },
      RemoveChildren = {
        args = "(bool removeReplicated, bool removeLocal, bool recursive)",
        returns = "()",
        type = "method"
      },
      RemoveComponent = {
        args = "(Component* component)",
        description = "() RemoveComponent (StringHash type),\n() RemoveComponent (const String type)",
        returns = "()",
        type = "method"
      },
      RemoveComponents = {
        args = "(bool removeReplicated, bool removeLocal)",
        description = "() RemoveComponents (const String type)",
        returns = "()",
        type = "method"
      },
      RemoveAllComponents = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ReorderComponent = {
        args = "(Component* component, unsigned index)",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(CreateMode mode = REPLICATED)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      Remove = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetParent = {
        args = "(Node* parent)",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        returns = "()",
        type = "method"
      },
      AddListener = {
        args = "(Component* component)",
        returns = "()",
        type = "method"
      },
      RemoveListener = {
        args = "(Component* component)",
        returns = "()",
        type = "method"
      },
      CreateComponent = {
        args = "(const String type, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      GetOrCreateComponent = {
        args = "(const String type, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      CloneComponent = {
        args = "(Component* component, unsigned id = 0)",
        description = "(Component*) CloneComponent (Component* component, CreateMode mode, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      CreateScriptObject = {
        args = "(const String scriptObjectType)",
        description = "(int) CreateScriptObject (const String fileName, const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetScriptObject = {
        args = "()",
        description = "(int) GetScriptObject (const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      GetParent = {
        args = "()",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsChildOf = {
        args = "(Node* node)",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetOwner = {
        args = "()",
        returns = "(Connection*)",
        valuetype = "Connection",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetPosition2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetRotation = {
        args = "()",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetRotation2D = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetDirection = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetUp = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetRight = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetScale = {
        args = "()",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetScale2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetTransform = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      GetWorldPosition = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldPosition2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetWorldRotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      GetWorldRotation2D = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetWorldDirection = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldUp = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldRight = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldScale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldScale2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetWorldTransform = {
        args = "()",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      LocalToWorld = {
        args = "(const Vector3& position)",
        description = "(Vector3) LocalToWorld (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      LocalToWorld2D = {
        args = "(const Vector2& vector)",
        returns = "(Vector2)",
        type = "method"
      },
      WorldToLocal = {
        args = "(const Vector3& position)",
        description = "(Vector3) WorldToLocal (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      WorldToLocal2D = {
        args = "(const Vector2& vector)",
        returns = "(Vector2)",
        type = "method"
      },
      IsDirty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(Node*) GetChild (StringHash nameHash, bool recursive = false),\n(Node*) GetChild (unsigned index)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetNumComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumNetworkComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      HasComponent = {
        args = "(StringHash type)",
        description = "(bool) HasComponent (const String type)",
        returns = "(bool)",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetComponent = {
        args = "(const String type, bool recursive = false)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      GetParentComponent = {
        args = "(const String type, bool recursive = false)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      GetComponents = {
        args = "(const String type, bool recursive = false)",
        returns = "(const PODVector<Component*>&)",
        valuetype = "PODVector<Component*>",
        type = "method"
      },
      GetChildren = {
        args = "(bool recursive = false)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      GetChildrenWithComponent = {
        args = "(const String type, bool recursive = false)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      LoadXML = {
        args = "(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      LoadJSON = {
        args = "(const JSONValue& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      AddComponent = {
        args = "(Component* component, unsigned id, CreateMode mode)",
        returns = "()",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      SetID = {
        args = "(unsigned id)",
        returns = "()",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      name = {
        description = "String",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      parent = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      owner = {
        valuetype = "Connection",
        description = "Connection*",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      position2D = {
        description = "Vector2",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&",
        type = "value"
      },
      rotation2D = {
        description = "float",
        type = "value"
      },
      direction = {
        description = "Vector3",
        type = "value"
      },
      up = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      right = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      scale = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      scale2D = {
        description = "Vector2",
        type = "value"
      },
      transform = {
        description = "(Readonly) Matrix3x4",
        type = "value"
      },
      worldPosition = {
        description = "Vector3",
        type = "value"
      },
      worldPosition2D = {
        description = "Vector2",
        type = "value"
      },
      worldRotation = {
        description = "Quaternion",
        type = "value"
      },
      worldRotation2D = {
        description = "float",
        type = "value"
      },
      worldDirection = {
        description = "Vector3",
        type = "value"
      },
      worldUp = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldRight = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldScale = {
        description = "Vector3",
        type = "value"
      },
      worldScale2D = {
        description = "Vector2",
        type = "value"
      },
      worldTransform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&",
        type = "value"
      },
      dirty = {
        description = "(Readonly) bool",
        type = "value"
      },
      numComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numNetworkComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Object = {
    childs = {
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ObjectAnimation = {
    childs = {
      new = {
        args = "()",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      AddAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "() RemoveAttributeAnimation (ValueAnimation* attributeAnimation)\nRemove attribute animation, attribute name can in following format: \"attribute\" or \"#0/#1/attribute\" or \"\"#0/#1/@component#1/attribute.",
        returns = "()",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation by name.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode by name.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed by name.",
        returns = "(float)",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Obstacle = {
    childs = {
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Simplified rendering of debug information for script usage.",
        returns = "()",
        type = "method"
      },
      SetRadius = {
        args = "(float radius)",
        description = "Set the blocking radius of this obstacle.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(float height)",
        description = "Set the height of this obstacle.",
        returns = "()",
        type = "method"
      },
      GetRadius = {
        args = "()",
        description = "Get the blocking radius of this obstacle.",
        returns = "(float)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Get the height of this obstacle.",
        returns = "(float)",
        type = "method"
      },
      radius = {
        description = "float\nRadius of this obstacle.",
        type = "value"
      },
      height = {
        description = "float\nHeight of this obstacle, extends 1/2 height below and 1/2 height above the owning node's position.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Octree = {
    childs = {
      SetSize = {
        args = "(const BoundingBox& box, unsigned numLevels)",
        description = "Set size and maximum subdivision levels. If octree is not empty, drawable objects will be temporarily moved to the root.",
        returns = "()",
        type = "method"
      },
      Update = {
        args = "(const FrameInfo& frame)",
        description = "Update and reinsert drawable objects.",
        returns = "()",
        type = "method"
      },
      AddManualDrawable = {
        args = "(Drawable* drawable)",
        description = "Add a drawable manually.",
        returns = "()",
        type = "method"
      },
      RemoveManualDrawable = {
        args = "(Drawable* drawable)",
        description = "Remove a manually added drawable.",
        returns = "()",
        type = "method"
      },
      GetDrawables = {
        args = "(const Vector3& point, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK)",
        description = "(const PODVector<OctreeQueryResult>&) GetDrawables (const BoundingBox& box, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK),\n(const PODVector<OctreeQueryResult>&) GetDrawables (const Frustum& frustum, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK),\n(const PODVector<OctreeQueryResult>&) GetDrawables (const Sphere& sphere, char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK)",
        returns = "(const PODVector<OctreeQueryResult>&)",
        valuetype = "PODVector<OctreeQueryResult>",
        type = "method"
      },
      GetAllDrawables = {
        args = "(char drawableFlags = DRAWABLE_ANY, unsigned viewMask = DEFAULT_VIEWMASK)",
        returns = "(const PODVector<OctreeQueryResult>&)",
        valuetype = "PODVector<OctreeQueryResult>",
        type = "method"
      },
      Raycast = {
        args = "(const Ray& ray, RayQueryLevel level, float maxDistance, char drawableFlags, unsigned viewMask = DEFAULT_VIEWMASK)",
        returns = "(const PODVector<RayQueryResult>&)",
        valuetype = "PODVector<RayQueryResult>",
        type = "method"
      },
      RaycastSingle = {
        args = "(const Ray& ray, RayQueryLevel level, float maxDistance, char drawableFlags, unsigned viewMask = DEFAULT_VIEWMASK)",
        returns = "(RayQueryResult)",
        type = "method"
      },
      GetNumLevels = {
        args = "()",
        description = "Return subdivision levels.",
        returns = "(unsigned)",
        type = "method"
      },
      QueueUpdate = {
        args = "(Drawable* drawable)",
        description = "Mark drawable object as requiring an update and a reinsertion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      numLevels = {
        description = "(Readonly) unsigned\nSubdivision level.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  OctreeQueryResult = {
    childs = {
      new = {
        args = "()",
        returns = "(OctreeQueryResult*)",
        valuetype = "OctreeQueryResult",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      drawable = {
        valuetype = "Drawable",
        description = "Drawable*",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
    },
    type = "class"
  },
  OffMeshConnection = {
    childs = {
      SetEndPoint = {
        args = "(Node* node)",
        description = "Set endpoint node.",
        returns = "()",
        type = "method"
      },
      SetRadius = {
        args = "(float radius)",
        description = "Set radius.",
        returns = "()",
        type = "method"
      },
      SetBidirectional = {
        args = "(bool enabled)",
        description = "Set bidirectional flag. Default true.",
        returns = "()",
        type = "method"
      },
      SetMask = {
        args = "(unsigned newMask)",
        description = "Set a user assigned mask",
        returns = "()",
        type = "method"
      },
      SetAreaID = {
        args = "(unsigned newAreaID)",
        description = "Sets the assigned area Id for the connection",
        returns = "()",
        type = "method"
      },
      GetEndPoint = {
        args = "()",
        description = "Return endpoint node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetRadius = {
        args = "()",
        description = "Return radius.",
        returns = "(float)",
        type = "method"
      },
      IsBidirectional = {
        args = "()",
        description = "Return whether is bidirectional.",
        returns = "(bool)",
        type = "method"
      },
      GetMask = {
        args = "()",
        description = "Return the user assigned mask",
        returns = "(unsigned)",
        type = "method"
      },
      GetAreaID = {
        args = "()",
        description = "Return the user assigned area ID",
        returns = "(unsigned)",
        type = "method"
      },
      endPoint = {
        valuetype = "Node",
        description = "Node*\nEndpoint node.",
        type = "value"
      },
      radius = {
        description = "float\nRadius.",
        type = "value"
      },
      bidirectional = {
        description = "bool\nBidirectional flag.",
        type = "value"
      },
      mask = {
        description = "unsigned\nFlags mask to represent properties of this mesh",
        type = "value"
      },
      areaID = {
        description = "unsigned",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  PackageEntry = {
    childs = {
      offset = {
        description = "unsigned",
        type = "value"
      },
      size = {
        description = "unsigned",
        type = "value"
      },
      checksum = {
        description = "unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  PackageFile = {
    childs = {
      new = {
        args = "()",
        description = "(PackageFile*) new (const String fileName, unsigned startOffset = 0)",
        returns = "(PackageFile*)",
        valuetype = "PackageFile",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Open = {
        args = "(const String fileName, unsigned startOffset = 0)",
        description = "Open the package file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Exists = {
        args = "(const String fileName)",
        description = "Check if a file exists within the package file. This will be case-insensitive on Windows and case-sensitive on other platforms.",
        returns = "(bool)",
        type = "method"
      },
      GetEntry = {
        args = "(const String fileName)",
        description = "Return the file entry corresponding to the name, or null if not found. This will be case-insensitive on Windows and case-sensitive on other platforms.",
        returns = "(const PackageEntry*)",
        valuetype = "PackageEntry",
        type = "method"
      },
      GetEntries = {
        args = "()",
        description = "Return all file entries.",
        returns = "(const HashMap<String,PackageEntry>&)",
        valuetype = "HashMap<String,PackageEntry>",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return the package file name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return hash of the package file name.",
        returns = "(StringHash)",
        type = "method"
      },
      GetNumFiles = {
        args = "()",
        description = "Return number of files.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTotalSize = {
        args = "()",
        description = "Return total size of the package file.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTotalDataSize = {
        args = "()",
        description = "Return total data size from all the file entries in the package file.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return checksum of the package file contents.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the files are compressed.",
        returns = "(bool)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nPackage file name hash.",
        type = "value"
      },
      numFiles = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      totalSize = {
        description = "(Readonly) unsigned\nPackage file total size.",
        type = "value"
      },
      totalDataSize = {
        description = "(Readonly) unsigned\nTotal data size in the package using each entry's actual size if it is a compressed package file.",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned\nPackage file checksum.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool\nCompressed flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleEffect = {
    childs = {
      new = {
        args = "()",
        returns = "(ParticleEffect*)",
        valuetype = "ParticleEffect",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetNumParticles = {
        args = "(unsigned num)",
        description = "Set maximum number of particles.",
        returns = "()",
        type = "method"
      },
      SetUpdateInvisible = {
        args = "(bool enable)",
        description = "Set whether to update when particles are not visible.",
        returns = "()",
        type = "method"
      },
      SetRelative = {
        args = "(bool enable)",
        description = "Set whether billboards are relative to the scene node.",
        returns = "()",
        type = "method"
      },
      SetScaled = {
        args = "(bool enable)",
        description = "Set whether scene node scale affects billboards' size.",
        returns = "()",
        type = "method"
      },
      SetSorted = {
        args = "(bool enable)",
        description = "Set whether billboards are sorted by distance.",
        returns = "()",
        type = "method"
      },
      SetFixedScreenSize = {
        args = "(bool enable)",
        description = "Set whether billboards have fixed size on screen (measured in pixels) regardless of distance to camera.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float lodBias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      SetEmitterType = {
        args = "(EmitterType type)",
        description = "Set emitter type.",
        returns = "()",
        type = "method"
      },
      SetEmitterSize = {
        args = "(const Vector3& size)",
        description = "Set emitter size.",
        returns = "()",
        type = "method"
      },
      SetMinDirection = {
        args = "(const Vector3& direction)",
        description = "Set negative direction limit.",
        returns = "()",
        type = "method"
      },
      SetMaxDirection = {
        args = "(const Vector3& direction)",
        description = "Set positive direction limit.",
        returns = "()",
        type = "method"
      },
      SetConstantForce = {
        args = "(const Vector3& force)",
        description = "Set constant force acting on particles.",
        returns = "()",
        type = "method"
      },
      SetDampingForce = {
        args = "(float force)",
        description = "Set particle velocity damping force.",
        returns = "()",
        type = "method"
      },
      SetActiveTime = {
        args = "(float time)",
        description = "Set emission active period length (0 = infinite.)",
        returns = "()",
        type = "method"
      },
      SetInactiveTime = {
        args = "(float time)",
        description = "Set emission inactive period length (0 = infinite.)",
        returns = "()",
        type = "method"
      },
      SetMinEmissionRate = {
        args = "(float rate)",
        description = "Set minimum emission rate.",
        returns = "()",
        type = "method"
      },
      SetMaxEmissionRate = {
        args = "(float rate)",
        description = "Set maximum emission rate.",
        returns = "()",
        type = "method"
      },
      SetMinParticleSize = {
        args = "(const Vector2& size)",
        description = "Set particle minimum size.",
        returns = "()",
        type = "method"
      },
      SetMaxParticleSize = {
        args = "(const Vector2& size)",
        description = "Set particle maximum size.",
        returns = "()",
        type = "method"
      },
      SetMinTimeToLive = {
        args = "(float time)",
        description = "Set particle minimum time to live.",
        returns = "()",
        type = "method"
      },
      SetMaxTimeToLive = {
        args = "(float time)",
        description = "Set particle maximum time to live.",
        returns = "()",
        type = "method"
      },
      SetMinVelocity = {
        args = "(float velocity)",
        description = "Set particle minimum velocity.",
        returns = "()",
        type = "method"
      },
      SetMaxVelocity = {
        args = "(float velocity)",
        description = "Set particle maximum velocity.",
        returns = "()",
        type = "method"
      },
      SetMinRotation = {
        args = "(float rotation)",
        description = "Set particle minimum rotation.",
        returns = "()",
        type = "method"
      },
      SetMaxRotation = {
        args = "(float rotation)",
        description = "Set particle maximum rotation.",
        returns = "()",
        type = "method"
      },
      SetMinRotationSpeed = {
        args = "(float speed)",
        description = "Set particle minimum rotation speed.",
        returns = "()",
        type = "method"
      },
      SetMaxRotationSpeed = {
        args = "(float speed)",
        description = "Set particle maximum rotation speed.",
        returns = "()",
        type = "method"
      },
      SetSizeAdd = {
        args = "(float sizeAdd)",
        description = "Set particle size additive modifier.",
        returns = "()",
        type = "method"
      },
      SetSizeMul = {
        args = "(float sizeMul)",
        description = "Set particle size multiplicative modifier.",
        returns = "()",
        type = "method"
      },
      AddColorTime = {
        args = "(const Color& color, const float time)",
        description = "Add a color frame sorted in the correct position based on time.",
        returns = "()",
        type = "method"
      },
      AddColorFrame = {
        args = "(const ColorFrame& colorFrame)",
        description = "Add a color frame sorted in the correct position based on time.",
        returns = "()",
        type = "method"
      },
      RemoveColorFrame = {
        args = "(unsigned index)",
        description = "Remove color frame at index",
        returns = "()",
        type = "method"
      },
      SetColorFrame = {
        args = "(unsigned index, const ColorFrame& colorFrame)",
        description = "Set color animation frame at index. If index is greater than number of color frames, new color frames are added.",
        returns = "()",
        type = "method"
      },
      SetNumColorFrames = {
        args = "(unsigned number)",
        description = "Set number of color frames.",
        returns = "()",
        type = "method"
      },
      SortColorFrames = {
        args = "()",
        description = "Sort the list of color frames based on time.",
        returns = "()",
        type = "method"
      },
      AddTextureTime = {
        args = "(const Rect& uv, const float time)",
        description = "Add a texture frame sorted in the correct position based on time.",
        returns = "()",
        type = "method"
      },
      AddTextureFrame = {
        args = "(const TextureFrame& textureFrame)",
        description = "Add a texture frame sorted in the correct position based on time.",
        returns = "()",
        type = "method"
      },
      RemoveTextureFrame = {
        args = "(unsigned index)",
        description = "Remove texture frame at index",
        returns = "()",
        type = "method"
      },
      SetTextureFrame = {
        args = "(unsigned index, const TextureFrame& textureFrame)",
        description = "Set number of texture animation frames.",
        returns = "()",
        type = "method"
      },
      SetNumTextureFrames = {
        args = "(unsigned number)",
        description = "Set number of texture frames.",
        returns = "()",
        type = "method"
      },
      SortTextureFrames = {
        args = "()",
        description = "Sort the list of texture frames based on time.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone the particle effect.",
        returns = "(ParticleEffect*)",
        valuetype = "ParticleEffect",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumParticles = {
        args = "()",
        description = "Return maximum number of particles.",
        returns = "(unsigned)",
        type = "method"
      },
      GetUpdateInvisible = {
        args = "()",
        description = "Return whether to update when particles are not visible.",
        returns = "(bool)",
        type = "method"
      },
      IsRelative = {
        args = "()",
        description = "Return whether billboards are relative to the scene node.",
        returns = "(bool)",
        type = "method"
      },
      IsScaled = {
        args = "()",
        description = "Return whether scene node scale affects billboards' size.",
        returns = "(bool)",
        type = "method"
      },
      IsSorted = {
        args = "()",
        description = "Return whether billboards are sorted.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedScreenSize = {
        args = "()",
        description = "Return whether billboards are fixed screen size.",
        returns = "(bool)",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation Lod bias.",
        returns = "(float)",
        type = "method"
      },
      GetEmitterType = {
        args = "()",
        description = "Return emitter type.",
        returns = "(EmitterType)",
        type = "method"
      },
      GetEmitterSize = {
        args = "()",
        description = "Return emitter size.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetMinDirection = {
        args = "()",
        description = "Return negative direction limit.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetMaxDirection = {
        args = "()",
        description = "Return positive direction limit.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetConstantForce = {
        args = "()",
        description = "Return constant force acting on particles.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetDampingForce = {
        args = "()",
        description = "Return particle velocity damping force.",
        returns = "(float)",
        type = "method"
      },
      GetActiveTime = {
        args = "()",
        description = "Return emission active period length (0 = infinite.)",
        returns = "(float)",
        type = "method"
      },
      GetInactiveTime = {
        args = "()",
        description = "Return emission inactive period length (0 = infinite.)",
        returns = "(float)",
        type = "method"
      },
      GetMinEmissionRate = {
        args = "()",
        description = "Return minimum emission rate.",
        returns = "(float)",
        type = "method"
      },
      GetMaxEmissionRate = {
        args = "()",
        description = "Return maximum emission rate.",
        returns = "(float)",
        type = "method"
      },
      GetMinParticleSize = {
        args = "()",
        description = "Return particle minimum size.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxParticleSize = {
        args = "()",
        description = "Return particle maximum size.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinTimeToLive = {
        args = "()",
        description = "Return particle minimum time to live.",
        returns = "(float)",
        type = "method"
      },
      GetMaxTimeToLive = {
        args = "()",
        description = "Return particle maximum time to live.",
        returns = "(float)",
        type = "method"
      },
      GetMinVelocity = {
        args = "()",
        description = "Return particle minimum velocity.",
        returns = "(float)",
        type = "method"
      },
      GetMaxVelocity = {
        args = "()",
        description = "Return particle maximum velocity.",
        returns = "(float)",
        type = "method"
      },
      GetMinRotation = {
        args = "()",
        description = "Return particle minimum rotation.",
        returns = "(float)",
        type = "method"
      },
      GetMaxRotation = {
        args = "()",
        description = "Return particle maximum rotation.",
        returns = "(float)",
        type = "method"
      },
      GetMinRotationSpeed = {
        args = "()",
        description = "Return particle minimum rotation speed.",
        returns = "(float)",
        type = "method"
      },
      GetMaxRotationSpeed = {
        args = "()",
        description = "Return particle maximum rotation speed.",
        returns = "(float)",
        type = "method"
      },
      GetSizeAdd = {
        args = "()",
        description = "Return particle size additive modifier.",
        returns = "(float)",
        type = "method"
      },
      GetSizeMul = {
        args = "()",
        description = "Return particle size multiplicative modifier.",
        returns = "(float)",
        type = "method"
      },
      GetNumColorFrames = {
        args = "()",
        description = "Return number of color animation frames.",
        returns = "(unsigned)",
        type = "method"
      },
      GetColorFrame = {
        args = "(unsigned index)",
        description = "Return a color animation frame, or null if outside range.",
        returns = "(const ColorFrame*)",
        valuetype = "ColorFrame",
        type = "method"
      },
      GetNumTextureFrames = {
        args = "()",
        description = "Return number of texture animation frames.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTextureFrame = {
        args = "(unsigned index)",
        description = "Return a texture animation frame, or null if outside range.",
        returns = "(const TextureFrame*)",
        valuetype = "TextureFrame",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial.",
        type = "value"
      },
      numParticles = {
        description = "unsigned\nNumber of particles.",
        type = "value"
      },
      updateInvisible = {
        description = "bool\nUpdate when invisible flag.",
        type = "value"
      },
      relative = {
        description = "bool\nBillboards relative flag.",
        type = "value"
      },
      scaled = {
        description = "bool\nScale affects billboard scale flag.",
        type = "value"
      },
      sorted = {
        description = "bool\nBillboards sorted flag.",
        type = "value"
      },
      fixedScreenSize = {
        description = "bool\nBillboards fixed screen size flag.",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      emitterType = {
        description = "EmitterType\nEmitter shape.",
        type = "value"
      },
      emitterSize = {
        valuetype = "Vector3",
        description = "const Vector3&\nEmitter size.",
        type = "value"
      },
      minDirection = {
        valuetype = "Vector3",
        description = "const Vector3&",
        type = "value"
      },
      maxDirection = {
        valuetype = "Vector3",
        description = "const Vector3&",
        type = "value"
      },
      constantForce = {
        valuetype = "Vector3",
        description = "const Vector3&\nParticle constant force.",
        type = "value"
      },
      dampingForce = {
        description = "float\nParticle velocity damping force.",
        type = "value"
      },
      activeTime = {
        description = "float\nActive period.",
        type = "value"
      },
      inactiveTime = {
        description = "float\nInactive period.",
        type = "value"
      },
      minEmissionRate = {
        description = "float",
        type = "value"
      },
      maxEmissionRate = {
        description = "float",
        type = "value"
      },
      minParticleSize = {
        valuetype = "Vector2",
        description = "const Vector2&",
        type = "value"
      },
      maxParticleSize = {
        valuetype = "Vector2",
        description = "const Vector2&",
        type = "value"
      },
      minTimeToLive = {
        description = "float",
        type = "value"
      },
      maxTimeToLive = {
        description = "float",
        type = "value"
      },
      minVelocity = {
        description = "float",
        type = "value"
      },
      maxVelocity = {
        description = "float",
        type = "value"
      },
      minRotation = {
        description = "float",
        type = "value"
      },
      maxRotation = {
        description = "float",
        type = "value"
      },
      minRotationSpeed = {
        description = "float",
        type = "value"
      },
      maxRotationSpeed = {
        description = "float",
        type = "value"
      },
      sizeAdd = {
        description = "float\nParticle size additive parameter.",
        type = "value"
      },
      sizeMul = {
        description = "float\nParticle size multiplicative parameter.",
        type = "value"
      },
      numColorFrames = {
        description = "unsigned",
        type = "value"
      },
      numTextureFrames = {
        description = "unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleEffect2D = {
    childs = {
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone the 2D particle effect.",
        returns = "(ParticleEffect2D*)",
        valuetype = "ParticleEffect2D",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleEmitter = {
    childs = {
      SetEffect = {
        args = "(ParticleEffect* effect)",
        description = "Set particle effect.",
        returns = "()",
        type = "method"
      },
      SetNumParticles = {
        args = "(unsigned num)",
        description = "Set maximum number of particles.",
        returns = "()",
        type = "method"
      },
      SetEmitting = {
        args = "(bool enable)",
        description = "Set whether should be emitting. If the state was changed, also resets the emission period timer.",
        returns = "()",
        type = "method"
      },
      SetSerializeParticles = {
        args = "(bool enable)",
        description = "Set whether particles should be serialized. Default true, set false to reduce scene file size.",
        returns = "()",
        type = "method"
      },
      SetAutoRemoveMode = {
        args = "(AutoRemoveMode mode)",
        description = "/ Set to remove either the emitter component or its owner node from the scene automatically on particle effect completion. Disabled by default.",
        returns = "()",
        type = "method"
      },
      ResetEmissionTimer = {
        args = "()",
        description = "Reset the emission period timer.",
        returns = "()",
        type = "method"
      },
      RemoveAllParticles = {
        args = "()",
        description = "Remove all current particles.",
        returns = "()",
        type = "method"
      },
      Reset = {
        args = "()",
        description = "Reset the particle emitter completely. Removes current particles, sets emitting state on, and resets the emission timer.",
        returns = "()",
        type = "method"
      },
      ApplyEffect = {
        args = "()",
        description = "Apply not continuously updated values such as the material, the number of particles and sorting mode from the particle effect. Call this if you change the effect programmatically.",
        returns = "()",
        type = "method"
      },
      GetEffect = {
        args = "()",
        description = "Return particle effect.",
        returns = "(ParticleEffect*)",
        valuetype = "ParticleEffect",
        type = "method"
      },
      GetNumParticles = {
        args = "()",
        description = "Return maximum number of particles.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEmitting = {
        args = "()",
        description = "Return whether is currently emitting.",
        returns = "(bool)",
        type = "method"
      },
      GetSerializeParticles = {
        args = "()",
        description = "Return whether particles are to be serialized.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoRemoveMode = {
        args = "()",
        description = "Return automatic removal mode on particle effect completion.",
        returns = "(AutoRemoveMode)",
        type = "method"
      },
      effect = {
        valuetype = "ParticleEffect",
        description = "ParticleEffect*\nParticle effect.",
        type = "value"
      },
      numParticles = {
        description = "unsigned",
        type = "value"
      },
      emitting = {
        description = "bool\nCurrently emitting flag.",
        type = "value"
      },
      serializeParticles = {
        description = "bool\nSerialize particles flag.",
        type = "value"
      },
      autoRemoveMode = {
        description = "AutoRemoveMode",
        type = "value"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetNumBillboards = {
        args = "(unsigned num)",
        description = "Set number of billboards.",
        returns = "()",
        type = "method"
      },
      SetRelative = {
        args = "(bool enable)",
        description = "Set whether billboards are relative to the scene node. Default true.",
        returns = "()",
        type = "method"
      },
      SetScaled = {
        args = "(bool enable)",
        description = "Set whether scene node scale affects billboards' size. Default true.",
        returns = "()",
        type = "method"
      },
      SetSorted = {
        args = "(bool enable)",
        description = "Set whether billboards are sorted by distance. Default false.",
        returns = "()",
        type = "method"
      },
      SetFixedScreenSize = {
        args = "(bool enable)",
        description = "Set whether billboards have fixed size on screen (measured in pixels) regardless of distance to camera. Default false.",
        returns = "()",
        type = "method"
      },
      SetFaceCameraMode = {
        args = "(FaceCameraMode mode)",
        description = "Set how the billboards should rotate in relation to the camera. Default is to follow camera rotation on all axes (FC_ROTATE_XYZ.)",
        returns = "()",
        type = "method"
      },
      SetMinAngle = {
        args = "(float angle)",
        description = "Set minimal angle between billboard normal and look-at direction.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      Commit = {
        args = "()",
        description = "Mark for bounding box and vertex buffer update. Call after modifying the billboards.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNumBillboards = {
        args = "()",
        description = "Return number of billboards.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBillboard = {
        args = "(unsigned index)",
        description = "Return billboard by index.",
        returns = "(Billboard*)",
        valuetype = "Billboard",
        type = "method"
      },
      IsRelative = {
        args = "()",
        description = "Return whether billboards are relative to the scene node.",
        returns = "(bool)",
        type = "method"
      },
      IsScaled = {
        args = "()",
        description = "Return whether scene node scale affects billboards' size.",
        returns = "(bool)",
        type = "method"
      },
      IsSorted = {
        args = "()",
        description = "Return whether billboards are sorted.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedScreenSize = {
        args = "()",
        description = "Return whether billboards are fixed screen size.",
        returns = "(bool)",
        type = "method"
      },
      GetFaceCameraMode = {
        args = "()",
        description = "Return how the billboards rotate in relation to the camera.",
        returns = "(FaceCameraMode)",
        type = "method"
      },
      GetMinAngle = {
        args = "()",
        description = "Return minimal angle between billboard normal and look-at direction.",
        returns = "(float)",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      numBillboards = {
        description = "unsigned",
        type = "value"
      },
      relative = {
        description = "bool\nBillboards relative flag.",
        type = "value"
      },
      scaled = {
        description = "bool\nScale affects billboard scale flag.",
        type = "value"
      },
      sorted = {
        description = "bool\nBillboards sorted flag.",
        type = "value"
      },
      fixedScreenSize = {
        description = "bool\nBillboards fixed screen size flag.",
        type = "value"
      },
      faceCameraMode = {
        description = "FaceCameraMode\nBillboard rotation mode in relation to the camera.",
        type = "value"
      },
      minAngle = {
        description = "float\nMinimal angle between billboard normal and look-at direction.",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ParticleEmitter2D = {
    childs = {
      SetEffect = {
        args = "(ParticleEffect2D* effect)",
        description = "Set particle effect.",
        returns = "()",
        type = "method"
      },
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode blendMode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      GetEffect = {
        args = "()",
        description = "Return particle effect.",
        returns = "(ParticleEffect2D*)",
        valuetype = "ParticleEffect2D",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      effect = {
        valuetype = "ParticleEffect2D",
        description = "ParticleEffect2D*\nParticle effect.",
        type = "value"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      SetLayer = {
        args = "(int layer)",
        description = "Set layer.",
        returns = "()",
        type = "method"
      },
      SetOrderInLayer = {
        args = "(int orderInLayer)",
        description = "Set order in layer.",
        returns = "()",
        type = "method"
      },
      GetLayer = {
        args = "()",
        description = "Return layer.",
        returns = "(int)",
        type = "method"
      },
      GetOrderInLayer = {
        args = "()",
        description = "Return order in layer.",
        returns = "(int)",
        type = "method"
      },
      layer = {
        description = "int\nLayer.",
        type = "value"
      },
      orderInLayer = {
        description = "int\nOrder in layer.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Pass = {
    childs = {
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetCullMode = {
        args = "(CullMode mode)",
        description = "Set culling mode override. By default culling mode is read from the material instead. Set the illegal culling mode MAX_CULLMODES to disable override again.",
        returns = "()",
        type = "method"
      },
      SetDepthTestMode = {
        args = "(CompareMode mode)",
        description = "Set depth compare mode.",
        returns = "()",
        type = "method"
      },
      SetLightingMode = {
        args = "(PassLightingMode mode)",
        description = "Set pass lighting mode, affects what shader variations will be attempted to be loaded.",
        returns = "()",
        type = "method"
      },
      SetDepthWrite = {
        args = "(bool enable)",
        description = "Set depth write on/off.",
        returns = "()",
        type = "method"
      },
      SetAlphaToCoverage = {
        args = "(bool enable)",
        description = "Set alpha-to-coverage on/off.",
        returns = "()",
        type = "method"
      },
      SetIsDesktop = {
        args = "(bool enable)",
        description = "Set whether requires desktop level hardware.",
        returns = "()",
        type = "method"
      },
      SetVertexShader = {
        args = "(const String name)",
        description = "Set vertex shader name.",
        returns = "()",
        type = "method"
      },
      SetPixelShader = {
        args = "(const String name)",
        description = "Set pixel shader name.",
        returns = "()",
        type = "method"
      },
      SetVertexShaderDefines = {
        args = "(const String defines)",
        description = "Set vertex shader defines. Separate multiple defines with spaces.",
        returns = "()",
        type = "method"
      },
      SetPixelShaderDefines = {
        args = "(const String defines)",
        description = "Set pixel shader defines. Separate multiple defines with spaces.",
        returns = "()",
        type = "method"
      },
      SetVertexShaderDefineExcludes = {
        args = "(const String excludes)",
        description = "Set vertex shader define excludes. Use to mark defines that the shader code will not recognize, to prevent compiling redundant shader variations.",
        returns = "()",
        type = "method"
      },
      SetPixelShaderDefineExcludes = {
        args = "(const String excludes)",
        description = "Set pixel shader define excludes. Use to mark defines that the shader code will not recognize, to prevent compiling redundant shader variations.",
        returns = "()",
        type = "method"
      },
      ReleaseShaders = {
        args = "()",
        description = "Reset shader pointers.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return pass name.",
        returns = "(const String)",
        type = "method"
      },
      GetIndex = {
        args = "()",
        description = "Return pass index. This is used for optimal render-time pass queries that avoid map lookups.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCullMode = {
        args = "()",
        description = "Return culling mode override. If pass is not overriding culling mode (default), the illegal mode MAX_CULLMODES is returned.",
        returns = "(CullMode)",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetDepthTestMode = {
        args = "()",
        description = "Return depth compare mode.",
        returns = "(CompareMode)",
        type = "method"
      },
      GetLightingMode = {
        args = "()",
        description = "Return pass lighting mode.",
        returns = "(PassLightingMode)",
        type = "method"
      },
      GetDepthWrite = {
        args = "()",
        description = "Return depth write mode.",
        returns = "(bool)",
        type = "method"
      },
      GetAlphaToCoverage = {
        args = "()",
        description = "Return alpha-to-coverage mode.",
        returns = "(bool)",
        type = "method"
      },
      IsDesktop = {
        args = "()",
        description = "Return whether requires desktop level hardware.",
        returns = "(bool)",
        type = "method"
      },
      GetVertexShader = {
        args = "()",
        description = "Return vertex shader name.",
        returns = "(const String)",
        type = "method"
      },
      GetPixelShader = {
        args = "()",
        description = "Return pixel shader name.",
        returns = "(const String)",
        type = "method"
      },
      GetVertexShaderDefines = {
        args = "()",
        description = "Return vertex shader defines.",
        returns = "(const String)",
        type = "method"
      },
      GetPixelShaderDefines = {
        args = "()",
        description = "Return pixel shader defines.",
        returns = "(const String)",
        type = "method"
      },
      GetVertexShaderDefineExcludes = {
        args = "()",
        description = "Return vertex shader define excludes.",
        returns = "(const String)",
        type = "method"
      },
      GetPixelShaderDefineExcludes = {
        args = "()",
        description = "Return pixel shader define excludes.",
        returns = "(const String)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nPass name.",
        type = "value"
      },
      index = {
        description = "(Readonly) unsigned\nPass index.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      cullMode = {
        description = "CullMode\nCulling mode.",
        type = "value"
      },
      depthTestMode = {
        description = "CompareMode\nDepth compare mode.",
        type = "value"
      },
      lightingMode = {
        description = "PassLightingMode\nLighting mode.",
        type = "value"
      },
      depthWrite = {
        description = "bool\nDepth write mode.",
        type = "value"
      },
      alphaToCoverage = {
        description = "bool\nAlpha-to-coverage mode.",
        type = "value"
      },
      desktop = {
        description = "(Readonly) bool",
        type = "value"
      },
      vertexShader = {
        description = "String",
        type = "value"
      },
      pixelShader = {
        description = "String",
        type = "value"
      },
      vertexShaderDefines = {
        description = "String\nVertex shader defines.",
        type = "value"
      },
      pixelShaderDefines = {
        description = "String\nPixel shader defines.",
        type = "value"
      },
      vertexShaderDefineExcludes = {
        description = "String\nVertex shader define excludes.",
        type = "value"
      },
      pixelShaderDefineExcludes = {
        description = "String\nPixel shader define excludes.",
        type = "value"
      },
    },
    type = "class"
  },
  PhysicsRaycastResult = {
    childs = {
      new = {
        args = "()",
        returns = "(PhysicsRaycastResult*)",
        valuetype = "PhysicsRaycastResult",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      distance = {
        description = "float",
        type = "value"
      },
      hitFraction = {
        description = "float",
        type = "value"
      },
      body = {
        valuetype = "RigidBody",
        description = "RigidBody*",
        type = "value"
      },
    },
    type = "class"
  },
  PhysicsRaycastResult2D = {
    childs = {
      new = {
        args = "()",
        returns = "(PhysicsRaycastResult2D*)",
        valuetype = "PhysicsRaycastResult2D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      position = {
        description = "Vector2",
        type = "value"
      },
      normal = {
        description = "Vector2",
        type = "value"
      },
      distance = {
        description = "float",
        type = "value"
      },
      body = {
        valuetype = "RigidBody2D",
        description = "RigidBody2D*",
        type = "value"
      },
    },
    type = "class"
  },
  PhysicsWorld = {
    childs = {
      Update = {
        args = "(float timeStep)",
        description = "Step the simulation forward.",
        returns = "()",
        type = "method"
      },
      UpdateCollisions = {
        args = "()",
        description = "Refresh collisions only without updating dynamics.",
        returns = "()",
        type = "method"
      },
      SetFps = {
        args = "(int fps)",
        description = "Set simulation substeps per second.",
        returns = "()",
        type = "method"
      },
      SetGravity = {
        args = "(const Vector3& gravity)",
        description = "Set gravity.",
        returns = "()",
        type = "method"
      },
      SetMaxSubSteps = {
        args = "(int num)",
        description = "Set maximum number of physics substeps per frame. 0 (default) is unlimited. Positive values cap the amount. Use a negative value to enable an adaptive timestep. This may cause inconsistent physics behavior.",
        returns = "()",
        type = "method"
      },
      SetNumIterations = {
        args = "(int num)",
        description = "Set number of constraint solver iterations.",
        returns = "()",
        type = "method"
      },
      SetUpdateEnabled = {
        args = "(bool enable)",
        description = "Enable or disable automatic physics simulation during scene update. Enabled by default.",
        returns = "()",
        type = "method"
      },
      SetInterpolation = {
        args = "(bool enable)",
        description = "Set whether to interpolate between simulation steps.",
        returns = "()",
        type = "method"
      },
      SetInternalEdge = {
        args = "(bool enable)",
        description = "Set whether to use Bullet's internal edge utility for trimesh collisions. Disabled by default.",
        returns = "()",
        type = "method"
      },
      SetSplitImpulse = {
        args = "(bool enable)",
        description = "Set split impulse collision mode. This is more accurate, but slower. Disabled by default.",
        returns = "()",
        type = "method"
      },
      SetMaxNetworkAngularVelocity = {
        args = "(float velocity)",
        description = "Set maximum angular velocity for network replication.",
        returns = "()",
        type = "method"
      },
      Raycast = {
        args = "(const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(const PODVector<PhysicsRaycastResult>&)",
        valuetype = "PODVector<PhysicsRaycastResult>",
        type = "method"
      },
      RaycastSingle = {
        args = "(const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult)",
        type = "method"
      },
      RaycastSingleSegmented = {
        args = "(const Ray& ray, float maxDistance, float segmentDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult)",
        type = "method"
      },
      SphereCast = {
        args = "(const Ray& ray, float radius, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult)",
        type = "method"
      },
      ConvexCast = {
        args = "(CollisionShape* shape, const Vector3& startPos, const Quaternion& startRot, const Vector3& endPos, const Quaternion& endRot, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult)",
        type = "method"
      },
      GetRigidBodies = {
        args = "(const Sphere& sphere, unsigned collisionMask = M_MAX_UNSIGNED)",
        description = "(const PODVector<RigidBody*>&) GetRigidBodies (const BoundingBox& box, unsigned collisionMask = M_MAX_UNSIGNED),\n(const PODVector<RigidBody*>&) GetRigidBodies (const RigidBody* body)",
        returns = "(const PODVector<RigidBody*>&)",
        valuetype = "PODVector<RigidBody*>",
        type = "method"
      },
      GetCollidingBodies = {
        args = "(const RigidBody* body)",
        returns = "(const PODVector<RigidBody*>&)",
        valuetype = "PODVector<RigidBody*>",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      RemoveCachedGeometry = {
        args = "(Model* model)",
        description = "Invalidate cached collision geometry for a model.",
        returns = "()",
        type = "method"
      },
      GetGravity = {
        args = "()",
        description = "Return gravity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetMaxSubSteps = {
        args = "()",
        description = "Return maximum number of physics substeps per frame.",
        returns = "(int)",
        type = "method"
      },
      GetNumIterations = {
        args = "()",
        description = "Return number of constraint solver iterations.",
        returns = "(int)",
        type = "method"
      },
      IsUpdateEnabled = {
        args = "()",
        description = "Return whether physics world will automatically simulate during scene update.",
        returns = "(bool)",
        type = "method"
      },
      GetInterpolation = {
        args = "()",
        description = "Return whether interpolation between simulation steps is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetInternalEdge = {
        args = "()",
        description = "Return whether Bullet's internal edge utility for trimesh collisions is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetSplitImpulse = {
        args = "()",
        description = "Return whether split impulse collision mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetFps = {
        args = "()",
        description = "Return simulation steps per second.",
        returns = "(int)",
        type = "method"
      },
      GetMaxNetworkAngularVelocity = {
        args = "()",
        description = "Return maximum angular velocity for network replication.",
        returns = "(float)",
        type = "method"
      },
      gravity = {
        description = "Vector3",
        type = "value"
      },
      maxSubSteps = {
        description = "int\nMaximum number of simulation substeps per frame. 0 (default) unlimited, or negative values for adaptive timestep.",
        type = "value"
      },
      numIterations = {
        description = "int",
        type = "value"
      },
      updateEnabled = {
        description = "bool\nAutomatic simulation update enabled flag.",
        type = "value"
      },
      interpolation = {
        description = "bool\nInterpolation flag.",
        type = "value"
      },
      internalEdge = {
        description = "bool\nUse internal edge utility flag.",
        type = "value"
      },
      splitImpulse = {
        description = "bool",
        type = "value"
      },
      fps = {
        description = "int\nSimulation substeps per second.",
        type = "value"
      },
      maxNetworkAngularVelocity = {
        description = "float\nMaximum angular velocity for network replication.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  PhysicsWorld2D = {
    childs = {
      DrawDebugGeometry = {
        args = "()",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      SetUpdateEnabled = {
        args = "(bool enable)",
        description = "Enable or disable automatic physics simulation during scene update. Enabled by default.",
        returns = "()",
        type = "method"
      },
      SetDrawShape = {
        args = "(bool drawShape)",
        description = "Set draw shape.",
        returns = "()",
        type = "method"
      },
      SetDrawJoint = {
        args = "(bool drawJoint)",
        description = "Set draw joint.",
        returns = "()",
        type = "method"
      },
      SetDrawAabb = {
        args = "(bool drawAabb)",
        description = "Set draw aabb.",
        returns = "()",
        type = "method"
      },
      SetDrawPair = {
        args = "(bool drawPair)",
        description = "Set draw pair.",
        returns = "()",
        type = "method"
      },
      SetDrawCenterOfMass = {
        args = "(bool drawCenterOfMass)",
        description = "Set draw center of mass.",
        returns = "()",
        type = "method"
      },
      SetAllowSleeping = {
        args = "(bool enable)",
        description = "Set allow sleeping.",
        returns = "()",
        type = "method"
      },
      SetWarmStarting = {
        args = "(bool enable)",
        description = "Set warm starting.",
        returns = "()",
        type = "method"
      },
      SetContinuousPhysics = {
        args = "(bool enable)",
        description = "Set continuous physics.",
        returns = "()",
        type = "method"
      },
      SetSubStepping = {
        args = "(bool enable)",
        description = "Set sub stepping.",
        returns = "()",
        type = "method"
      },
      SetGravity = {
        args = "(const Vector2& gravity)",
        description = "Set gravity.",
        returns = "()",
        type = "method"
      },
      SetAutoClearForces = {
        args = "(bool enable)",
        description = "Set auto clear forces.",
        returns = "()",
        type = "method"
      },
      SetVelocityIterations = {
        args = "(int velocityIterations)",
        description = "Set velocity iterations.",
        returns = "()",
        type = "method"
      },
      SetPositionIterations = {
        args = "(int positionIterations)",
        description = "Set position iterations.",
        returns = "()",
        type = "method"
      },
      Raycast = {
        args = "(const Vector2& startPoint, const Vector2& endPoint, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(const PODVector<PhysicsRaycastResult2D>&)",
        valuetype = "PODVector<PhysicsRaycastResult2D>",
        type = "method"
      },
      RaycastSingle = {
        args = "(const Vector2& startPoint, const Vector2& endPoint, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(PhysicsRaycastResult2D)",
        type = "method"
      },
      GetRigidBody = {
        args = "(const Vector2& point, unsigned collisionMask = M_MAX_UNSIGNED)",
        description = "(RigidBody2D*) GetRigidBody (int screenX, int screenY, unsigned collisionMask = M_MAX_UNSIGNED)\nReturn rigid body at point.",
        returns = "(RigidBody2D*)",
        valuetype = "RigidBody2D",
        type = "method"
      },
      GetRigidBodies = {
        args = "(const Rect& aabb, unsigned collisionMask = M_MAX_UNSIGNED)",
        returns = "(const PODVector<RigidBody2D*>&)",
        valuetype = "PODVector<RigidBody2D*>",
        type = "method"
      },
      IsUpdateEnabled = {
        args = "()",
        description = "Return whether physics world will automatically simulate during scene update.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawShape = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetDrawJoint = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetDrawAabb = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetDrawPair = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetDrawCenterOfMass = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetAllowSleeping = {
        args = "()",
        description = "Return allow sleeping.",
        returns = "(bool)",
        type = "method"
      },
      GetWarmStarting = {
        args = "()",
        description = "Return warm starting.",
        returns = "(bool)",
        type = "method"
      },
      GetContinuousPhysics = {
        args = "()",
        description = "Return continuous physics.",
        returns = "(bool)",
        type = "method"
      },
      GetSubStepping = {
        args = "()",
        description = "Return sub stepping.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoClearForces = {
        args = "()",
        description = "Return auto clear forces.",
        returns = "(bool)",
        type = "method"
      },
      GetGravity = {
        args = "()",
        description = "Return gravity.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetVelocityIterations = {
        args = "()",
        description = "Return velocity iterations.",
        returns = "(int)",
        type = "method"
      },
      GetPositionIterations = {
        args = "()",
        description = "Return position iterations.",
        returns = "(int)",
        type = "method"
      },
      updateEnabled = {
        description = "bool\nAutomatic simulation update enabled flag.",
        type = "value"
      },
      drawShape = {
        description = "bool",
        type = "value"
      },
      drawJoint = {
        description = "bool",
        type = "value"
      },
      drawAabb = {
        description = "bool",
        type = "value"
      },
      drawPair = {
        description = "bool",
        type = "value"
      },
      drawCenterOfMass = {
        description = "bool",
        type = "value"
      },
      allowSleeping = {
        description = "bool",
        type = "value"
      },
      warmStarting = {
        description = "bool",
        type = "value"
      },
      continuousPhysics = {
        description = "bool",
        type = "value"
      },
      subStepping = {
        description = "bool",
        type = "value"
      },
      autoClearForces = {
        description = "bool",
        type = "value"
      },
      gravity = {
        valuetype = "Vector2",
        description = "Vector2&\nGravity.",
        type = "value"
      },
      velocityIterations = {
        description = "int\nVelocity iterations.",
        type = "value"
      },
      positionIterations = {
        description = "int\nPosition iterations.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Plane = {
    childs = {
      new = {
        args = "()",
        description = "(Plane*) new (const Plane& plane),\n(Plane*) new (const Vector3& v0, const Vector3& v1, const Vector3& v2),\n(Plane*) new (const Vector3& normal, const Vector3& point),\n(Plane*) new (const Vector4& plane)",
        returns = "(Plane*)",
        valuetype = "Plane",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Vector3& v0, const Vector3& v1, const Vector3& v2)",
        description = "() Define (const Vector3& normal, const Vector3& point),\n() Define (const Vector4& plane)",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform),\n() Transform (const Matrix4& transform)",
        returns = "()",
        type = "method"
      },
      Project = {
        args = "(const Vector3& point)",
        returns = "(Vector3)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      Reflect = {
        args = "(const Vector3& direction)",
        returns = "(Vector3)",
        type = "method"
      },
      ReflectionMatrix = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(Plane) Transformed (const Matrix3x4& transform),\n(Plane) Transformed (const Matrix4& transform)",
        returns = "(Plane)",
        type = "method"
      },
      ToVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      absNormal = {
        description = "Vector3",
        type = "value"
      },
      d = {
        description = "float",
        type = "value"
      },
      UP = {
        description = "const Plane",
        type = "value"
      },
    },
    type = "class"
  },
  Polyhedron = {
    childs = {
      new = {
        args = "()",
        description = "(Polyhedron*) new (const Polyhedron& polyhedron),\n(Polyhedron*) new (const BoundingBox& box),\n(Polyhedron*) new (const Frustum& frustum)",
        returns = "(Polyhedron*)",
        valuetype = "Polyhedron",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const BoundingBox& box)",
        description = "() Define (const Frustum& frustum)",
        returns = "()",
        type = "method"
      },
      AddFace = {
        args = "(const Vector3& v0, const Vector3& v1, const Vector3& v2)",
        description = "() AddFace (const Vector3& v0, const Vector3& v1, const Vector3& v2, const Vector3& v3)",
        returns = "()",
        type = "method"
      },
      Clip = {
        args = "(const Plane& plane)",
        description = "() Clip (const BoundingBox& box),\n() Clip (const Frustum& box)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Transform = {
        args = "(const Matrix3& transform)",
        description = "() Transform (const Matrix3x4& transform)",
        returns = "()",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3& transform)",
        description = "(Polyhedron) Transformed (const Matrix3x4& transform)",
        returns = "(Polyhedron)",
        type = "method"
      },
      Empty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      empty = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  ProgressBar = {
    childs = {
      new = {
        args = "()",
        returns = "(ProgressBar*)",
        valuetype = "ProgressBar",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetOrientation = {
        args = "(Orientation orientation)",
        description = "Set orientation type.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set ProgressBar range maximum value (minimum value is always 0.)",
        returns = "()",
        type = "method"
      },
      SetValue = {
        args = "(float value)",
        description = "Set ProgressBar current value.",
        returns = "()",
        type = "method"
      },
      ChangeValue = {
        args = "(float delta)",
        description = "Change value by a delta.",
        returns = "()",
        type = "method"
      },
      SetLoadingPercentStyle = {
        args = "(const String style)",
        description = "Sets the loading percent style.",
        returns = "()",
        type = "method"
      },
      SetShowPercentText = {
        args = "(bool showPercentText)",
        description = "Sets the flag to display the percent text.",
        returns = "()",
        type = "method"
      },
      GetOrientation = {
        args = "()",
        description = "Return orientation type.",
        returns = "(Orientation)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return ProgressBar range.",
        returns = "(float)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return ProgressBar current value.",
        returns = "(float)",
        type = "method"
      },
      GetKnob = {
        args = "()",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetLoadingPercentStyle = {
        args = "()",
        description = "Returns the loading percent style.",
        returns = "(const String)",
        type = "method"
      },
      GetShowPercentText = {
        args = "()",
        description = "Returns the flag to display the percent text.",
        returns = "(bool)",
        type = "method"
      },
      orientation = {
        description = "Orientation\nOrientation.",
        type = "value"
      },
      range = {
        description = "float\nProgressBar range.",
        type = "value"
      },
      value = {
        description = "float\nProgressBar current value.",
        type = "value"
      },
      knob = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nProgressBar knob.",
        type = "value"
      },
      loadingPercentStyle = {
        description = "(Readonly) String\nProgressBar text style",
        type = "value"
      },
      showPercentText = {
        description = "bool\nFlag to show the percent text.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  PropertySet2D = {
    childs = {
      HasProperty = {
        args = "(const String name)",
        description = "Return has property.",
        returns = "(bool)",
        type = "method"
      },
      GetProperty = {
        args = "(const String name)",
        description = "Return property value.",
        returns = "(const String)",
        type = "method"
      },
    },
    type = "class"
  },
  Quaternion = {
    childs = {
      new = {
        args = "()",
        description = "(Quaternion*) new (const Quaternion& quat),\n(Quaternion*) new (float w, float x, float y, float z),\n(Quaternion*) new (float angle, const Vector3& axis),\n(Quaternion*) new (float angle),\n(Quaternion*) new (float x, float y, float z),\n(Quaternion*) new (const Vector3& start, const Vector3& end),\n(Quaternion*) new (const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis),\n(Quaternion*) new (const Matrix3& matrix)",
        returns = "(Quaternion*)",
        valuetype = "Quaternion",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      FromAngleAxis = {
        args = "(float angle, const Vector3& axis)",
        returns = "()",
        type = "method"
      },
      FromEulerAngles = {
        args = "(float x, float y, float z)",
        returns = "()",
        type = "method"
      },
      FromRotationTo = {
        args = "(const Vector3& start, const Vector3& end)",
        returns = "()",
        type = "method"
      },
      FromAxes = {
        args = "(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis)",
        returns = "()",
        type = "method"
      },
      FromRotationMatrix = {
        args = "(const Matrix3& matrix)",
        returns = "()",
        type = "method"
      },
      FromLookRotation = {
        args = "(const Vector3& direction, const Vector3& up)",
        returns = "(bool)",
        type = "method"
      },
      Normalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Normalized = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      Inverse = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      LengthSquared = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      DotProduct = {
        args = "(const Quaternion& rhs)",
        returns = "(float)",
        type = "method"
      },
      Equals = {
        args = "(const Quaternion& rhs)",
        returns = "(bool)",
        type = "method"
      },
      IsNaN = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Conjugate = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      EulerAngles = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      YawAngle = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      PitchAngle = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      RollAngle = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      RotationMatrix = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      Slerp = {
        args = "(const Quaternion& rhs, float t)",
        returns = "(Quaternion)",
        type = "method"
      },
      Nlerp = {
        args = "(const Quaternion& rhs, float t, bool shortestPath)",
        returns = "(Quaternion)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      w = {
        description = "float",
        type = "value"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      z = {
        description = "float",
        type = "value"
      },
      IDENTITY = {
        description = "const Quaternion",
        type = "value"
      },
    },
    type = "class"
  },
  Ray = {
    childs = {
      new = {
        args = "()",
        description = "(Ray*) new (const Vector3& origin, const Vector3& direction),\n(Ray*) new (const Ray& ray)",
        returns = "(Ray*)",
        valuetype = "Ray",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Vector3& origin, const Vector3& direction)",
        returns = "()",
        type = "method"
      },
      Project = {
        args = "(const Vector3& point)",
        returns = "(Vector3)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      ClosestPoint = {
        args = "(const Ray& ray)",
        returns = "(Vector3)",
        type = "method"
      },
      HitDistance = {
        args = "(const Plane& plane)",
        description = "(float) HitDistance (const BoundingBox& box),\n(float) HitDistance (const Frustum& frustum, bool solidInside = true),\n(float) HitDistance (const Sphere& sphere),\n(float) HitDistance (const Vector3& v0, const Vector3& v1, const Vector3& v2)",
        returns = "(float)",
        type = "method"
      },
      Transformed = {
        args = "(const Matrix3x4& transform)",
        returns = "(Ray)",
        type = "method"
      },
      origin = {
        description = "Vector3",
        type = "value"
      },
      direction = {
        description = "Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  RayQueryResult = {
    childs = {
      new = {
        args = "()",
        returns = "(RayQueryResult*)",
        valuetype = "RayQueryResult",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      normal = {
        description = "Vector3",
        type = "value"
      },
      textureUV = {
        description = "Vector2",
        type = "value"
      },
      distance = {
        description = "float",
        type = "value"
      },
      drawable = {
        valuetype = "Drawable",
        description = "Drawable*",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      subObject = {
        description = "unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  Rect = {
    childs = {
      new = {
        args = "()",
        description = "(Rect*) new (const Rect& rect),\n(Rect*) new (const Vector2& min, const Vector2& max),\n(Rect*) new (float left, float top, float right, float bottom),\n(Rect*) new (const Vector4& vector)",
        returns = "(Rect*)",
        valuetype = "Rect",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Rect& rect)",
        description = "() Define (const Vector2& min, const Vector2& max),\n() Define (const Vector2& point)",
        returns = "()",
        type = "method"
      },
      Merge = {
        args = "(const Vector2& point)",
        description = "() Merge (const Rect& rect)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Clip = {
        args = "(const Rect& rect)",
        returns = "()",
        type = "method"
      },
      Defined = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Center = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      Size = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      HalfSize = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      Equals = {
        args = "(const Rect& rhs)",
        returns = "(bool)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector2& point)",
        description = "(Intersection) IsInside (const Rect& rect)",
        returns = "(Intersection)",
        type = "method"
      },
      ToVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      min = {
        description = "Vector2",
        type = "value"
      },
      max = {
        description = "Vector2",
        type = "value"
      },
      FULL = {
        description = "const Rect",
        type = "value"
      },
      POSITIVE = {
        description = "const Rect",
        type = "value"
      },
      ZERO = {
        description = "const Rect",
        type = "value"
      },
      center = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      size = {
        description = "(Readonly) Vector2",
        type = "value"
      },
      halfSize = {
        description = "(Readonly) Vector2",
        type = "value"
      },
    },
    type = "class"
  },
  RemoteEvent = {
    childs = {
      senderID = {
        description = "unsigned",
        type = "value"
      },
      eventType = {
        description = "StringHash",
        type = "value"
      },
      eventData = {
        description = "VariantMap",
        type = "value"
      },
      inOrder = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  RenderPath = {
    childs = {
      Clone = {
        args = "()",
        description = "Clone the rendering path.",
        returns = "(RenderPath*)",
        valuetype = "RenderPath",
        type = "method"
      },
      Load = {
        args = "(XMLFile* file)",
        description = "Clear existing data and load from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      Append = {
        args = "(XMLFile* file)",
        description = "Append data from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetEnabled = {
        args = "(const String tag, bool active)",
        description = "Enable/disable commands and rendertargets by tag.",
        returns = "()",
        type = "method"
      },
      ToggleEnabled = {
        args = "(const String tag)",
        description = "Toggle enabled state of commands and rendertargets by tag.",
        returns = "()",
        type = "method"
      },
      SetRenderTarget = {
        args = "(unsigned index, const RenderTargetInfo& info)",
        description = "Assign rendertarget at index.",
        returns = "()",
        type = "method"
      },
      AddRenderTarget = {
        args = "(const RenderTargetInfo& info)",
        description = "Add a rendertarget.",
        returns = "()",
        type = "method"
      },
      RemoveRenderTarget = {
        args = "(const String name)",
        description = "() RemoveRenderTarget (unsigned index)\nRemove a rendertarget by name.",
        returns = "()",
        type = "method"
      },
      RemoveRenderTargets = {
        args = "(const String tag)",
        description = "Remove rendertargets by tag name.",
        returns = "()",
        type = "method"
      },
      SetCommand = {
        args = "(unsigned index, const RenderPathCommand& command)",
        description = "Assign command at index.",
        returns = "()",
        type = "method"
      },
      AddCommand = {
        args = "(const RenderPathCommand& command)",
        description = "Add a command to the end of the list.",
        returns = "()",
        type = "method"
      },
      InsertCommand = {
        args = "(unsigned index, const RenderPathCommand& command)",
        description = "Insert a command at a position.",
        returns = "()",
        type = "method"
      },
      RemoveCommand = {
        args = "(unsigned index)",
        description = "Remove a command by index.",
        returns = "()",
        type = "method"
      },
      RemoveCommands = {
        args = "(const String tag)",
        description = "Remove commands by tag name.",
        returns = "()",
        type = "method"
      },
      SetShaderParameter = {
        args = "(const String name, const Variant& value)",
        description = "Set a shader parameter in all commands that define it.",
        returns = "()",
        type = "method"
      },
      GetNumRenderTargets = {
        args = "()",
        description = "Return number of rendertargets.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumCommands = {
        args = "()",
        description = "Return number of commands.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCommand = {
        args = "(unsigned index)",
        returns = "(RenderPathCommand*)",
        valuetype = "RenderPathCommand",
        type = "method"
      },
      GetShaderParameter = {
        args = "(const String name)",
        description = "Return a shader parameter (first appearance in any command.)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
    },
    type = "class"
  },
  RenderPathCommand = {
    childs = {
      new = {
        args = "()",
        returns = "(RenderPathCommand*)",
        valuetype = "RenderPathCommand",
        type = "method"
      },
      Load = {
        args = "(const XMLElement& element)",
        returns = "()",
        type = "method"
      },
      SetTextureName = {
        args = "(TextureUnit unit, const String name)",
        returns = "()",
        type = "method"
      },
      SetShaderParameter = {
        args = "(const String name, const Variant& value)",
        returns = "()",
        type = "method"
      },
      RemoveShaderParameter = {
        args = "(const String name)",
        returns = "()",
        type = "method"
      },
      SetNumOutputs = {
        args = "(unsigned num)",
        returns = "()",
        type = "method"
      },
      SetOutput = {
        args = "(unsigned index, const String name, CubeMapFace face)",
        returns = "()",
        type = "method"
      },
      SetOutputName = {
        args = "(unsigned index, const String name)",
        returns = "()",
        type = "method"
      },
      SetOutputFace = {
        args = "(unsigned index, CubeMapFace face)",
        returns = "()",
        type = "method"
      },
      SetDepthStencilName = {
        args = "(const String name)",
        returns = "()",
        type = "method"
      },
      GetTextureName = {
        args = "(TextureUnit unit)",
        returns = "(const String)",
        type = "method"
      },
      GetShaderParameter = {
        args = "(const String name)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetNumOutputs = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetOutputName = {
        args = "(unsigned index)",
        returns = "(const String)",
        type = "method"
      },
      GetOutputFace = {
        args = "(unsigned index)",
        returns = "(CubeMapFace)",
        type = "method"
      },
      GetDepthStencilName = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      tag = {
        description = "String",
        type = "value"
      },
      type = {
        description = "RenderCommandType",
        type = "value"
      },
      sortMode = {
        description = "RenderCommandSortMode",
        type = "value"
      },
      pass = {
        description = "String",
        type = "value"
      },
      metadata = {
        description = "String",
        type = "value"
      },
      vertexShaderName = {
        description = "String",
        type = "value"
      },
      pixelShaderName = {
        description = "String",
        type = "value"
      },
      vertexShaderDefines = {
        description = "String",
        type = "value"
      },
      pixelShaderDefines = {
        description = "String",
        type = "value"
      },
      clearFlags = {
        description = "unsigned",
        type = "value"
      },
      clearColor = {
        description = "Color",
        type = "value"
      },
      clearDepth = {
        description = "float",
        type = "value"
      },
      clearStencil = {
        description = "unsigned",
        type = "value"
      },
      blendMode = {
        description = "BlendMode",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      useFogColor = {
        description = "bool",
        type = "value"
      },
      markToStencil = {
        description = "bool",
        type = "value"
      },
      useLitBase = {
        description = "bool",
        type = "value"
      },
      vertexLights = {
        description = "bool",
        type = "value"
      },
      eventName = {
        description = "String",
        type = "value"
      },
    },
    type = "class"
  },
  RenderSurface = {
    childs = {
      new = {
        args = "(Texture* parentTexture)",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetNumViewports = {
        args = "(unsigned num)",
        description = "Set number of viewports.",
        returns = "()",
        type = "method"
      },
      SetViewport = {
        args = "(unsigned index, Viewport* viewport)",
        description = "Set viewport.",
        returns = "()",
        type = "method"
      },
      SetUpdateMode = {
        args = "(RenderSurfaceUpdateMode mode)",
        description = "Set viewport update mode. Default is to update when visible.",
        returns = "()",
        type = "method"
      },
      SetLinkedRenderTarget = {
        args = "(RenderSurface* renderTarget)",
        description = "Set linked color rendertarget.",
        returns = "()",
        type = "method"
      },
      SetLinkedDepthStencil = {
        args = "(RenderSurface* depthStencil)",
        description = "Set linked depth-stencil surface.",
        returns = "()",
        type = "method"
      },
      QueueUpdate = {
        args = "()",
        description = "Queue manual update of the viewport(s).",
        returns = "()",
        type = "method"
      },
      Release = {
        args = "()",
        description = "Release surface.",
        returns = "()",
        type = "method"
      },
      GetParentTexture = {
        args = "()",
        description = "Return parent texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        description = "Return usage.",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetNumViewports = {
        args = "()",
        description = "Return number of viewports.",
        returns = "(unsigned)",
        type = "method"
      },
      GetViewport = {
        args = "(unsigned index)",
        description = "Return viewport by index.",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      GetUpdateMode = {
        args = "()",
        description = "Return viewport update mode.",
        returns = "(RenderSurfaceUpdateMode)",
        type = "method"
      },
      GetLinkedRenderTarget = {
        args = "()",
        description = "Return linked color rendertarget.",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      GetLinkedDepthStencil = {
        args = "()",
        description = "Return linked depth-stencil surface.",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      IsResolveDirty = {
        args = "()",
        description = "Return whether multisampled rendertarget needs resolve.",
        returns = "(bool)",
        type = "method"
      },
      parentTexture = {
        valuetype = "Texture",
        description = "(Readonly) Texture*\nParent texture.",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage",
        type = "value"
      },
      numViewports = {
        description = "unsigned",
        type = "value"
      },
      updateMode = {
        description = "RenderSurfaceUpdateMode\nUpdate mode for viewports.",
        type = "value"
      },
      linkedRenderTarget = {
        valuetype = "RenderSurface",
        description = "RenderSurface*\nLinked color buffer.",
        type = "value"
      },
      linkedDepthStencil = {
        valuetype = "RenderSurface",
        description = "RenderSurface*\nLinked depth buffer.",
        type = "value"
      },
      resolveDirty = {
        description = "(Readonly) bool\nMultisampled resolve dirty flag.",
        type = "value"
      },
    },
    type = "class"
  },
  RenderTargetInfo = {
    childs = {
      new = {
        args = "()",
        returns = "(RenderTargetInfo*)",
        valuetype = "RenderTargetInfo",
        type = "method"
      },
      Load = {
        args = "(const XMLElement& element)",
        returns = "()",
        type = "method"
      },
      name = {
        description = "String",
        type = "value"
      },
      tag = {
        description = "String",
        type = "value"
      },
      format = {
        description = "unsigned",
        type = "value"
      },
      size = {
        description = "Vector2",
        type = "value"
      },
      sizeMode = {
        description = "RenderTargetSizeMode",
        type = "value"
      },
      multiSample = {
        description = "int",
        type = "value"
      },
      autoResolve = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      cubemap = {
        description = "bool",
        type = "value"
      },
      filtered = {
        description = "bool",
        type = "value"
      },
      sRGB = {
        description = "bool",
        type = "value"
      },
      persistent = {
        description = "bool",
        type = "value"
      },
    },
    type = "class"
  },
  Renderer = {
    childs = {
      SetNumViewports = {
        args = "(unsigned num)",
        description = "Set number of backbuffer viewports to render.",
        returns = "()",
        type = "method"
      },
      SetViewport = {
        args = "(unsigned index, Viewport* viewport)",
        description = "Set a backbuffer viewport.",
        returns = "()",
        type = "method"
      },
      SetDefaultRenderPath = {
        args = "(RenderPath* renderPath)",
        description = "() SetDefaultRenderPath (XMLFile* file)\nSet default renderpath.",
        returns = "()",
        type = "method"
      },
      SetDefaultTechnique = {
        args = "(Technique* technique)",
        description = "Set default non-textured material technique.",
        returns = "()",
        type = "method"
      },
      SetHDRRendering = {
        args = "(bool enable)",
        description = "Set HDR rendering on/off.",
        returns = "()",
        type = "method"
      },
      SetSpecularLighting = {
        args = "(bool enable)",
        description = "Set specular lighting on/off.",
        returns = "()",
        type = "method"
      },
      SetTextureAnisotropy = {
        args = "(int level)",
        description = "Set default texture max anisotropy level.",
        returns = "()",
        type = "method"
      },
      SetTextureFilterMode = {
        args = "(TextureFilterMode mode)",
        description = "Set default texture filtering.",
        returns = "()",
        type = "method"
      },
      SetTextureQuality = {
        args = "(int quality)",
        description = "Set texture quality level. See the QUALITY constants in GraphicsDefs.h.",
        returns = "()",
        type = "method"
      },
      SetMaterialQuality = {
        args = "(int quality)",
        description = "Set material quality level. See the QUALITY constants in GraphicsDefs.h.",
        returns = "()",
        type = "method"
      },
      SetDrawShadows = {
        args = "(bool enable)",
        description = "Set shadows on/off.",
        returns = "()",
        type = "method"
      },
      SetShadowMapSize = {
        args = "(int size)",
        description = "Set shadow map resolution.",
        returns = "()",
        type = "method"
      },
      SetShadowQuality = {
        args = "(ShadowQuality quality)",
        description = "Set shadow quality mode. See the SHADOWQUALITY enum in GraphicsDefs.h.",
        returns = "()",
        type = "method"
      },
      SetShadowSoftness = {
        args = "(float shadowSoftness)",
        description = "Set shadow softness, only works when SHADOWQUALITY_BLUR_VSM is used.",
        returns = "()",
        type = "method"
      },
      SetVSMShadowParameters = {
        args = "(float minVariance, float lightBleedingReduction)",
        description = "Set shadow parameters when VSM is used, they help to reduce light bleeding. LightBleeding must be in [0, 1[",
        returns = "()",
        type = "method"
      },
      SetVSMMultiSample = {
        args = "(int multiSample)",
        description = "Set VSM shadow map multisampling level. Default 1 (no multisampling.)",
        returns = "()",
        type = "method"
      },
      SetReuseShadowMaps = {
        args = "(bool enable)",
        description = "Set reuse of shadow maps. Default is true. If disabled, also transparent geometry can be shadowed.",
        returns = "()",
        type = "method"
      },
      SetMaxShadowMaps = {
        args = "(int shadowMaps)",
        description = "Set maximum number of shadow maps created for one resolution. Only has effect if reuse of shadow maps is disabled.",
        returns = "()",
        type = "method"
      },
      SetDynamicInstancing = {
        args = "(bool enable)",
        description = "Set dynamic instancing on/off. When on (default), drawables using the same static-type geometry and material will be automatically combined to an instanced draw call.",
        returns = "()",
        type = "method"
      },
      SetNumExtraInstancingBufferElements = {
        args = "(int elements)",
        description = "Set number of extra instancing buffer elements. Default is 0. Extra 4-vectors are available through TEXCOORD7 and further.",
        returns = "()",
        type = "method"
      },
      SetMinInstances = {
        args = "(int instances)",
        description = "Set minimum number of instances required in a batch group to render as instanced.",
        returns = "()",
        type = "method"
      },
      SetMaxSortedInstances = {
        args = "(int instances)",
        description = "Set maximum number of sorted instances per batch group. If exceeded, instances are rendered unsorted.",
        returns = "()",
        type = "method"
      },
      SetMaxOccluderTriangles = {
        args = "(int triangles)",
        description = "Set maximum number of occluder triangles.",
        returns = "()",
        type = "method"
      },
      SetOcclusionBufferSize = {
        args = "(int size)",
        description = "Set occluder buffer width.",
        returns = "()",
        type = "method"
      },
      SetOccluderSizeThreshold = {
        args = "(float screenSize)",
        description = "Set required screen size (1.0 = full screen) for occluders.",
        returns = "()",
        type = "method"
      },
      SetThreadedOcclusion = {
        args = "(bool enable)",
        description = "Set whether to thread occluder rendering. Default false.",
        returns = "()",
        type = "method"
      },
      SetMobileShadowBiasMul = {
        args = "(float mul)",
        description = "Set shadow depth bias multiplier for mobile platforms to counteract possible worse shadow map precision. Default 1.0 (no effect.)",
        returns = "()",
        type = "method"
      },
      SetMobileShadowBiasAdd = {
        args = "(float add)",
        description = "Set shadow depth bias addition for mobile platforms to counteract possible worse shadow map precision. Default 0.0 (no effect.)",
        returns = "()",
        type = "method"
      },
      SetMobileNormalOffsetMul = {
        args = "(float mul)",
        description = "Set shadow normal offset multiplier for mobile platforms to counteract possible worse shadow map precision. Default 1.0 (no effect.)",
        returns = "()",
        type = "method"
      },
      ReloadShaders = {
        args = "()",
        description = "Force reload of shaders.",
        returns = "()",
        type = "method"
      },
      GetNumViewports = {
        args = "()",
        description = "Return number of backbuffer viewports.",
        returns = "(unsigned)",
        type = "method"
      },
      GetViewport = {
        args = "(unsigned index)",
        description = "Return backbuffer viewport by index.",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      GetDefaultRenderPath = {
        args = "()",
        description = "Return default renderpath.",
        returns = "(RenderPath*)",
        valuetype = "RenderPath",
        type = "method"
      },
      GetDefaultTechnique = {
        args = "()",
        description = "Return default non-textured material technique.",
        returns = "(Technique*)",
        valuetype = "Technique",
        type = "method"
      },
      GetHDRRendering = {
        args = "()",
        description = "Return whether HDR rendering is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetSpecularLighting = {
        args = "()",
        description = "Return whether specular lighting is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawShadows = {
        args = "()",
        description = "Return whether drawing shadows is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetTextureAnisotropy = {
        args = "()",
        description = "Return default texture max. anisotropy level.",
        returns = "(int)",
        type = "method"
      },
      GetTextureFilterMode = {
        args = "()",
        description = "Return default texture filtering mode.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetTextureQuality = {
        args = "()",
        description = "Return texture quality level.",
        returns = "(int)",
        type = "method"
      },
      GetMaterialQuality = {
        args = "()",
        description = "Return material quality level.",
        returns = "(int)",
        type = "method"
      },
      GetShadowMapSize = {
        args = "()",
        description = "Return shadow map resolution.",
        returns = "(int)",
        type = "method"
      },
      GetShadowQuality = {
        args = "()",
        description = "Return shadow quality.",
        returns = "(ShadowQuality)",
        type = "method"
      },
      GetShadowSoftness = {
        args = "()",
        description = "Return shadow softness.",
        returns = "(float)",
        type = "method"
      },
      GetVSMShadowParameters = {
        args = "()",
        description = "Return VSM shadow parameters.",
        returns = "(Vector2)",
        type = "method"
      },
      GetVSMMultiSample = {
        args = "()",
        description = "Return VSM shadow multisample level.",
        returns = "(int)",
        type = "method"
      },
      GetReuseShadowMaps = {
        args = "()",
        description = "Return whether shadow maps are reused.",
        returns = "(bool)",
        type = "method"
      },
      GetMaxShadowMaps = {
        args = "()",
        description = "Return maximum number of shadow maps per resolution.",
        returns = "(int)",
        type = "method"
      },
      GetDynamicInstancing = {
        args = "()",
        description = "Return whether dynamic instancing is in use.",
        returns = "(bool)",
        type = "method"
      },
      GetNumExtraInstancingBufferElements = {
        args = "()",
        description = "Return number of extra instancing buffer elements.",
        returns = "(int)",
        type = "method"
      },
      GetMinInstances = {
        args = "()",
        description = "Return minimum number of instances required in a batch group to render as instanced.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSortedInstances = {
        args = "()",
        description = "Return maximum number of sorted instances per batch group.",
        returns = "(int)",
        type = "method"
      },
      GetMaxOccluderTriangles = {
        args = "()",
        description = "Return maximum number of occluder triangles.",
        returns = "(int)",
        type = "method"
      },
      GetOcclusionBufferSize = {
        args = "()",
        description = "Return occlusion buffer width.",
        returns = "(int)",
        type = "method"
      },
      GetOccluderSizeThreshold = {
        args = "()",
        description = "Return occluder screen size threshold.",
        returns = "(float)",
        type = "method"
      },
      GetThreadedOcclusion = {
        args = "()",
        description = "Return whether occlusion rendering is threaded.",
        returns = "(bool)",
        type = "method"
      },
      GetMobileShadowBiasMul = {
        args = "()",
        description = "Return shadow depth bias multiplier for mobile platforms.",
        returns = "(float)",
        type = "method"
      },
      GetMobileShadowBiasAdd = {
        args = "()",
        description = "Return shadow depth bias addition for mobile platforms.",
        returns = "(float)",
        type = "method"
      },
      GetMobileNormalOffsetMul = {
        args = "()",
        description = "Return shadow normal offset multiplier for mobile platforms.",
        returns = "(float)",
        type = "method"
      },
      GetNumViews = {
        args = "()",
        description = "Return number of views rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumPrimitives = {
        args = "()",
        description = "Return number of primitives rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumBatches = {
        args = "()",
        description = "Return number of batches rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumGeometries = {
        args = "(bool allViews = false)",
        description = "Return number of geometries rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumLights = {
        args = "(bool allViews = false)",
        description = "Return number of lights rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumShadowMaps = {
        args = "(bool allViews = false)",
        description = "Return number of shadow maps rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumOccluders = {
        args = "(bool allViews = false)",
        description = "Return number of occluders rendered.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDefaultZone = {
        args = "()",
        description = "Return the default zone.",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      GetDefaultMaterial = {
        args = "()",
        description = "Return the default material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetDefaultLightRamp = {
        args = "()",
        description = "Return the default range attenuation texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetDefaultLightSpot = {
        args = "()",
        description = "Return the default spotlight attenuation texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(bool depthTest)",
        description = "Add debug geometry to the debug renderer.",
        returns = "()",
        type = "method"
      },
      numViewports = {
        description = "unsigned",
        type = "value"
      },
      defaultRenderPath = {
        valuetype = "RenderPath",
        description = "RenderPath*\nDefault renderpath.",
        type = "value"
      },
      defaultTechnique = {
        valuetype = "Technique",
        description = "Technique*\nDefault non-textured material technique.",
        type = "value"
      },
      HDRRendering = {
        description = "bool",
        type = "value"
      },
      specularLighting = {
        description = "bool\nSpecular lighting flag.",
        type = "value"
      },
      drawShadows = {
        description = "bool\nDraw shadows flag.",
        type = "value"
      },
      textureAnisotropy = {
        description = "int\nTexture anisotropy level.",
        type = "value"
      },
      textureFilterMode = {
        description = "TextureFilterMode\nTexture filtering mode.",
        type = "value"
      },
      textureQuality = {
        description = "int\nTexture quality level.",
        type = "value"
      },
      materialQuality = {
        description = "int\nMaterial quality level.",
        type = "value"
      },
      shadowMapSize = {
        description = "int\nShadow map resolution.",
        type = "value"
      },
      shadowQuality = {
        description = "ShadowQuality\nShadow quality.",
        type = "value"
      },
      shadowSoftness = {
        description = "float\nShadow softness, only works when SHADOWQUALITY_BLUR_VSM is used.",
        type = "value"
      },
      VSMMultiSample = {
        description = "int",
        type = "value"
      },
      reuseShadowMaps = {
        description = "bool\nShadow map reuse flag.",
        type = "value"
      },
      maxShadowMaps = {
        description = "int\nMaximum number of shadow maps per resolution.",
        type = "value"
      },
      dynamicInstancing = {
        description = "bool\nDynamic instancing flag.",
        type = "value"
      },
      numExtraInstancingBufferElements = {
        description = "int\nNumber of extra instancing data elements.",
        type = "value"
      },
      minInstances = {
        description = "int\nMinimum number of instances required in a batch group to render as instanced.",
        type = "value"
      },
      maxSortedInstances = {
        description = "int\nMaximum sorted instances per batch group.",
        type = "value"
      },
      maxOccluderTriangles = {
        description = "int\nMaximum occluder triangles.",
        type = "value"
      },
      occlusionBufferSize = {
        description = "int\nOcclusion buffer width.",
        type = "value"
      },
      occluderSizeThreshold = {
        description = "float\nOccluder screen size threshold.",
        type = "value"
      },
      threadedOcclusion = {
        description = "bool\nThreaded occlusion rendering flag.",
        type = "value"
      },
      mobileShadowBiasMul = {
        description = "float\nMobile platform shadow depth bias multiplier.",
        type = "value"
      },
      mobileShadowBiasAdd = {
        description = "float\nMobile platform shadow depth bias addition.",
        type = "value"
      },
      mobileNormalOffsetMul = {
        description = "float\nMobile platform shadow normal offset multiplier.",
        type = "value"
      },
      numViews = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numPrimitives = {
        description = "(Readonly) unsigned\nNumber of primitives (3D geometry only.)",
        type = "value"
      },
      numBatches = {
        description = "(Readonly) unsigned\nNumber of batches (3D geometry only.)",
        type = "value"
      },
      defaultZone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*\nDefault zone.",
        type = "value"
      },
      defaultMaterial = {
        valuetype = "Material",
        description = "(Readonly) Material*\nDefault material.",
        type = "value"
      },
      defaultLightRamp = {
        valuetype = "Texture2D",
        description = "(Readonly) Texture2D*\nDefault range attenuation texture.",
        type = "value"
      },
      defaultLightSpot = {
        valuetype = "Texture2D",
        description = "(Readonly) Texture2D*\nDefault spotlight attenuation texture.",
        type = "value"
      },
    },
    type = "class"
  },
  Resource = {
    childs = {
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  ResourceCache = {
    childs = {
      ReleaseAllResources = {
        args = "(bool force = false)",
        description = "Release all resources. When called with the force flag false, releases all currently unused resources.",
        returns = "()",
        type = "method"
      },
      ReloadResource = {
        args = "(Resource* resource)",
        description = "Reload a resource. Return true on success. The resource will not be removed from the cache in case of failure.",
        returns = "(bool)",
        type = "method"
      },
      ReloadResourceWithDependencies = {
        args = "(const String fileName)",
        description = "Reload a resource based on filename. Causes also reload of dependent resources if necessary.",
        returns = "()",
        type = "method"
      },
      SetMemoryBudget = {
        args = "(StringHash type, long budget)",
        description = "() SetMemoryBudget (const String type, long budget)",
        returns = "()",
        type = "method"
      },
      SetAutoReloadResources = {
        args = "(bool enable)",
        description = "Enable or disable automatic reloading of resources as files are modified. Default false.",
        returns = "()",
        type = "method"
      },
      SetReturnFailedResources = {
        args = "(bool enable)",
        description = "Enable or disable returning resources that failed to load. Default false. This may be useful in editing to not lose resource ref attributes.",
        returns = "()",
        type = "method"
      },
      SetSearchPackagesFirst = {
        args = "(bool value)",
        description = "Define whether when getting resources should check package files or directories first. True for packages, false for directories.",
        returns = "()",
        type = "method"
      },
      SetFinishBackgroundResourcesMs = {
        args = "(int ms)",
        returns = "()",
        type = "method"
      },
      GetFile = {
        args = "(const String name)",
        description = "Open and return a file from the resource load paths or from inside a package file. If not found, use a fallback search with absolute path. Return null if fails. Can be called from outside the main thread.",
        returns = "(File*)",
        valuetype = "File",
        type = "method"
      },
      GetResource = {
        args = "(const String type, const String name, bool sendEventOnFailure = true)",
        returns = "(Resource*)",
        valuetype = "Resource",
        type = "method"
      },
      GetExistingResource = {
        args = "(const String type, const String name)",
        description = "Template version of returning an existing resource by name.",
        returns = "(Resource*)",
        valuetype = "Resource",
        type = "method"
      },
      BackgroundLoadResource = {
        args = "(const String type, const String name, bool sendEventOnFailure = true)",
        returns = "(bool)",
        type = "method"
      },
      GetNumBackgroundLoadResources = {
        args = "()",
        description = "Return number of pending background-loaded resources.",
        returns = "(unsigned)",
        type = "method"
      },
      GetResourceDirs = {
        args = "()",
        description = "Return added resource load directories.",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "method"
      },
      Exists = {
        args = "(const String name)",
        description = "Return whether a file exists by name.",
        returns = "(bool)",
        type = "method"
      },
      GetMemoryBudget = {
        args = "(StringHash type)",
        description = "Return memory budget for a resource type.",
        returns = "(long)",
        type = "method"
      },
      GetMemoryUse = {
        args = "(StringHash type)",
        description = "Return total memory use for a resource type.",
        returns = "(long)",
        type = "method"
      },
      GetTotalMemoryUse = {
        args = "()",
        description = "Return total memory use for all resources.",
        returns = "(long)",
        type = "method"
      },
      GetResourceFileName = {
        args = "(const String name)",
        description = "Return full absolute file name of resource if possible, or empty if not found.",
        returns = "(String)",
        type = "method"
      },
      GetAutoReloadResources = {
        args = "()",
        description = "Return whether automatic resource reloading is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetReturnFailedResources = {
        args = "()",
        description = "Return whether resources that failed to load are returned.",
        returns = "(bool)",
        type = "method"
      },
      GetSearchPackagesFirst = {
        args = "()",
        description = "Return whether when getting resources should check package files or directories first.",
        returns = "(bool)",
        type = "method"
      },
      GetFinishBackgroundResourcesMs = {
        args = "()",
        description = "Return how many milliseconds maximum to spend on finishing background loaded resources.",
        returns = "(int)",
        type = "method"
      },
      GetPreferredResourceDir = {
        args = "(const String path)",
        description = "Return either the path itself or its parent, based on which of them has recognized resource subdirectories.",
        returns = "(String)",
        type = "method"
      },
      SanitateResourceName = {
        args = "(const String name)",
        description = "Remove unsupported constructs from the resource name to prevent ambiguity, and normalize absolute filename to resource path relative if possible.",
        returns = "(String)",
        type = "method"
      },
      SanitateResourceDirName = {
        args = "(const String name)",
        description = "Remove unnecessary constructs from a resource directory name and ensure it to be an absolute path.",
        returns = "(String)",
        type = "method"
      },
      totalMemoryUse = {
        description = "(Readonly) long",
        type = "value"
      },
      autoReloadResources = {
        description = "bool\nAutomatic resource reloading flag.",
        type = "value"
      },
      returnFailedResources = {
        description = "bool\nReturn failed resources flag.",
        type = "value"
      },
      searchPackagesFirst = {
        description = "bool\nSearch priority flag.",
        type = "value"
      },
      numBackgroundLoadResources = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      resourceDirs = {
        valuetype = "Vector<String>",
        description = "(Readonly) Vector<String>&\nResource load directories.",
        type = "value"
      },
      finishBackgroundResourcesMs = {
        description = "int\nHow many milliseconds maximum per frame to spend on finishing background loaded resources.",
        type = "value"
      },
    },
    type = "class"
  },
  ResourceRef = {
    childs = {
      new = {
        args = "()",
        description = "(ResourceRef*) new (StringHash type),\n(ResourceRef*) new (StringHash type, String name),\n(ResourceRef*) new (String type, String name),\n(ResourceRef*) new (const ResourceRef& rhs)",
        returns = "(ResourceRef*)",
        valuetype = "ResourceRef",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      type = {
        description = "StringHash",
        type = "value"
      },
      name = {
        description = "String",
        type = "value"
      },
    },
    type = "class"
  },
  ResourceRefList = {
    childs = {
      new = {
        args = "()",
        description = "(ResourceRefList*) new (StringHash type)",
        returns = "(ResourceRefList*)",
        valuetype = "ResourceRefList",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      type = {
        description = "StringHash",
        type = "value"
      },
    },
    type = "class"
  },
  RibbonTrail = {
    childs = {
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetVertexDistance = {
        args = "(float length)",
        description = "Set distance between points.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(float width)",
        description = "Set width of the tail. Only works for face camera trail type.",
        returns = "()",
        type = "method"
      },
      SetStartColor = {
        args = "(const Color& c)",
        description = "Set vertex blended color for start of trail.",
        returns = "()",
        type = "method"
      },
      SetEndColor = {
        args = "(const Color& c)",
        description = "Set vertex blended scale for end of trail.",
        returns = "()",
        type = "method"
      },
      SetStartScale = {
        args = "(float startScale)",
        description = "Set vertex blended color for start of trail.",
        returns = "()",
        type = "method"
      },
      SetEndScale = {
        args = "(float endScale)",
        description = "Set vertex blended scale for end of trail.",
        returns = "()",
        type = "method"
      },
      SetTrailType = {
        args = "(TrailType type)",
        description = "Set how the trail behave.",
        returns = "()",
        type = "method"
      },
      SetSorted = {
        args = "(bool enable)",
        description = "Set whether tails are sorted by distance. Default false.",
        returns = "()",
        type = "method"
      },
      SetLifetime = {
        args = "(float time)",
        description = "Set tail time to live.",
        returns = "()",
        type = "method"
      },
      SetEmitting = {
        args = "(bool emitting)",
        description = "Set whether trail should be emitting.",
        returns = "()",
        type = "method"
      },
      SetUpdateInvisible = {
        args = "(bool updateInvisible)",
        description = "Set whether to update when trail emiiter are not visible.",
        returns = "()",
        type = "method"
      },
      SetTailColumn = {
        args = "(unsigned tailColumn)",
        description = "Set number of column for every tails. Can be useful for fixing distortion at high angle.",
        returns = "()",
        type = "method"
      },
      SetAnimationLodBias = {
        args = "(float bias)",
        description = "Set animation LOD bias.",
        returns = "()",
        type = "method"
      },
      Commit = {
        args = "()",
        description = "Mark for bounding box and vertex buffer update. Call after modifying the trails.",
        returns = "()",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetVertexDistance = {
        args = "()",
        description = "Get distance between points.",
        returns = "(float)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Get width of the trail.",
        returns = "(float)",
        type = "method"
      },
      GetStartColor = {
        args = "()",
        description = "Get vertex blended color for start of trail.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetEndColor = {
        args = "()",
        description = "Get vertex blended color for end of trail.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetStartScale = {
        args = "()",
        description = "Get vertex blended scale for start of trail.",
        returns = "(float)",
        type = "method"
      },
      GetEndScale = {
        args = "()",
        description = "Get vertex blended scale for end of trail.",
        returns = "(float)",
        type = "method"
      },
      GetTrailType = {
        args = "()",
        description = "Return how the trail behave.",
        returns = "(TrailType)",
        type = "method"
      },
      IsSorted = {
        args = "()",
        description = "Return whether tails are sorted.",
        returns = "(bool)",
        type = "method"
      },
      GetLifetime = {
        args = "()",
        description = "Return tail time to live.",
        returns = "(float)",
        type = "method"
      },
      GetTailColumn = {
        args = "()",
        description = "Get number of column for tails.",
        returns = "(unsigned)",
        type = "method"
      },
      IsEmitting = {
        args = "()",
        description = "Return whether is currently emitting.",
        returns = "(bool)",
        type = "method"
      },
      GetUpdateInvisible = {
        args = "()",
        description = "Return whether to update when trail emitter are not visible.",
        returns = "(bool)",
        type = "method"
      },
      GetAnimationLodBias = {
        args = "()",
        description = "Return animation LOD bias.",
        returns = "(float)",
        type = "method"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      vertexDistance = {
        description = "float\nDistance between points. Basically is tail length.",
        type = "value"
      },
      width = {
        description = "float\nWidth of trail.",
        type = "value"
      },
      startColor = {
        valuetype = "Color",
        description = "Color&\nColor for start of trails.",
        type = "value"
      },
      endColor = {
        valuetype = "Color",
        description = "Color&\nColor for end of trails.",
        type = "value"
      },
      startScale = {
        description = "float\nScale for start of trails.",
        type = "value"
      },
      endScale = {
        description = "float\nEnd for start of trails.",
        type = "value"
      },
      trailType = {
        description = "TrailType\nTrail type.",
        type = "value"
      },
      sorted = {
        description = "bool\nTails sorted flag.",
        type = "value"
      },
      lifetime = {
        description = "float",
        type = "value"
      },
      tailColumn = {
        description = "unsigned\nNumber of columns for every tails.",
        type = "value"
      },
      emitting = {
        description = "bool\nCurrently emitting flag.",
        type = "value"
      },
      updateInvisible = {
        description = "bool\nUpdate when invisible flag.",
        type = "value"
      },
      animationLodBias = {
        description = "float\nAnimation LOD bias.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  RigidBody = {
    childs = {
      SetMass = {
        args = "(float mass)",
        description = "Set mass. Zero mass makes the body static.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set rigid body position in world space.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rigid body rotation in world space.",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "Set rigid body position and rotation in world space as an atomic operation.",
        returns = "()",
        type = "method"
      },
      SetLinearVelocity = {
        args = "(const Vector3& velocity)",
        description = "Set linear velocity.",
        returns = "()",
        type = "method"
      },
      SetLinearFactor = {
        args = "(const Vector3& factor)",
        description = "Set linear degrees of freedom. Use 1 to enable an axis or 0 to disable. Default is all axes enabled (1, 1, 1).",
        returns = "()",
        type = "method"
      },
      SetLinearRestThreshold = {
        args = "(float threshold)",
        description = "Set linear velocity deactivation threshold.",
        returns = "()",
        type = "method"
      },
      SetLinearDamping = {
        args = "(float damping)",
        description = "Set linear velocity damping factor.",
        returns = "()",
        type = "method"
      },
      SetAngularVelocity = {
        args = "(const Vector3& angularVelocity)",
        description = "Set angular velocity.",
        returns = "()",
        type = "method"
      },
      SetAngularFactor = {
        args = "(const Vector3& factor)",
        description = "Set angular degrees of freedom. Use 1 to enable an axis or 0 to disable. Default is all axes enabled (1, 1, 1).",
        returns = "()",
        type = "method"
      },
      SetAngularRestThreshold = {
        args = "(float threshold)",
        description = "Set angular velocity deactivation threshold.",
        returns = "()",
        type = "method"
      },
      SetAngularDamping = {
        args = "(float factor)",
        description = "Set angular velocity damping factor.",
        returns = "()",
        type = "method"
      },
      SetFriction = {
        args = "(float friction)",
        description = "Set friction coefficient.",
        returns = "()",
        type = "method"
      },
      SetAnisotropicFriction = {
        args = "(const Vector3& friction)",
        description = "Set anisotropic friction.",
        returns = "()",
        type = "method"
      },
      SetRollingFriction = {
        args = "(float friction)",
        description = "Set rolling friction coefficient.",
        returns = "()",
        type = "method"
      },
      SetRestitution = {
        args = "(float restitution)",
        description = "Set restitution coefficient.",
        returns = "()",
        type = "method"
      },
      SetContactProcessingThreshold = {
        args = "(float threshold)",
        description = "Set contact processing threshold.",
        returns = "()",
        type = "method"
      },
      SetCcdRadius = {
        args = "(float radius)",
        description = "Set continuous collision detection swept sphere radius.",
        returns = "()",
        type = "method"
      },
      SetCcdMotionThreshold = {
        args = "(float threshold)",
        description = "Set continuous collision detection motion-per-simulation-step threshold. 0 disables, which is the default.",
        returns = "()",
        type = "method"
      },
      SetUseGravity = {
        args = "(bool enable)",
        description = "Set whether gravity is applied to rigid body.",
        returns = "()",
        type = "method"
      },
      SetGravityOverride = {
        args = "(const Vector3& gravity)",
        description = "Set gravity override. If zero, uses physics world's gravity.",
        returns = "()",
        type = "method"
      },
      SetKinematic = {
        args = "(bool enable)",
        description = "Set rigid body kinematic mode. In kinematic mode forces are not applied to the rigid body.",
        returns = "()",
        type = "method"
      },
      SetTrigger = {
        args = "(bool enable)",
        description = "Set rigid body trigger mode. In trigger mode collisions are reported but do not apply forces.",
        returns = "()",
        type = "method"
      },
      SetCollisionLayer = {
        args = "(unsigned layer)",
        description = "Set collision layer.",
        returns = "()",
        type = "method"
      },
      SetCollisionMask = {
        args = "(unsigned mask)",
        description = "Set collision mask.",
        returns = "()",
        type = "method"
      },
      SetCollisionLayerAndMask = {
        args = "(unsigned layer, unsigned mask)",
        description = "Set collision group and mask.",
        returns = "()",
        type = "method"
      },
      SetCollisionEventMode = {
        args = "(CollisionEventMode mode)",
        description = "Set collision event signaling mode. Default is to signal when rigid bodies are active.",
        returns = "()",
        type = "method"
      },
      DisableMassUpdate = {
        args = "()",
        description = "Disable mass update. Call this to optimize performance when adding or editing multiple collision shapes in the same node.",
        returns = "()",
        type = "method"
      },
      EnableMassUpdate = {
        args = "()",
        description = "Re-enable mass update and recalculate the mass/inertia by calling UpdateMass(). Call when collision shape changes are finished.",
        returns = "()",
        type = "method"
      },
      ApplyForce = {
        args = "(const Vector3& force)",
        description = "() ApplyForce (const Vector3& force, const Vector3& position)\nApply force to center of mass.",
        returns = "()",
        type = "method"
      },
      ApplyTorque = {
        args = "(const Vector3& torque)",
        description = "Apply torque.",
        returns = "()",
        type = "method"
      },
      ApplyImpulse = {
        args = "(const Vector3& impulse)",
        description = "() ApplyImpulse (const Vector3& impulse, const Vector3& position)\nApply impulse to center of mass.",
        returns = "()",
        type = "method"
      },
      ApplyTorqueImpulse = {
        args = "(const Vector3& torque)",
        description = "Apply torque impulse.",
        returns = "()",
        type = "method"
      },
      ResetForces = {
        args = "()",
        description = "Reset accumulated forces.",
        returns = "()",
        type = "method"
      },
      Activate = {
        args = "()",
        description = "Activate rigid body if it was resting.",
        returns = "()",
        type = "method"
      },
      ReAddBodyToWorld = {
        args = "()",
        description = "Readd rigid body to the physics world to clean up internal state like stale contacts.",
        returns = "()",
        type = "method"
      },
      GetPhysicsWorld = {
        args = "()",
        description = "Return physics world.",
        returns = "(PhysicsWorld*)",
        valuetype = "PhysicsWorld",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return rigid body position in world space.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return rigid body rotation in world space.",
        returns = "(Quaternion)",
        type = "method"
      },
      GetLinearVelocity = {
        args = "()",
        description = "Return linear velocity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetLinearFactor = {
        args = "()",
        description = "Return linear degrees of freedom.",
        returns = "(Vector3)",
        type = "method"
      },
      GetVelocityAtPoint = {
        args = "(const Vector3& position)",
        description = "Return linear velocity at local point.",
        returns = "(Vector3)",
        type = "method"
      },
      GetLinearRestThreshold = {
        args = "()",
        description = "Return linear velocity deactivation threshold.",
        returns = "(float)",
        type = "method"
      },
      GetLinearDamping = {
        args = "()",
        description = "Return linear velocity damping factor.",
        returns = "(float)",
        type = "method"
      },
      GetAngularVelocity = {
        args = "()",
        description = "Return angular velocity.",
        returns = "(Vector3)",
        type = "method"
      },
      GetAngularFactor = {
        args = "()",
        description = "Return angular degrees of freedom.",
        returns = "(Vector3)",
        type = "method"
      },
      GetAngularRestThreshold = {
        args = "()",
        description = "Return angular velocity deactivation threshold.",
        returns = "(float)",
        type = "method"
      },
      GetAngularDamping = {
        args = "()",
        description = "Return angular velocity damping factor.",
        returns = "(float)",
        type = "method"
      },
      GetFriction = {
        args = "()",
        description = "Return friction coefficient.",
        returns = "(float)",
        type = "method"
      },
      GetAnisotropicFriction = {
        args = "()",
        description = "Return anisotropic friction.",
        returns = "(Vector3)",
        type = "method"
      },
      GetRollingFriction = {
        args = "()",
        description = "Return rolling friction coefficient.",
        returns = "(float)",
        type = "method"
      },
      GetRestitution = {
        args = "()",
        description = "Return restitution coefficient.",
        returns = "(float)",
        type = "method"
      },
      GetContactProcessingThreshold = {
        args = "()",
        description = "Return contact processing threshold.",
        returns = "(float)",
        type = "method"
      },
      GetCcdRadius = {
        args = "()",
        description = "Return continuous collision detection swept sphere radius.",
        returns = "(float)",
        type = "method"
      },
      GetCcdMotionThreshold = {
        args = "()",
        description = "Return continuous collision detection motion-per-simulation-step threshold.",
        returns = "(float)",
        type = "method"
      },
      GetUseGravity = {
        args = "()",
        description = "Return whether rigid body uses gravity.",
        returns = "(bool)",
        type = "method"
      },
      GetGravityOverride = {
        args = "()",
        description = "Return gravity override. If zero (default), uses the physics world's gravity.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetCenterOfMass = {
        args = "()",
        description = "Return center of mass offset.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      IsKinematic = {
        args = "()",
        description = "Return kinematic mode flag.",
        returns = "(bool)",
        type = "method"
      },
      IsTrigger = {
        args = "()",
        description = "Return whether this RigidBody is acting as a trigger.",
        returns = "(bool)",
        type = "method"
      },
      IsActive = {
        args = "()",
        description = "Return whether rigid body is active (not sleeping.)",
        returns = "(bool)",
        type = "method"
      },
      GetCollisionLayer = {
        args = "()",
        description = "Return collision layer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCollisionMask = {
        args = "()",
        description = "Return collision mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCollisionEventMode = {
        args = "()",
        description = "Return collision event signaling mode.",
        returns = "(CollisionEventMode)",
        type = "method"
      },
      physicsWorld = {
        valuetype = "PhysicsWorld",
        description = "(Readonly) PhysicsWorld*\nPhysics world.",
        type = "value"
      },
      mass = {
        description = "float\nMass.",
        type = "value"
      },
      position = {
        description = "Vector3",
        type = "value"
      },
      rotation = {
        description = "Quaternion",
        type = "value"
      },
      linearVelocity = {
        description = "Vector3",
        type = "value"
      },
      linearFactor = {
        description = "Vector3",
        type = "value"
      },
      linearRestThreshold = {
        description = "float",
        type = "value"
      },
      linearDamping = {
        description = "float",
        type = "value"
      },
      angularVelocity = {
        description = "Vector3",
        type = "value"
      },
      angularFactor = {
        description = "Vector3",
        type = "value"
      },
      angularRestThreshold = {
        description = "float",
        type = "value"
      },
      angularDamping = {
        description = "float",
        type = "value"
      },
      friction = {
        description = "float",
        type = "value"
      },
      anisotropicFriction = {
        description = "Vector3",
        type = "value"
      },
      rollingFriction = {
        description = "float",
        type = "value"
      },
      restitution = {
        description = "float",
        type = "value"
      },
      contactProcessingThreshold = {
        description = "float",
        type = "value"
      },
      ccdRadius = {
        description = "float",
        type = "value"
      },
      ccdMotionThreshold = {
        description = "float",
        type = "value"
      },
      useGravity = {
        description = "bool\nUse gravity flag.",
        type = "value"
      },
      gravityOverride = {
        valuetype = "Vector3",
        description = "Vector3&\nGravity override vector.",
        type = "value"
      },
      centerOfMass = {
        valuetype = "Vector3",
        description = "(Readonly) Vector3&\nCenter of mass offset.",
        type = "value"
      },
      kinematic = {
        description = "bool\nKinematic flag.",
        type = "value"
      },
      trigger = {
        description = "bool\nTrigger flag.",
        type = "value"
      },
      active = {
        description = "(Readonly) bool",
        type = "value"
      },
      collisionLayer = {
        description = "unsigned\nCollision layer.",
        type = "value"
      },
      collisionMask = {
        description = "unsigned\nCollision mask.",
        type = "value"
      },
      collisionEventMode = {
        description = "CollisionEventMode\nCollision event signaling mode.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  RigidBody2D = {
    childs = {
      SetBodyType = {
        args = "(BodyType2D bodyType)",
        description = "Set body type.",
        returns = "()",
        type = "method"
      },
      SetMass = {
        args = "(float mass)",
        description = "Set mass.",
        returns = "()",
        type = "method"
      },
      SetInertia = {
        args = "(float inertia)",
        description = "Set inertia.",
        returns = "()",
        type = "method"
      },
      SetMassCenter = {
        args = "(const Vector2& center)",
        description = "Set mass center.",
        returns = "()",
        type = "method"
      },
      SetUseFixtureMass = {
        args = "(bool useFixtureMass)",
        description = "Set whether to automatically calculate mass and inertia from collision shapes. Default true.",
        returns = "()",
        type = "method"
      },
      SetLinearDamping = {
        args = "(float linearDamping)",
        description = "Set linear damping.",
        returns = "()",
        type = "method"
      },
      SetAngularDamping = {
        args = "(float angularDamping)",
        description = "Set angular damping.",
        returns = "()",
        type = "method"
      },
      SetAllowSleep = {
        args = "(bool allowSleep)",
        description = "Set allow sleep.",
        returns = "()",
        type = "method"
      },
      SetFixedRotation = {
        args = "(bool fixedRotation)",
        description = "Set fixed rotation.",
        returns = "()",
        type = "method"
      },
      SetBullet = {
        args = "(bool bullet)",
        description = "Set bullet mode.",
        returns = "()",
        type = "method"
      },
      SetGravityScale = {
        args = "(float gravityScale)",
        description = "Set gravity scale.",
        returns = "()",
        type = "method"
      },
      SetAwake = {
        args = "(bool awake)",
        description = "Set awake.",
        returns = "()",
        type = "method"
      },
      SetLinearVelocity = {
        args = "(const Vector2& linearVelocity)",
        description = "Set linear velocity.",
        returns = "()",
        type = "method"
      },
      SetAngularVelocity = {
        args = "(float angularVelocity)",
        description = "Set angular velocity.",
        returns = "()",
        type = "method"
      },
      ApplyForce = {
        args = "(const Vector2& force, const Vector2& point, bool wake)",
        description = "Apply force.",
        returns = "()",
        type = "method"
      },
      ApplyForceToCenter = {
        args = "(const Vector2& force, bool wake)",
        description = "Apply force to center.",
        returns = "()",
        type = "method"
      },
      ApplyTorque = {
        args = "(float torque, bool wake)",
        description = "Apply Torque.",
        returns = "()",
        type = "method"
      },
      ApplyLinearImpulse = {
        args = "(const Vector2& impulse, const Vector2& point, bool wake)",
        description = "Apply linear impulse.",
        returns = "()",
        type = "method"
      },
      ApplyLinearImpulseToCenter = {
        args = "(const Vector2& impulse, bool wake)",
        description = "Apply linear impulse to center.",
        returns = "()",
        type = "method"
      },
      ApplyAngularImpulse = {
        args = "(float impulse, bool wake)",
        description = "Apply angular impulse.",
        returns = "()",
        type = "method"
      },
      GetBodyType = {
        args = "()",
        returns = "(BodyType2D)",
        type = "method"
      },
      GetMass = {
        args = "()",
        description = "Return mass.",
        returns = "(float)",
        type = "method"
      },
      GetInertia = {
        args = "()",
        description = "Return inertia.",
        returns = "(float)",
        type = "method"
      },
      GetMassCenter = {
        args = "()",
        description = "Return mass center.",
        returns = "(Vector2)",
        type = "method"
      },
      GetUseFixtureMass = {
        args = "()",
        description = "Return whether to calculate mass and inertia from collision shapes automatically.",
        returns = "(bool)",
        type = "method"
      },
      GetLinearDamping = {
        args = "()",
        description = "Return linear damping.",
        returns = "(float)",
        type = "method"
      },
      GetAngularDamping = {
        args = "()",
        description = "Return angular damping.",
        returns = "(float)",
        type = "method"
      },
      IsAllowSleep = {
        args = "()",
        description = "Return allow sleep.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedRotation = {
        args = "()",
        description = "Return fixed rotation.",
        returns = "(bool)",
        type = "method"
      },
      IsBullet = {
        args = "()",
        description = "Return bullet mode.",
        returns = "(bool)",
        type = "method"
      },
      GetGravityScale = {
        args = "()",
        description = "Return gravity scale.",
        returns = "(float)",
        type = "method"
      },
      IsAwake = {
        args = "()",
        description = "Return awake.",
        returns = "(bool)",
        type = "method"
      },
      GetLinearVelocity = {
        args = "()",
        description = "Return linear velocity.",
        returns = "(Vector2)",
        type = "method"
      },
      GetAngularVelocity = {
        args = "()",
        description = "Return angular velocity.",
        returns = "(float)",
        type = "method"
      },
      bodyType = {
        description = "BodyType2D",
        type = "value"
      },
      mass = {
        description = "float",
        type = "value"
      },
      inertia = {
        description = "float",
        type = "value"
      },
      massCenter = {
        description = "Vector2",
        type = "value"
      },
      useFixtureMass = {
        description = "bool\nUse fixture mass (calculate mass & inertia from collision shapes automatically.)",
        type = "value"
      },
      linearDamping = {
        description = "float",
        type = "value"
      },
      angularDamping = {
        description = "float",
        type = "value"
      },
      allowSleep = {
        description = "bool",
        type = "value"
      },
      fixedRotation = {
        description = "bool",
        type = "value"
      },
      bullet = {
        description = "bool",
        type = "value"
      },
      gravityScale = {
        description = "float",
        type = "value"
      },
      awake = {
        description = "bool",
        type = "value"
      },
      linearVelocity = {
        description = "Vector2",
        type = "value"
      },
      angularVelocity = {
        description = "float",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Scene = {
    childs = {
      new = {
        args = "()",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Load = {
        args = "(File* source)",
        description = "(bool) Load (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(File* dest)",
        description = "(bool) Save (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      LoadXML = {
        args = "(File* source)",
        description = "(bool) LoadXML (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(File* dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      LoadJSON = {
        args = "(File* source)",
        description = "(bool) LoadJSON (const String fileName)",
        returns = "(bool)",
        type = "method"
      },
      SaveJSON = {
        args = "(File* dest, const String indentation = \"\t\")",
        description = "(bool) SaveJSON (const String fileName, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      Instantiate = {
        args = "(File* source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        description = "(Node*) Instantiate (const String fileName, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      InstantiateXML = {
        args = "(File* source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        description = "(Node*) InstantiateXML (const String fileName, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      LoadAsync = {
        args = "(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES)",
        description = "(bool) LoadAsync (const String fileName, LoadMode mode = LOAD_SCENE_AND_RESOURCES)\nLoad from a binary file asynchronously. Return true if started successfully. The LOAD_RESOURCES_ONLY mode can also be used to preload resources from object prefab files.",
        returns = "(bool)",
        type = "method"
      },
      LoadAsyncXML = {
        args = "(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES)",
        description = "(bool) LoadAsyncXML (const String fileName, LoadMode mode = LOAD_SCENE_AND_RESOURCES)\nLoad from an XML file asynchronously. Return true if started successfully. The LOAD_RESOURCES_ONLY mode can also be used to preload resources from object prefab files.",
        returns = "(bool)",
        type = "method"
      },
      StopAsyncLoading = {
        args = "()",
        description = "Stop asynchronous loading.",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "(bool clearReplicated = true, bool clearLocal = true)",
        description = "Clear scene completely of either replicated, local or all nodes and components.",
        returns = "()",
        type = "method"
      },
      SetUpdateEnabled = {
        args = "(bool enable)",
        description = "Enable or disable scene update.",
        returns = "()",
        type = "method"
      },
      SetTimeScale = {
        args = "(float scale)",
        description = "Set update time scale. 1.0 = real time (default.)",
        returns = "()",
        type = "method"
      },
      SetElapsedTime = {
        args = "(float time)",
        description = "Set elapsed time in seconds. This can be used to prevent inaccuracy in the timer if the scene runs for a long time.",
        returns = "()",
        type = "method"
      },
      SetSmoothingConstant = {
        args = "(float constant)",
        description = "Set network client motion smoothing constant.",
        returns = "()",
        type = "method"
      },
      SetSnapThreshold = {
        args = "(float threshold)",
        description = "Set network client motion smoothing snap threshold.",
        returns = "()",
        type = "method"
      },
      SetAsyncLoadingMs = {
        args = "(int ms)",
        description = "Set maximum milliseconds per frame to spend on async scene loading.",
        returns = "()",
        type = "method"
      },
      GetNode = {
        args = "(unsigned id)",
        description = "Return node from the whole scene by ID, or null if not found.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      IsUpdateEnabled = {
        args = "()",
        description = "Return whether updates are enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsAsyncLoading = {
        args = "()",
        description = "Return whether an asynchronous loading operation is in progress.",
        returns = "(bool)",
        type = "method"
      },
      GetAsyncProgress = {
        args = "()",
        description = "Return asynchronous loading progress between 0.0 and 1.0, or 1.0 if not in progress.",
        returns = "(float)",
        type = "method"
      },
      GetAsyncLoadMode = {
        args = "()",
        description = "Return the load mode of the current asynchronous loading operation.",
        returns = "(LoadMode)",
        type = "method"
      },
      GetFileName = {
        args = "()",
        description = "Return source file name.",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        description = "Return source file checksum.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeScale = {
        args = "()",
        description = "Return update time scale.",
        returns = "(float)",
        type = "method"
      },
      GetElapsedTime = {
        args = "()",
        description = "Return elapsed time in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetSmoothingConstant = {
        args = "()",
        description = "Return motion smoothing constant.",
        returns = "(float)",
        type = "method"
      },
      GetSnapThreshold = {
        args = "()",
        description = "Return motion smoothing snap threshold.",
        returns = "(float)",
        type = "method"
      },
      GetAsyncLoadingMs = {
        args = "()",
        description = "Return maximum milliseconds per frame to spend on async loading.",
        returns = "(int)",
        type = "method"
      },
      GetVarName = {
        args = "(StringHash hash)",
        description = "Return a node user variable name, or empty if not registered.",
        returns = "(const String)",
        type = "method"
      },
      Update = {
        args = "(float timeStep)",
        description = "Update scene. Called by HandleUpdate.",
        returns = "()",
        type = "method"
      },
      BeginThreadedUpdate = {
        args = "()",
        description = "Begin a threaded update. During threaded update components can choose to delay dirty processing.",
        returns = "()",
        type = "method"
      },
      EndThreadedUpdate = {
        args = "()",
        description = "End a threaded update. Notify components that marked themselves for delayed dirty processing.",
        returns = "()",
        type = "method"
      },
      DelayedMarkedDirty = {
        args = "(Component* component)",
        description = "Add a component to the delayed dirty notify queue. Is thread-safe.",
        returns = "()",
        type = "method"
      },
      IsThreadedUpdate = {
        args = "()",
        description = "Return threaded update flag.",
        returns = "(bool)",
        type = "method"
      },
      GetFreeNodeID = {
        args = "(CreateMode mode)",
        description = "Get free node ID, either non-local or local.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFreeComponentID = {
        args = "(CreateMode mode)",
        description = "Get free component ID, either non-local or local.",
        returns = "(unsigned)",
        type = "method"
      },
      NodeAdded = {
        args = "(Node* node)",
        description = "Node added. Assign scene pointer and add to ID map.",
        returns = "()",
        type = "method"
      },
      NodeRemoved = {
        args = "(Node* node)",
        description = "Node removed. Remove from ID map.",
        returns = "()",
        type = "method"
      },
      ComponentAdded = {
        args = "(Component* component)",
        description = "Component added. Add to ID map.",
        returns = "()",
        type = "method"
      },
      ComponentRemoved = {
        args = "(Component* component)",
        description = "Component removed. Remove from ID map.",
        returns = "()",
        type = "method"
      },
      SetVarNamesAttr = {
        args = "(const String value)",
        description = "Set node user variable reverse mappings.",
        returns = "()",
        type = "method"
      },
      GetVarNamesAttr = {
        args = "()",
        description = "Return node user variable reverse mappings.",
        returns = "(String)",
        type = "method"
      },
      PrepareNetworkUpdate = {
        args = "()",
        description = "Prepare network update by comparing attributes and marking replication states dirty as necessary.",
        returns = "()",
        type = "method"
      },
      CleanupConnection = {
        args = "(Connection* connection)",
        description = "Clean up all references to a network connection that is about to be removed.",
        returns = "()",
        type = "method"
      },
      MarkNetworkUpdate = {
        args = "(Node* node)",
        description = "() MarkNetworkUpdate (Component* component)\nMark a node for attribute check on the next network update.",
        returns = "()",
        type = "method"
      },
      MarkReplicationDirty = {
        args = "(Node* node)",
        description = "Mark a node dirty in scene replication states. The node does not need to have own replication state yet.",
        returns = "()",
        type = "method"
      },
      GetNodesWithTag = {
        args = "(const String tag)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      updateEnabled = {
        description = "bool\nUpdate enabled flag.",
        type = "value"
      },
      asyncLoading = {
        description = "(Readonly) bool\nAsynchronous loading flag.",
        type = "value"
      },
      asyncProgress = {
        description = "(Readonly) float\nAsynchronous loading progress.",
        type = "value"
      },
      asyncLoadMode = {
        description = "(Readonly) LoadMode",
        type = "value"
      },
      fileName = {
        description = "const String\nSource file name.",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned\nScene source file checksum.",
        type = "value"
      },
      timeScale = {
        description = "float\nScene update time scale.",
        type = "value"
      },
      elapsedTime = {
        description = "float\nElapsed time accumulator.",
        type = "value"
      },
      smoothingConstant = {
        description = "float\nMotion smoothing constant.",
        type = "value"
      },
      snapThreshold = {
        description = "float\nMotion smoothing snap threshold.",
        type = "value"
      },
      asyncLoadingMs = {
        description = "int\nMaximum milliseconds per frame to spend on async scene loading.",
        type = "value"
      },
      threadedUpdate = {
        description = "(Readonly) bool\nThreaded update flag.",
        type = "value"
      },
      varNamesAttr = {
        description = "String",
        type = "value"
      },
      SaveXML = {
        args = "(File* dest, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      SaveJSON = {
        args = "(File* dest, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name of the scene node. Names are not required to be unique.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector3& position)",
        description = "Set position in parent space. If the scene node is on the root level (is child of the scene itself), this is same as world space.",
        returns = "()",
        type = "method"
      },
      SetPosition2D = {
        args = "(const Vector2& position)",
        description = "() SetPosition2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(const Quaternion& rotation)",
        description = "Set rotation in parent space.",
        returns = "()",
        type = "method"
      },
      SetRotation2D = {
        args = "(float rotation)",
        returns = "()",
        type = "method"
      },
      SetDirection = {
        args = "(const Vector3& direction)",
        description = "Set forward direction in parent space. Positive Z axis equals identity rotation.",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(float scale)",
        description = "() SetScale (const Vector3& scale)\nSet uniform scale in parent space.",
        returns = "()",
        type = "method"
      },
      SetScale2D = {
        args = "(const Vector2& scale)",
        description = "() SetScale2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale),\n() SetTransform (const Vector3& position, const Quaternion& rotation, float scale),\n() SetTransform (const Matrix3x4& transform)\nSet both position and rotation in parent space as an atomic operation. This is faster than setting position and rotation separately.",
        returns = "()",
        type = "method"
      },
      SetTransform2D = {
        args = "(const Vector2& position, float rotation)",
        description = "() SetTransform2D (const Vector2& position, float rotation, const Vector2& scale),\n() SetTransform2D (const Vector2& position, float rotation, float scale)",
        returns = "()",
        type = "method"
      },
      SetWorldPosition = {
        args = "(const Vector3& position)",
        returns = "()",
        type = "method"
      },
      SetWorldPosition2D = {
        args = "(const Vector2& position)",
        description = "() SetWorldPosition2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetWorldRotation = {
        args = "(const Quaternion& rotation)",
        returns = "()",
        type = "method"
      },
      SetWorldRotation2D = {
        args = "(float rotation)",
        returns = "()",
        type = "method"
      },
      SetWorldDirection = {
        args = "(const Vector3& direction)",
        returns = "()",
        type = "method"
      },
      SetWorldScale = {
        args = "(float scale)",
        description = "() SetWorldScale (const Vector3& scale)",
        returns = "()",
        type = "method"
      },
      SetWorldScale2D = {
        args = "(const Vector2& scale)",
        description = "() SetWorldScale2D (float x, float y)",
        returns = "()",
        type = "method"
      },
      SetWorldTransform = {
        args = "(const Vector3& position, const Quaternion& rotation)",
        description = "() SetWorldTransform (const Vector3& position, const Quaternion& rotation, const Vector3& scale),\n() SetWorldTransform (const Vector3& position, const Quaternion& rotation, float scale)",
        returns = "()",
        type = "method"
      },
      SetWorldTransform2D = {
        args = "(const Vector2& position, float rotation)",
        description = "() SetWorldTransform2D (const Vector2& position, float rotation, const Vector2& scale),\n() SetWorldTransform2D (const Vector2& position, float rotation, float scale)",
        returns = "()",
        type = "method"
      },
      Translate = {
        args = "(const Vector3& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Translate2D = {
        args = "(const Vector2& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Rotate = {
        args = "(const Quaternion& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Rotate2D = {
        args = "(float delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      RotateAround = {
        args = "(const Vector3& point, const Quaternion& delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      RotateAround2D = {
        args = "(const Vector2& point, float delta, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Pitch = {
        args = "(float angle, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Yaw = {
        args = "(float angle, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      Roll = {
        args = "(float angle, TransformSpace space = TS_LOCAL)",
        returns = "()",
        type = "method"
      },
      LookAt = {
        args = "(const Vector3& target)",
        description = "(bool) LookAt (const Vector3& target, const Vector3& upAxis, TransformSpace space = TS_WORLD)",
        returns = "(bool)",
        type = "method"
      },
      Scale = {
        args = "(float scale)",
        description = "() Scale (const Vector3& scale)",
        returns = "()",
        type = "method"
      },
      Scale2D = {
        args = "(const Vector2& scale)",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        returns = "()",
        type = "method"
      },
      SetOwner = {
        args = "(Connection* owner)",
        returns = "()",
        type = "method"
      },
      MarkDirty = {
        args = "()",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0, bool temporary = false)",
        description = "(Node*) CreateChild (unsigned id, CreateMode mode, bool temporary = false)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      CreateTemporaryChild = {
        args = "(const String name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      AddChild = {
        args = "(Node* node, unsigned index = M_MAX_UNSIGNED)",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(Node* node)",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        returns = "()",
        type = "method"
      },
      RemoveChildren = {
        args = "(bool removeReplicated, bool removeLocal, bool recursive)",
        returns = "()",
        type = "method"
      },
      RemoveComponent = {
        args = "(Component* component)",
        description = "() RemoveComponent (StringHash type),\n() RemoveComponent (const String type)",
        returns = "()",
        type = "method"
      },
      RemoveComponents = {
        args = "(bool removeReplicated, bool removeLocal)",
        description = "() RemoveComponents (const String type)",
        returns = "()",
        type = "method"
      },
      RemoveAllComponents = {
        args = "()",
        returns = "()",
        type = "method"
      },
      ReorderComponent = {
        args = "(Component* component, unsigned index)",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(CreateMode mode = REPLICATED)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      Remove = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetParent = {
        args = "(Node* parent)",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        returns = "()",
        type = "method"
      },
      AddListener = {
        args = "(Component* component)",
        returns = "()",
        type = "method"
      },
      RemoveListener = {
        args = "(Component* component)",
        returns = "()",
        type = "method"
      },
      CreateComponent = {
        args = "(const String type, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      GetOrCreateComponent = {
        args = "(const String type, CreateMode mode = REPLICATED, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      CloneComponent = {
        args = "(Component* component, unsigned id = 0)",
        description = "(Component*) CloneComponent (Component* component, CreateMode mode, unsigned id = 0)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      CreateScriptObject = {
        args = "(const String scriptObjectType)",
        description = "(int) CreateScriptObject (const String fileName, const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetScriptObject = {
        args = "()",
        description = "(int) GetScriptObject (const String scriptObjectType)",
        returns = "(int)",
        type = "method"
      },
      GetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      GetParent = {
        args = "()",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsChildOf = {
        args = "(Node* node)",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetOwner = {
        args = "()",
        returns = "(Connection*)",
        valuetype = "Connection",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetPosition2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetRotation = {
        args = "()",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetRotation2D = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetDirection = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetUp = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetRight = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetScale = {
        args = "()",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetScale2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetTransform = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      GetWorldPosition = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldPosition2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetWorldRotation = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      GetWorldRotation2D = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetWorldDirection = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldUp = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldRight = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldScale = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetWorldScale2D = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      GetWorldTransform = {
        args = "()",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      LocalToWorld = {
        args = "(const Vector3& position)",
        description = "(Vector3) LocalToWorld (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      LocalToWorld2D = {
        args = "(const Vector2& vector)",
        returns = "(Vector2)",
        type = "method"
      },
      WorldToLocal = {
        args = "(const Vector3& position)",
        description = "(Vector3) WorldToLocal (const Vector4& vector)",
        returns = "(Vector3)",
        type = "method"
      },
      WorldToLocal2D = {
        args = "(const Vector2& vector)",
        returns = "(Vector2)",
        type = "method"
      },
      IsDirty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(Node*) GetChild (StringHash nameHash, bool recursive = false),\n(Node*) GetChild (unsigned index)",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetNumComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumNetworkComponents = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      HasComponent = {
        args = "(StringHash type)",
        description = "(bool) HasComponent (const String type)",
        returns = "(bool)",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetComponent = {
        args = "(const String type, bool recursive = false)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      GetParentComponent = {
        args = "(const String type, bool recursive = false)",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      GetComponents = {
        args = "(const String type, bool recursive = false)",
        returns = "(const PODVector<Component*>&)",
        valuetype = "PODVector<Component*>",
        type = "method"
      },
      GetChildren = {
        args = "(bool recursive = false)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      GetChildrenWithComponent = {
        args = "(const String type, bool recursive = false)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      LoadXML = {
        args = "(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      LoadJSON = {
        args = "(const JSONValue& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)",
        returns = "(bool)",
        type = "method"
      },
      AddComponent = {
        args = "(Component* component, unsigned id, CreateMode mode)",
        returns = "()",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        returns = "(const PODVector<Node*>&)",
        valuetype = "PODVector<Node*>",
        type = "method"
      },
      SetID = {
        args = "(unsigned id)",
        returns = "()",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      name = {
        description = "String",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      parent = {
        valuetype = "Node",
        description = "Node*",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      enabled = {
        description = "bool",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      owner = {
        valuetype = "Connection",
        description = "Connection*",
        type = "value"
      },
      position = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      position2D = {
        description = "Vector2",
        type = "value"
      },
      rotation = {
        valuetype = "Quaternion",
        description = "Quaternion&",
        type = "value"
      },
      rotation2D = {
        description = "float",
        type = "value"
      },
      direction = {
        description = "Vector3",
        type = "value"
      },
      up = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      right = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      scale = {
        valuetype = "Vector3",
        description = "Vector3&",
        type = "value"
      },
      scale2D = {
        description = "Vector2",
        type = "value"
      },
      transform = {
        description = "(Readonly) Matrix3x4",
        type = "value"
      },
      worldPosition = {
        description = "Vector3",
        type = "value"
      },
      worldPosition2D = {
        description = "Vector2",
        type = "value"
      },
      worldRotation = {
        description = "Quaternion",
        type = "value"
      },
      worldRotation2D = {
        description = "float",
        type = "value"
      },
      worldDirection = {
        description = "Vector3",
        type = "value"
      },
      worldUp = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldRight = {
        description = "(Readonly) Vector3",
        type = "value"
      },
      worldScale = {
        description = "Vector3",
        type = "value"
      },
      worldScale2D = {
        description = "Vector2",
        type = "value"
      },
      worldTransform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&",
        type = "value"
      },
      dirty = {
        description = "(Readonly) bool",
        type = "value"
      },
      numComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numNetworkComponents = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ScrollBar = {
    childs = {
      new = {
        args = "()",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetOrientation = {
        args = "(Orientation orientation)",
        description = "Set orientation type.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set slider range maximum value (minimum value is always 0.)",
        returns = "()",
        type = "method"
      },
      SetValue = {
        args = "(float value)",
        description = "Set slider current value.",
        returns = "()",
        type = "method"
      },
      ChangeValue = {
        args = "(float delta)",
        description = "Change slider current value by a delta.",
        returns = "()",
        type = "method"
      },
      SetScrollStep = {
        args = "(float step)",
        description = "Set button scroll step.",
        returns = "()",
        type = "method"
      },
      SetStepFactor = {
        args = "(float factor)",
        description = "Set button step factor, can be used to adjust the step for constant pixel size.",
        returns = "()",
        type = "method"
      },
      StepBack = {
        args = "()",
        description = "Scroll back one step.",
        returns = "()",
        type = "method"
      },
      StepForward = {
        args = "()",
        description = "Scroll forward one step.",
        returns = "()",
        type = "method"
      },
      GetOrientation = {
        args = "()",
        description = "Return scrollbar orientation.",
        returns = "(Orientation)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return slider range.",
        returns = "(float)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return slider current value.",
        returns = "(float)",
        type = "method"
      },
      GetScrollStep = {
        args = "()",
        description = "Return button scroll step.",
        returns = "(float)",
        type = "method"
      },
      GetStepFactor = {
        args = "()",
        description = "Return button step factor.",
        returns = "(float)",
        type = "method"
      },
      GetEffectiveScrollStep = {
        args = "()",
        description = "Return scroll step multiplied by factor.",
        returns = "(float)",
        type = "method"
      },
      GetBackButton = {
        args = "()",
        description = "Return back button element.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetForwardButton = {
        args = "()",
        description = "Return forward button element.",
        returns = "(Button*)",
        valuetype = "Button",
        type = "method"
      },
      GetSlider = {
        args = "()",
        description = "Return slider element.",
        returns = "(Slider*)",
        valuetype = "Slider",
        type = "method"
      },
      orientation = {
        description = "Orientation",
        type = "value"
      },
      range = {
        description = "float",
        type = "value"
      },
      value = {
        description = "float",
        type = "value"
      },
      scrollStep = {
        description = "float\nScroll step.",
        type = "value"
      },
      stepFactor = {
        description = "float\nStep factor.",
        type = "value"
      },
      effectiveScrollStep = {
        description = "(Readonly) float",
        type = "value"
      },
      backButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nBack button.",
        type = "value"
      },
      forwardButton = {
        valuetype = "Button",
        description = "(Readonly) Button*\nForward button.",
        type = "value"
      },
      slider = {
        valuetype = "Slider",
        description = "(Readonly) Slider*\nSlider.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ScrollView = {
    childs = {
      new = {
        args = "()",
        returns = "(ScrollView*)",
        valuetype = "ScrollView",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetContentElement = {
        args = "(UIElement* element)",
        description = "Set content element.",
        returns = "()",
        type = "method"
      },
      SetViewPosition = {
        args = "(const IntVector2& position)",
        description = "() SetViewPosition (int x, int y)\nSet view offset from the top-left corner.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsVisible = {
        args = "(bool horizontal, bool vertical)",
        description = "Set scrollbars' visibility manually. Disables scrollbar autoshow/hide.",
        returns = "()",
        type = "method"
      },
      SetScrollBarsAutoVisible = {
        args = "(bool enable)",
        description = "Set whether to automatically show/hide scrollbars. Default true.",
        returns = "()",
        type = "method"
      },
      SetScrollStep = {
        args = "(float step)",
        description = "Set arrow key scroll step. Also sets it on the scrollbars.",
        returns = "()",
        type = "method"
      },
      SetPageStep = {
        args = "(float step)",
        description = "Set arrow key page step.",
        returns = "()",
        type = "method"
      },
      SetScrollDeceleration = {
        args = "(float deceleration)",
        description = "Set scroll deceleration.",
        returns = "()",
        type = "method"
      },
      SetScrollSnapEpsilon = {
        args = "(float snap)",
        description = "Set scroll snap epsilon",
        returns = "()",
        type = "method"
      },
      SetAutoDisableChildren = {
        args = "(bool disable)",
        description = "Set whether child elements should be disabled while touch scrolling.",
        returns = "()",
        type = "method"
      },
      SetAutoDisableThreshold = {
        args = "(float amount)",
        description = "Set how much touch movement is needed to trigger child element disabling.",
        returns = "()",
        type = "method"
      },
      GetViewPosition = {
        args = "()",
        description = "Return view offset from the top-left corner.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetContentElement = {
        args = "()",
        description = "Return content element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetHorizontalScrollBar = {
        args = "()",
        description = "Return horizontal scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetVerticalScrollBar = {
        args = "()",
        description = "Return vertical scroll bar.",
        returns = "(ScrollBar*)",
        valuetype = "ScrollBar",
        type = "method"
      },
      GetScrollPanel = {
        args = "()",
        description = "Return scroll panel.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetScrollBarsAutoVisible = {
        args = "()",
        description = "Return whether scrollbars are automatically shown/hidden.",
        returns = "(bool)",
        type = "method"
      },
      GetScrollStep = {
        args = "()",
        description = "Return arrow key scroll step.",
        returns = "(float)",
        type = "method"
      },
      GetPageStep = {
        args = "()",
        description = "Return arrow key page step.",
        returns = "(float)",
        type = "method"
      },
      GetScrollDeceleration = {
        args = "()",
        description = "Return scroll deceleration.",
        returns = "(float)",
        type = "method"
      },
      GetScrollSnapEpsilon = {
        args = "()",
        description = "Return scroll snap epsilon",
        returns = "(float)",
        type = "method"
      },
      GetAutoDisableChildren = {
        args = "()",
        description = "Return whether child element will be disabled while touch scrolling.",
        returns = "(bool)",
        type = "method"
      },
      GetAutoDisableThreshold = {
        args = "()",
        description = "Return how much touch movement is needed to trigger child element disabling.",
        returns = "(float)",
        type = "method"
      },
      viewPosition = {
        valuetype = "IntVector2",
        description = "IntVector2&\nCurrent view offset from the top-left corner.",
        type = "value"
      },
      contentElement = {
        valuetype = "UIElement",
        description = "UIElement*\nContent element.",
        type = "value"
      },
      horizontalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nHorizontal scroll bar.",
        type = "value"
      },
      verticalScrollBar = {
        valuetype = "ScrollBar",
        description = "(Readonly) ScrollBar*\nVertical scroll bar.",
        type = "value"
      },
      scrollPanel = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nScroll panel element.",
        type = "value"
      },
      scrollBarsAutoVisible = {
        description = "bool\nAutomatically show/hide scrollbars flag.",
        type = "value"
      },
      scrollStep = {
        description = "float",
        type = "value"
      },
      pageStep = {
        description = "float\nArrow key page step.",
        type = "value"
      },
      scrollDeceleration = {
        description = "float\nScroll deceleration",
        type = "value"
      },
      scrollSnapEpsilon = {
        description = "float\nScroll snap epsilon",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Serializable = {
    childs = {
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Serializer = {
    childs = {
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        description = "Write a 32-bit integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteInt64 = {
        args = "(long value)",
        description = "Write a 64-bit integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        description = "Write a 16-bit integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        description = "Write a 32-bit unsigned integer.",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt64 = {
        args = "(long value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        description = "Write a bool.",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        description = "Write a float.",
        returns = "(bool)",
        type = "method"
      },
      WriteDouble = {
        args = "(double value)",
        description = "Write a double.",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        description = "Write an IntRect.",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        description = "Write an IntVector2.",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector3 = {
        args = "(const IntVector3& value)",
        description = "Write an IntVector3.",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        description = "Write a Rect.",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        description = "Write a Vector2.",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        description = "Write a Vector3.",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        description = "Write a Vector3 packed into 3 x 16 bits with the specified maximum absolute range.",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        description = "Write a Vector4.",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        description = "Write a quaternion.",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        description = "Write a quaternion with each component packed in 16 bits.",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3 = {
        args = "(const Matrix3& value)",
        description = "Write a Matrix3.",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3x4 = {
        args = "(const Matrix3x4& value)",
        description = "Write a Matrix3x4.",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix4 = {
        args = "(const Matrix4& value)",
        description = "Write a Matrix4.",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        description = "Write a color.",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        description = "Write a bounding box.",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        description = "Write a null-terminated string.",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        description = "Write a four-letter file ID. If the string is not long enough, spaces will be appended.",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        description = "Write a 32-bit StringHash.",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        description = "Write a resource reference.",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        description = "Write a resource reference list.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        description = "Write a variant.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        description = "Write a variant without the type information.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        description = "Write a variant vector.",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        description = "Write a variant map.",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        description = "Write a variable-length encoded unsigned integer, which can use 29 bits maximum.",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        description = "Write a 24-bit network object ID.",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        description = "Write a text line. Char codes 13 & 10 will be automatically appended.",
        returns = "(bool)",
        type = "method"
      },
    },
    type = "class"
  },
  Skeleton = {
    childs = {
      GetNumBones = {
        args = "()",
        description = "Return number of bones.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRootBone = {
        args = "()",
        description = "Return root bone.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      GetBone = {
        args = "(const String name)",
        description = "(Bone*) GetBone (unsigned index)\nReturn bone by name.",
        returns = "(Bone*)",
        valuetype = "Bone",
        type = "method"
      },
      numBones = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      rootBone = {
        valuetype = "Bone",
        description = "(Readonly) Bone*",
        type = "value"
      },
    },
    type = "class"
  },
  Skybox = {
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    type = "class"
  },
  Slider = {
    childs = {
      new = {
        args = "()",
        returns = "(Slider*)",
        valuetype = "Slider",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetOrientation = {
        args = "(Orientation orientation)",
        description = "Set orientation type.",
        returns = "()",
        type = "method"
      },
      SetRange = {
        args = "(float range)",
        description = "Set slider range maximum value (minimum value is always 0.)",
        returns = "()",
        type = "method"
      },
      SetValue = {
        args = "(float value)",
        description = "Set slider current value.",
        returns = "()",
        type = "method"
      },
      ChangeValue = {
        args = "(float delta)",
        description = "Change value by a delta.",
        returns = "()",
        type = "method"
      },
      SetRepeatRate = {
        args = "(float rate)",
        description = "Set paging minimum repeat rate (number of events per second).",
        returns = "()",
        type = "method"
      },
      GetOrientation = {
        args = "()",
        description = "Return orientation type.",
        returns = "(Orientation)",
        type = "method"
      },
      GetRange = {
        args = "()",
        description = "Return slider range.",
        returns = "(float)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return slider current value.",
        returns = "(float)",
        type = "method"
      },
      GetKnob = {
        args = "()",
        description = "Return knob element.",
        returns = "(BorderImage*)",
        valuetype = "BorderImage",
        type = "method"
      },
      GetRepeatRate = {
        args = "()",
        description = "Return paging minimum repeat rate (number of events per second).",
        returns = "(float)",
        type = "method"
      },
      orientation = {
        description = "Orientation\nOrientation.",
        type = "value"
      },
      range = {
        description = "float\nSlider range.",
        type = "value"
      },
      value = {
        description = "float\nSlider current value.",
        type = "value"
      },
      knob = {
        valuetype = "BorderImage",
        description = "(Readonly) BorderImage*\nSlider knob.",
        type = "value"
      },
      repeatRate = {
        description = "float\nPaging repeat rate.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sound = {
    childs = {
      new = {
        args = "()",
        returns = "(Sound*)",
        valuetype = "Sound",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      LoadRaw = {
        args = "(Deserializer& source)",
        description = "(bool) LoadRaw (const String fileName)\nLoad raw sound data.",
        returns = "(bool)",
        type = "method"
      },
      LoadWav = {
        args = "(Deserializer& source)",
        description = "(bool) LoadWav (const String fileName)\nLoad WAV format sound data.",
        returns = "(bool)",
        type = "method"
      },
      LoadOggVorbis = {
        args = "(Deserializer& source)",
        description = "(bool) LoadOggVorbis (const String fileName)\nLoad Ogg Vorbis format sound data. Does not decode at load, but will rather be decoded while playing.",
        returns = "(bool)",
        type = "method"
      },
      SetSize = {
        args = "(unsigned dataSize)",
        description = "Set sound size in bytes. Also resets the sound to be uncompressed and one-shot.",
        returns = "()",
        type = "method"
      },
      SetData = {
        args = "(const void* data, unsigned dataSize)",
        returns = "()",
        type = "method"
      },
      SetFormat = {
        args = "(unsigned frequency, bool sixteenBit, bool stereo)",
        description = "Set uncompressed sound data format.",
        returns = "()",
        type = "method"
      },
      SetLooped = {
        args = "(bool enable)",
        description = "Set loop on/off. If loop is enabled, sets the full sound as loop range.",
        returns = "()",
        type = "method"
      },
      SetLoop = {
        args = "(unsigned repeatOffset, unsigned endOffset)",
        description = "Define loop.",
        returns = "()",
        type = "method"
      },
      FixInterpolation = {
        args = "()",
        description = "Fix interpolation by copying data from loop start to loop end (looped), or adding silence (oneshot.) Called internally, does not normally need to be called, unless the sound data is modified manually on the fly.",
        returns = "()",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Return length in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetDataSize = {
        args = "()",
        description = "Return total sound data size.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSampleSize = {
        args = "()",
        description = "Return sample size.",
        returns = "(unsigned)",
        type = "method"
      },
      GetFrequency = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetIntFrequency = {
        args = "()",
        description = "Return default frequency as an integer.",
        returns = "(unsigned)",
        type = "method"
      },
      IsLooped = {
        args = "()",
        description = "Return whether is looped.",
        returns = "(bool)",
        type = "method"
      },
      IsSixteenBit = {
        args = "()",
        description = "Return whether data is sixteen bit.",
        returns = "(bool)",
        type = "method"
      },
      IsStereo = {
        args = "()",
        description = "Return whether data is stereo.",
        returns = "(bool)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether is compressed.",
        returns = "(bool)",
        type = "method"
      },
      length = {
        description = "(Readonly) float",
        type = "value"
      },
      dataSize = {
        description = "(Readonly) unsigned\nSound data size in bytes.",
        type = "value"
      },
      sampleSize = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      frequency = {
        description = "(Readonly) float\nDefault frequency.",
        type = "value"
      },
      intFrequency = {
        description = "(Readonly) int",
        type = "value"
      },
      looped = {
        description = "bool\nLooped flag.",
        type = "value"
      },
      sixteenBit = {
        description = "(Readonly) bool\nSixteen bit flag.",
        type = "value"
      },
      stereo = {
        description = "(Readonly) bool\nStereo flag.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool\nCompressed flag.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  SoundListener = {
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    type = "class"
  },
  SoundSource = {
    childs = {
      Play = {
        args = "(Sound* sound)",
        description = "() Play (Sound* sound, float frequency),\n() Play (Sound* sound, float frequency, float gain),\n() Play (Sound* sound, float frequency, float gain, float panning)\nPlay a sound.",
        returns = "()",
        type = "method"
      },
      Stop = {
        args = "()",
        description = "Stop playback.",
        returns = "()",
        type = "method"
      },
      SetSoundType = {
        args = "(const String type)",
        description = "Set sound type, determines the master gain group.",
        returns = "()",
        type = "method"
      },
      SetFrequency = {
        args = "(float frequency)",
        description = "Set frequency.",
        returns = "()",
        type = "method"
      },
      SetGain = {
        args = "(float gain)",
        description = "Set gain. 0.0 is silence, 1.0 is full volume.",
        returns = "()",
        type = "method"
      },
      SetAttenuation = {
        args = "(float attenuation)",
        description = "Set attenuation. 1.0 is unaltered. Used for distance attenuated playback.",
        returns = "()",
        type = "method"
      },
      SetPanning = {
        args = "(float panning)",
        description = "Set stereo panning. -1.0 is full left and 1.0 is full right.",
        returns = "()",
        type = "method"
      },
      SetAutoRemoveMode = {
        args = "(AutoRemoveMode mode)",
        description = "Set to remove either the sound source component or its owner node from the scene automatically on sound playback completion. Disabled by default.",
        returns = "()",
        type = "method"
      },
      GetSound = {
        args = "()",
        description = "Return sound.",
        returns = "(Sound*)",
        valuetype = "Sound",
        type = "method"
      },
      GetSoundType = {
        args = "()",
        description = "Return sound type, determines the master gain group.",
        returns = "(String)",
        type = "method"
      },
      GetTimePosition = {
        args = "()",
        description = "Return playback time position.",
        returns = "(float)",
        type = "method"
      },
      GetFrequency = {
        args = "()",
        description = "Return frequency.",
        returns = "(float)",
        type = "method"
      },
      GetGain = {
        args = "()",
        description = "Return gain.",
        returns = "(float)",
        type = "method"
      },
      GetAttenuation = {
        args = "()",
        description = "Return attenuation.",
        returns = "(float)",
        type = "method"
      },
      GetPanning = {
        args = "()",
        description = "Return stereo panning.",
        returns = "(float)",
        type = "method"
      },
      GetAutoRemoveMode = {
        args = "()",
        description = "Return automatic removal mode on sound playback completion.",
        returns = "(AutoRemoveMode)",
        type = "method"
      },
      IsPlaying = {
        args = "()",
        description = "Return whether is playing.",
        returns = "(bool)",
        type = "method"
      },
      sound = {
        valuetype = "Sound",
        description = "(Readonly) Sound*\nSound that is being played.",
        type = "value"
      },
      soundType = {
        description = "String\nSoundSource type, determines the master gain group.",
        type = "value"
      },
      timePosition = {
        description = "(Readonly) float\nPlayback time position.",
        type = "value"
      },
      frequency = {
        description = "float\nFrequency.",
        type = "value"
      },
      gain = {
        description = "float\nGain.",
        type = "value"
      },
      attenuation = {
        description = "float\nAttenuation.",
        type = "value"
      },
      panning = {
        description = "float\nStereo panning.",
        type = "value"
      },
      autoRemoveMode = {
        description = "AutoRemoveMode",
        type = "value"
      },
      playing = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  SoundSource3D = {
    childs = {
      SetDistanceAttenuation = {
        args = "(float nearDistance, float farDistance, float rolloffFactor)",
        description = "Set attenuation parameters.",
        returns = "()",
        type = "method"
      },
      SetAngleAttenuation = {
        args = "(float innerAngle, float outerAngle)",
        description = "Set angle attenuation parameters.",
        returns = "()",
        type = "method"
      },
      SetNearDistance = {
        args = "(float distance)",
        description = "Set near distance. Inside this range sound will not be attenuated.",
        returns = "()",
        type = "method"
      },
      SetFarDistance = {
        args = "(float distance)",
        description = "Set far distance. Outside this range sound will be completely attenuated.",
        returns = "()",
        type = "method"
      },
      SetInnerAngle = {
        args = "(float angle)",
        description = "Set inner angle in degrees. Inside this angle sound will not be attenuated.By default 360, meaning direction never has an effect.",
        returns = "()",
        type = "method"
      },
      SetOuterAngle = {
        args = "(float angle)",
        description = "Set outer angle in degrees. Outside this angle sound will be completely attenuated. By default 360, meaning direction never has an effect.",
        returns = "()",
        type = "method"
      },
      SetRolloffFactor = {
        args = "(float factor)",
        description = "Set rolloff power factor, defines attenuation function shape.",
        returns = "()",
        type = "method"
      },
      CalculateAttenuation = {
        args = "()",
        description = "Calculate attenuation and panning based on current position and listener position.",
        returns = "()",
        type = "method"
      },
      GetNearDistance = {
        args = "()",
        description = "Return near distance.",
        returns = "(float)",
        type = "method"
      },
      GetFarDistance = {
        args = "()",
        description = "Return far distance.",
        returns = "(float)",
        type = "method"
      },
      GetInnerAngle = {
        args = "()",
        description = "Return inner angle in degrees.",
        returns = "(float)",
        type = "method"
      },
      GetOuterAngle = {
        args = "()",
        description = "Return outer angle in degrees.",
        returns = "(float)",
        type = "method"
      },
      RollAngleoffFactor = {
        args = "()",
        description = "Return rolloff power factor.",
        returns = "(float)",
        type = "method"
      },
      nearDistance = {
        description = "float\nNear distance.",
        type = "value"
      },
      farDistance = {
        description = "float\nFar distance.",
        type = "value"
      },
      innerAngle = {
        description = "float\nInner angle for directional attenuation.",
        type = "value"
      },
      outerAngle = {
        description = "float\nOuter angle for directional attenuation.",
        type = "value"
      },
      rolloffFactor = {
        description = "float\nRolloff power factor.",
        type = "value"
      },
      Play = {
        args = "(Sound* sound)",
        description = "() Play (Sound* sound, float frequency),\n() Play (Sound* sound, float frequency, float gain),\n() Play (Sound* sound, float frequency, float gain, float panning)\nPlay a sound.",
        returns = "()",
        type = "method"
      },
      Stop = {
        args = "()",
        description = "Stop playback.",
        returns = "()",
        type = "method"
      },
      SetSoundType = {
        args = "(const String type)",
        description = "Set sound type, determines the master gain group.",
        returns = "()",
        type = "method"
      },
      SetFrequency = {
        args = "(float frequency)",
        description = "Set frequency.",
        returns = "()",
        type = "method"
      },
      SetGain = {
        args = "(float gain)",
        description = "Set gain. 0.0 is silence, 1.0 is full volume.",
        returns = "()",
        type = "method"
      },
      SetAttenuation = {
        args = "(float attenuation)",
        description = "Set attenuation. 1.0 is unaltered. Used for distance attenuated playback.",
        returns = "()",
        type = "method"
      },
      SetPanning = {
        args = "(float panning)",
        description = "Set stereo panning. -1.0 is full left and 1.0 is full right.",
        returns = "()",
        type = "method"
      },
      SetAutoRemoveMode = {
        args = "(AutoRemoveMode mode)",
        description = "Set to remove either the sound source component or its owner node from the scene automatically on sound playback completion. Disabled by default.",
        returns = "()",
        type = "method"
      },
      GetSound = {
        args = "()",
        description = "Return sound.",
        returns = "(Sound*)",
        valuetype = "Sound",
        type = "method"
      },
      GetSoundType = {
        args = "()",
        description = "Return sound type, determines the master gain group.",
        returns = "(String)",
        type = "method"
      },
      GetTimePosition = {
        args = "()",
        description = "Return playback time position.",
        returns = "(float)",
        type = "method"
      },
      GetFrequency = {
        args = "()",
        description = "Return frequency.",
        returns = "(float)",
        type = "method"
      },
      GetGain = {
        args = "()",
        description = "Return gain.",
        returns = "(float)",
        type = "method"
      },
      GetAttenuation = {
        args = "()",
        description = "Return attenuation.",
        returns = "(float)",
        type = "method"
      },
      GetPanning = {
        args = "()",
        description = "Return stereo panning.",
        returns = "(float)",
        type = "method"
      },
      GetAutoRemoveMode = {
        args = "()",
        description = "Return automatic removal mode on sound playback completion.",
        returns = "(AutoRemoveMode)",
        type = "method"
      },
      IsPlaying = {
        args = "()",
        description = "Return whether is playing.",
        returns = "(bool)",
        type = "method"
      },
      sound = {
        valuetype = "Sound",
        description = "(Readonly) Sound*\nSound that is being played.",
        type = "value"
      },
      soundType = {
        description = "String\nSoundSource type, determines the master gain group.",
        type = "value"
      },
      timePosition = {
        description = "(Readonly) float\nPlayback time position.",
        type = "value"
      },
      frequency = {
        description = "float\nFrequency.",
        type = "value"
      },
      gain = {
        description = "float\nGain.",
        type = "value"
      },
      attenuation = {
        description = "float\nAttenuation.",
        type = "value"
      },
      panning = {
        description = "float\nStereo panning.",
        type = "value"
      },
      autoRemoveMode = {
        description = "AutoRemoveMode",
        type = "value"
      },
      playing = {
        description = "(Readonly) bool",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sphere = {
    childs = {
      new = {
        args = "()",
        description = "(Sphere*) new (const Sphere& sphere),\n(Sphere*) new (const Vector3& center, float radius),\n(Sphere*) new (const BoundingBox& box),\n(Sphere*) new (const Frustum& frustum),\n(Sphere*) new (const Polyhedron& poly)",
        returns = "(Sphere*)",
        valuetype = "Sphere",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Define = {
        args = "(const Sphere& sphere)",
        description = "() Define (const Vector3& center, float radius),\n() Define (const BoundingBox& box),\n() Define (const Frustum& frustum),\n() Define (const Polyhedron& poly)",
        returns = "()",
        type = "method"
      },
      Merge = {
        args = "(const Vector3& point)",
        description = "() Merge (const BoundingBox& box),\n() Merge (const Frustum& frustum),\n() Merge (const Polyhedron& poly),\n() Merge (const Sphere& sphere)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Defined = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "(Intersection) IsInside (const Sphere& sphere),\n(Intersection) IsInside (const BoundingBox& box)",
        returns = "(Intersection)",
        type = "method"
      },
      IsInsideFast = {
        args = "(const Sphere& sphere)",
        description = "(Intersection) IsInsideFast (const BoundingBox& box)",
        returns = "(Intersection)",
        type = "method"
      },
      Distance = {
        args = "(const Vector3& point)",
        returns = "(float)",
        type = "method"
      },
      center = {
        description = "Vector3",
        type = "value"
      },
      radius = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Spline = {
    childs = {
      new = {
        args = "()",
        description = "(Spline*) new (InterpolationMode mode),\n(Spline*) new (const Spline& rhs)",
        returns = "(Spline*)",
        valuetype = "Spline",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      GetPoint = {
        args = "(float f)",
        returns = "(Variant)",
        type = "method"
      },
      GetKnot = {
        args = "(unsigned index)",
        returns = "(Variant)",
        type = "method"
      },
      SetKnot = {
        args = "(const Variant& knot, unsigned tolua_var_1)",
        returns = "()",
        type = "method"
      },
      AddKnot = {
        args = "(const Variant& knot)",
        description = "() AddKnot (const Variant& knot, unsigned index)",
        returns = "()",
        type = "method"
      },
      RemoveKnot = {
        args = "()",
        description = "() RemoveKnot (unsigned index)",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      interpolationMode = {
        description = "InterpolationMode",
        type = "value"
      },
    },
    type = "class"
  },
  SplinePath = {
    childs = {
      AddControlPoint = {
        args = "(Node* point, unsigned index = M_MAX_UNSIGNED)",
        description = "Add a Node to the SplinePath as a Control Point.",
        returns = "()",
        type = "method"
      },
      RemoveControlPoint = {
        args = "(Node* point)",
        description = "Remove a Node Control Point from the SplinePath.",
        returns = "()",
        type = "method"
      },
      ClearControlPoints = {
        args = "()",
        description = "Clear the Control Points from the SplinePath.",
        returns = "()",
        type = "method"
      },
      SetInterpolationMode = {
        args = "(InterpolationMode mode)",
        description = "Set the Interpolation Mode.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(float factor)",
        description = "Set the controlled Node's position on the SplinePath.",
        returns = "()",
        type = "method"
      },
      SetControlledNode = {
        args = "(Node* controlled)",
        description = "Set the Node to be moved along the SplinePath.",
        returns = "()",
        type = "method"
      },
      GetInterpolationMode = {
        args = "()",
        description = "Get the Interpolation Mode.",
        returns = "(InterpolationMode)",
        type = "method"
      },
      GetSpeed = {
        args = "()",
        description = "Get the movement Speed.",
        returns = "(float)",
        type = "method"
      },
      GetLength = {
        args = "()",
        description = "Get the length of SplinePath;",
        returns = "(float)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      GetControlledNode = {
        args = "()",
        description = "Get the controlled Node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetPoint = {
        args = "(float factor)",
        description = "Get a point on the SplinePath from 0.f to 1.f where 0 is the start and 1 is the end.",
        returns = "(Vector3)",
        type = "method"
      },
      Move = {
        args = "(float timeStep)",
        description = "Move the controlled Node to the next position along the SplinePath based off the Speed value.",
        returns = "()",
        type = "method"
      },
      Reset = {
        args = "()",
        description = "Reset movement along the path.",
        returns = "()",
        type = "method"
      },
      IsFinished = {
        args = "()",
        description = "Returns whether the movement along the SplinePath is complete.",
        returns = "(bool)",
        type = "method"
      },
      interpolationMode = {
        description = "InterpolationMode",
        type = "value"
      },
      speed = {
        description = "float\nThe Speed of movement along the Spline.",
        type = "value"
      },
      length = {
        description = "(Readonly) float\nThe length of the SplinePath.",
        type = "value"
      },
      controlledNode = {
        valuetype = "Node",
        description = "Node*\nNode to be moved along the SplinePath.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sprite = {
    childs = {
      new = {
        args = "()",
        returns = "(Sprite*)",
        valuetype = "Sprite",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const Vector2& position)",
        description = "() SetPosition (float x, float y)\nSet floating point position.",
        returns = "()",
        type = "method"
      },
      SetHotSpot = {
        args = "(const IntVector2& hotSpot)",
        description = "() SetHotSpot (int x, int y)\nSet hotspot for positioning and rotation.",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(const Vector2& scale)",
        description = "() SetScale (float x, float y),\n() SetScale (float scale)\nSet scale. Scale also affects child sprites.",
        returns = "()",
        type = "method"
      },
      SetRotation = {
        args = "(float angle)",
        description = "Set rotation angle.",
        returns = "()",
        type = "method"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return floating point position.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetHotSpot = {
        args = "()",
        description = "Return hotspot.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetScale = {
        args = "()",
        description = "Return scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetRotation = {
        args = "()",
        description = "Return rotation angle.",
        returns = "(float)",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetTransform = {
        args = "()",
        description = "Update and return rendering transform, also used to transform child sprites.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      position = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      hotSpot = {
        valuetype = "IntVector2",
        description = "IntVector2&\nHotspot for positioning and rotation.",
        type = "value"
      },
      scale = {
        valuetype = "Vector2",
        description = "Vector2&\nScale.",
        type = "value"
      },
      rotation = {
        description = "float\nRotation angle.",
        type = "value"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      transform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&\nTransform matrix.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Sprite2D = {
    childs = {
      SetTexture = {
        args = "(Texture2D* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetRectangle = {
        args = "(const IntRect& rectangle)",
        description = "Set rectangle.",
        returns = "()",
        type = "method"
      },
      SetHotSpot = {
        args = "(const Vector2& hotSpot)",
        description = "Set hot spot.",
        returns = "()",
        type = "method"
      },
      SetOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset.",
        returns = "()",
        type = "method"
      },
      SetTextureEdgeOffset = {
        args = "(float offset)",
        description = "Set texture edge offset in pixels. This affects the left/right and top/bottom edges equally to prevent edge sampling artifacts. Default 0.",
        returns = "()",
        type = "method"
      },
      SetSpriteSheet = {
        args = "(SpriteSheet2D* spriteSheet)",
        description = "Set sprite sheet.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetRectangle = {
        args = "()",
        description = "Return rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHotSpot = {
        args = "()",
        description = "Return hot spot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetOffset = {
        args = "()",
        description = "Return offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetTextureEdgeOffset = {
        args = "()",
        description = "Return texture edge offset.",
        returns = "(float)",
        type = "method"
      },
      GetSpriteSheet = {
        args = "()",
        description = "Return sprite sheet.",
        returns = "(SpriteSheet2D*)",
        valuetype = "SpriteSheet2D",
        type = "method"
      },
      texture = {
        valuetype = "Texture2D",
        description = "Texture2D*\nTexture.",
        type = "value"
      },
      rectangle = {
        description = "IntRect\nRectangle.",
        type = "value"
      },
      hotSpot = {
        description = "Vector2\nHot spot.",
        type = "value"
      },
      offset = {
        description = "IntVector2\nOffset (for trimmed sprite).",
        type = "value"
      },
      textureEdgeOffset = {
        description = "float",
        type = "value"
      },
      spriteSheet = {
        valuetype = "SpriteSheet2D",
        description = "SpriteSheet2D*\nSprite sheet.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  SpriteSheet2D = {
    childs = {
      SetTexture = {
        args = "(Texture2D* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetSprite = {
        args = "(const String name)",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      DefineSprite = {
        args = "(const String name, const IntRect& rectangle)",
        description = "() DefineSprite (const String name, const IntRect& rectangle, const Vector2& hotSpot),\n() DefineSprite (const String name, const IntRect& rectangle, const Vector2& hotSpot, const IntVector2& originSize)",
        returns = "()",
        type = "method"
      },
      texture = {
        valuetype = "Texture2D",
        description = "Texture2D*\nTexture.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  StaticModel = {
    childs = {
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  StaticModelGroup = {
    childs = {
      AddInstanceNode = {
        args = "(Node* node)",
        description = "Add an instance scene node. It does not need any drawable components of its own.",
        returns = "()",
        type = "method"
      },
      RemoveInstanceNode = {
        args = "(Node* node)",
        description = "Remove an instance scene node.",
        returns = "()",
        type = "method"
      },
      RemoveAllInstanceNodes = {
        args = "()",
        description = "Remove all instance scene nodes.",
        returns = "()",
        type = "method"
      },
      GetNumInstanceNodes = {
        args = "()",
        description = "Return number of instance nodes.",
        returns = "(unsigned)",
        type = "method"
      },
      GetInstanceNode = {
        args = "(unsigned index)",
        description = "Return instance node by index.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      numInstanceNodes = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetModel = {
        args = "(Model* model)",
        description = "Set model.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "(bool) SetMaterial (unsigned index, Material* material)\nSet material on all geometries.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set occlusion LOD level. By default (M_MAX_UNSIGNED) same as visible.",
        returns = "()",
        type = "method"
      },
      ApplyMaterialList = {
        args = "(const String fileName = String::EMPTY)",
        description = "Apply default materials from a material list file. If filename is empty (default), the model's resource name with extension .txt will be used.",
        returns = "()",
        type = "method"
      },
      GetModel = {
        args = "()",
        description = "Return model.",
        returns = "(Model*)",
        valuetype = "Model",
        type = "method"
      },
      GetNumGeometries = {
        args = "()",
        description = "Return number of geometries.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaterial = {
        args = "(unsigned index = 0)",
        description = "Return material by geometry index.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return occlusion LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Determines if the given world space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideLocal = {
        args = "(const Vector3& point)",
        description = "Determines if the given local space point is within the model geometry.",
        returns = "(bool)",
        type = "method"
      },
      model = {
        valuetype = "Model",
        description = "Model*\nModel.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      numGeometries = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nOcclusion LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  StaticSprite2D = {
    childs = {
      SetSprite = {
        args = "(Sprite2D* sprite)",
        description = "Set sprite.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetFlip = {
        args = "(bool flipX, bool flipY)",
        description = "Set flip.",
        returns = "()",
        type = "method"
      },
      SetFlipX = {
        args = "(bool flipX)",
        description = "Set flip X.",
        returns = "()",
        type = "method"
      },
      SetFlipY = {
        args = "(bool flipY)",
        description = "Set flip Y.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "Set color.",
        returns = "()",
        type = "method"
      },
      SetAlpha = {
        args = "(float alpha)",
        description = "Set alpha.",
        returns = "()",
        type = "method"
      },
      SetUseHotSpot = {
        args = "(bool useHotSpot)",
        description = "Set whether to use custom-defined hot spot.",
        returns = "()",
        type = "method"
      },
      SetHotSpot = {
        args = "(const Vector2& hotspot)",
        description = "Set hot spot.",
        returns = "()",
        type = "method"
      },
      SetUseDrawRect = {
        args = "(bool useDrawRect)",
        description = "Set whether to use custom-defined draw rectangle.",
        returns = "()",
        type = "method"
      },
      SetDrawRect = {
        args = "(const Rect& rect)",
        description = "Set draw rectangle.",
        returns = "()",
        type = "method"
      },
      SetUseTextureRect = {
        args = "(bool useTextureRect)",
        description = "Set whether to use custom-defined texture rectangle.",
        returns = "()",
        type = "method"
      },
      SetTextureRect = {
        args = "(const Rect& rect)",
        description = "Set texture rectangle.",
        returns = "()",
        type = "method"
      },
      SetCustomMaterial = {
        args = "(Material* customMaterial)",
        description = "Set custom material.",
        returns = "()",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      GetFlipX = {
        args = "()",
        description = "Return flip X.",
        returns = "(bool)",
        type = "method"
      },
      GetFlipY = {
        args = "()",
        description = "Return flip Y.",
        returns = "(bool)",
        type = "method"
      },
      GetColor = {
        args = "()",
        description = "Return color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetAlpha = {
        args = "()",
        description = "Return alpha.",
        returns = "(float)",
        type = "method"
      },
      GetUseHotSpot = {
        args = "()",
        description = "Return whether to use custom-defined hot spot.",
        returns = "(bool)",
        type = "method"
      },
      GetHotSpot = {
        args = "()",
        description = "Return hot spot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetUseDrawRect = {
        args = "()",
        description = "Return whether to use custom-defined draw rectangle.",
        returns = "(bool)",
        type = "method"
      },
      GetDrawRect = {
        args = "()",
        description = "Return draw rect.",
        returns = "(const Rect&)",
        valuetype = "Rect",
        type = "method"
      },
      GetUseTextureRect = {
        args = "()",
        description = "Return whether to use custom-defined texture rectangle.",
        returns = "(bool)",
        type = "method"
      },
      GetTextureRect = {
        args = "()",
        description = "Return texture rect.",
        returns = "(const Rect&)",
        valuetype = "Rect",
        type = "method"
      },
      GetCustomMaterial = {
        args = "()",
        description = "Return custom material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "Sprite2D*\nSprite.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode.",
        type = "value"
      },
      flipX = {
        description = "bool\nFlip X.",
        type = "value"
      },
      flipY = {
        description = "bool\nFlip Y.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColor.",
        type = "value"
      },
      alpha = {
        description = "float",
        type = "value"
      },
      useHotSpot = {
        description = "bool\nUse hot spot flag.",
        type = "value"
      },
      hotSpot = {
        description = "Vector2\nHot spot.",
        type = "value"
      },
      customMaterial = {
        valuetype = "Material",
        description = "Material*\nCustom material.",
        type = "value"
      },
      drawRect = {
        description = "Rect\nDraw rectangle.",
        type = "value"
      },
      useDrawRect = {
        description = "bool\nUse draw rectangle flag.",
        type = "value"
      },
      textureRect = {
        description = "Rect\nTexture rectangle.",
        type = "value"
      },
      useTextureRect = {
        description = "bool\nUse texture rectangle flag.",
        type = "value"
      },
      SetLayer = {
        args = "(int layer)",
        description = "Set layer.",
        returns = "()",
        type = "method"
      },
      SetOrderInLayer = {
        args = "(int orderInLayer)",
        description = "Set order in layer.",
        returns = "()",
        type = "method"
      },
      GetLayer = {
        args = "()",
        description = "Return layer.",
        returns = "(int)",
        type = "method"
      },
      GetOrderInLayer = {
        args = "()",
        description = "Return order in layer.",
        returns = "(int)",
        type = "method"
      },
      layer = {
        description = "int\nLayer.",
        type = "value"
      },
      orderInLayer = {
        description = "int\nOrder in layer.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  StringHash = {
    childs = {
      new = {
        args = "()",
        description = "(StringHash*) new (const StringHash& rhs),\n(StringHash*) new (const char* str),\n(StringHash*) new (unsigned value)",
        returns = "(StringHash*)",
        valuetype = "StringHash",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      operatorbool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Value = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ToHash = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      Calculate = {
        args = "(const char* str)",
        returns = "(unsigned)",
        type = "method"
      },
      ZERO = {
        description = "const StringHash",
        type = "value"
      },
      value = {
        description = "(Readonly) unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  Technique = {
    childs = {
      SetIsDesktop = {
        args = "(bool enable)",
        description = "Set whether requires desktop level hardware.",
        returns = "()",
        type = "method"
      },
      CreatePass = {
        args = "(const String passName)",
        description = "Create a new pass.",
        returns = "(Pass*)",
        valuetype = "Pass",
        type = "method"
      },
      RemovePass = {
        args = "(const String passName)",
        description = "Remove a pass.",
        returns = "()",
        type = "method"
      },
      ReleaseShaders = {
        args = "()",
        description = "Reset shader pointers in all passes.",
        returns = "()",
        type = "method"
      },
      Clone = {
        args = "(const String cloneName = String::EMPTY)",
        description = "Clone the technique. Passes will be deep copied to allow independent modification.",
        returns = "(Technique*)",
        valuetype = "Technique",
        type = "method"
      },
      HasPass = {
        args = "(const String type)",
        description = "Return whether has a pass by name. This overload should not be called in time-critical rendering loops; use a pre-acquired pass index instead.",
        returns = "(bool)",
        type = "method"
      },
      GetPass = {
        args = "(const String type)",
        description = "Return a pass by name, or null if not found. This overload should not be called in time-critical rendering loops; use a pre-acquired pass index instead.",
        returns = "(Pass*)",
        valuetype = "Pass",
        type = "method"
      },
      GetSupportedPass = {
        args = "(const String type)",
        returns = "(Pass*)",
        valuetype = "Pass",
        type = "method"
      },
      IsSupported = {
        args = "()",
        description = "Return whether technique is supported by the current hardware.",
        returns = "(bool)",
        type = "method"
      },
      IsDesktop = {
        args = "()",
        description = "Return whether requires desktop level hardware.",
        returns = "(bool)",
        type = "method"
      },
      GetNumPasses = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetPassTypes = {
        args = "()",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "method"
      },
      GetPasses = {
        args = "()",
        returns = "(const PODVector<Pass*>&)",
        valuetype = "PODVector<Pass*>",
        type = "method"
      },
      supported = {
        description = "(Readonly) bool",
        type = "value"
      },
      desktop = {
        description = "(Readonly) bool",
        type = "value"
      },
      numPasses = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Terrain = {
    childs = {
      SetPatchSize = {
        args = "(int size)",
        description = "Set patch quads per side. Must be a power of two.",
        returns = "()",
        type = "method"
      },
      SetSpacing = {
        args = "(const Vector3& spacing)",
        description = "Set vertex (XZ) and height (Y) spacing.",
        returns = "()",
        type = "method"
      },
      SetMaxLodLevels = {
        args = "(unsigned levels)",
        description = "Set maximum number of LOD levels for terrain patches. This can be between 1-4.",
        returns = "()",
        type = "method"
      },
      SetOcclusionLodLevel = {
        args = "(unsigned level)",
        description = "Set LOD level used for terrain patch occlusion. By default (M_MAX_UNSIGNED) the coarsest. Since the LOD level used needs to be fixed, using finer LOD levels may result in false positive occlusion in cases where the actual rendered geometry is coarser, so use with caution.",
        returns = "()",
        type = "method"
      },
      SetSmoothing = {
        args = "(bool enable)",
        description = "Set smoothing of heightmap.",
        returns = "()",
        type = "method"
      },
      SetHeightMap = {
        args = "(Image* image)",
        description = "Set heightmap image. Dimensions should be a power of two + 1. Uses 8-bit grayscale, or optionally red as MSB and green as LSB for 16-bit accuracy. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetNorthNeighbor = {
        args = "(Terrain* north)",
        description = "Set north (positive Z) neighbor terrain for seamless LOD changes across terrains.",
        returns = "()",
        type = "method"
      },
      SetSouthNeighbor = {
        args = "(Terrain* south)",
        description = "Set south (negative Z) neighbor terrain for seamless LOD changes across terrains.",
        returns = "()",
        type = "method"
      },
      SetWestNeighbor = {
        args = "(Terrain* west)",
        description = "Set west (negative X) neighbor terrain for seamless LOD changes across terrains.",
        returns = "()",
        type = "method"
      },
      SetEastNeighbor = {
        args = "(Terrain* east)",
        description = "Set east (positive X) neighbor terrain for seamless LOD changes across terrains.",
        returns = "()",
        type = "method"
      },
      SetNeighbors = {
        args = "(Terrain* north, Terrain* south, Terrain* west, Terrain* east)",
        description = "Set all neighbor terrains at once.",
        returns = "()",
        type = "method"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance for patches.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance for patches.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias for patches. Affects which terrain LOD to display.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask for patches. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask for patches. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask for patches. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask for patches. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights for patches. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag for patches.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag for patches. Occlusion uses the coarsest LOD by default.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag for patches.",
        returns = "()",
        type = "method"
      },
      ApplyHeightMap = {
        args = "()",
        description = "Apply changes from the heightmap image.",
        returns = "()",
        type = "method"
      },
      GetPatchSize = {
        args = "()",
        description = "Return patch quads per side.",
        returns = "(int)",
        type = "method"
      },
      GetSpacing = {
        args = "()",
        description = "Return vertex and height spacing.",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetNumVertices = {
        args = "()",
        description = "Return heightmap size in vertices.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetNumPatches = {
        args = "()",
        description = "Return heightmap size in patches.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxLodLevels = {
        args = "()",
        description = "Return maximum number of LOD levels for terrain patches. This can be between 1-4.",
        returns = "(unsigned)",
        type = "method"
      },
      GetOcclusionLodLevel = {
        args = "()",
        description = "Return LOD level used for occlusion.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSmoothing = {
        args = "()",
        description = "Return whether smoothing is in use.",
        returns = "(bool)",
        type = "method"
      },
      GetHeightMap = {
        args = "()",
        description = "Return heightmap image.",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetNorthNeighbor = {
        args = "()",
        description = "Return north neighbor terrain.",
        returns = "(Terrain*)",
        valuetype = "Terrain",
        type = "method"
      },
      GetSouthNeighbor = {
        args = "()",
        description = "Return south neighbor terrain.",
        returns = "(Terrain*)",
        valuetype = "Terrain",
        type = "method"
      },
      GetWestNeighbor = {
        args = "()",
        description = "Return west neighbor terrain.",
        returns = "(Terrain*)",
        valuetype = "Terrain",
        type = "method"
      },
      GetEastNeighbor = {
        args = "()",
        description = "Return east neighbor terrain.",
        returns = "(Terrain*)",
        valuetype = "Terrain",
        type = "method"
      },
      GetPatch = {
        args = "(unsigned index)",
        description = "(TerrainPatch*) GetPatch (int x, int z)\nReturn patch by index.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetNeighborPatch = {
        args = "(int x, int z)",
        description = "Return patch by patch coordinates including neighbor terrains.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetHeight = {
        args = "(const Vector3& worldPosition)",
        description = "Return height at world coordinates.",
        returns = "(float)",
        type = "method"
      },
      GetNormal = {
        args = "(const Vector3& worldPosition)",
        description = "Return normal at world coordinates.",
        returns = "(Vector3)",
        type = "method"
      },
      WorldToHeightMap = {
        args = "(const Vector3& worldPosition)",
        description = "Convert world position to heightmap pixel position. Note that the internal height data representation is reversed vertically, but in the heightmap image north is at the top.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetHeightData = {
        args = "()",
        description = "Return raw height data.",
        returns = "(SharedArrayPtr<float>)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return visible flag.",
        returns = "(bool)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      patchSize = {
        description = "int\nPatch size, quads per side.",
        type = "value"
      },
      spacing = {
        valuetype = "Vector3",
        description = "Vector3&\nVertex and height spacing.",
        type = "value"
      },
      numVertices = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nTerrain size in vertices.",
        type = "value"
      },
      numPatches = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nTerrain size in patches.",
        type = "value"
      },
      maxLodLevels = {
        description = "unsigned\nMaximum number of LOD levels.",
        type = "value"
      },
      occlusionLodLevel = {
        description = "unsigned\nLOD level used for occlusion.",
        type = "value"
      },
      smoothing = {
        description = "bool\nSmoothing enable flag.",
        type = "value"
      },
      heightMap = {
        valuetype = "Image",
        description = "Image*\nHeightmap image.",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial.",
        type = "value"
      },
      northNeighbor = {
        valuetype = "Terrain",
        description = "Terrain*",
        type = "value"
      },
      southNeighbor = {
        valuetype = "Terrain",
        description = "Terrain*",
        type = "value"
      },
      westNeighbor = {
        valuetype = "Terrain",
        description = "Terrain*",
        type = "value"
      },
      eastNeighbor = {
        valuetype = "Terrain",
        description = "Terrain*",
        type = "value"
      },
      drawDistance = {
        description = "float\nDraw distance.",
        type = "value"
      },
      shadowDistance = {
        description = "float\nShadow distance.",
        type = "value"
      },
      lodBias = {
        description = "float\nLOD bias.",
        type = "value"
      },
      viewMask = {
        description = "unsigned\nView mask.",
        type = "value"
      },
      lightMask = {
        description = "unsigned\nLight mask.",
        type = "value"
      },
      shadowMask = {
        description = "unsigned\nShadow mask.",
        type = "value"
      },
      zoneMask = {
        description = "unsigned\nZone mask.",
        type = "value"
      },
      maxLights = {
        description = "unsigned\nMaximum lights.",
        type = "value"
      },
      visible = {
        description = "(Readonly) bool\nVisible flag.",
        type = "value"
      },
      castShadows = {
        description = "bool\nShadowcaster flag.",
        type = "value"
      },
      occluder = {
        description = "bool\nOccluder flag.",
        type = "value"
      },
      occludee = {
        description = "bool\nOccludee flag.",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TerrainPatch = {
    childs = {
      SetOwner = {
        args = "(Terrain* terrain)",
        description = "Set owner terrain.",
        returns = "()",
        type = "method"
      },
      SetNeighbors = {
        args = "(TerrainPatch* north, TerrainPatch* south, TerrainPatch* west, TerrainPatch* east)",
        description = "Set neighbor patches.",
        returns = "()",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetBoundingBox = {
        args = "(const BoundingBox& box)",
        description = "Set local-space bounding box.",
        returns = "()",
        type = "method"
      },
      SetCoordinates = {
        args = "(const IntVector2& coordinates)",
        description = "Set patch coordinates.",
        returns = "()",
        type = "method"
      },
      ResetLod = {
        args = "()",
        description = "Reset to LOD level 0.",
        returns = "()",
        type = "method"
      },
      GetGeometry = {
        args = "()",
        description = "Return visible geometry.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetMaxLodGeometry = {
        args = "()",
        description = "Return max LOD geometry. Used for decals.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetOcclusionGeometry = {
        args = "()",
        description = "Return geometry used for occlusion.",
        returns = "(Geometry*)",
        valuetype = "Geometry",
        type = "method"
      },
      GetVertexBuffer = {
        args = "()",
        description = "Return vertex buffer.",
        returns = "(VertexBuffer*)",
        valuetype = "VertexBuffer",
        type = "method"
      },
      GetOwner = {
        args = "()",
        description = "Return owner terrain.",
        returns = "(Terrain*)",
        valuetype = "Terrain",
        type = "method"
      },
      GetNorthPatch = {
        args = "()",
        description = "Return north neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetSouthPatch = {
        args = "()",
        description = "Return south neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetWestPatch = {
        args = "()",
        description = "Return west neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetEastPatch = {
        args = "()",
        description = "Return east neighbor patch.",
        returns = "(TerrainPatch*)",
        valuetype = "TerrainPatch",
        type = "method"
      },
      GetCoordinates = {
        args = "()",
        description = "Return patch coordinates.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetLodLevel = {
        args = "()",
        description = "Return current LOD level.",
        returns = "(unsigned)",
        type = "method"
      },
      geometry = {
        valuetype = "Geometry",
        description = "(Readonly) Geometry*\nGeometry.",
        type = "value"
      },
      maxLodGeometry = {
        valuetype = "Geometry",
        description = "(Readonly) Geometry*\nGeometry that is locked to the max LOD level. Used for decals.",
        type = "value"
      },
      occlusionGeometry = {
        valuetype = "Geometry",
        description = "(Readonly) Geometry*\nGeometry that is used for occlusion.",
        type = "value"
      },
      vertexBuffer = {
        valuetype = "VertexBuffer",
        description = "(Readonly) VertexBuffer*\nVertex buffer.",
        type = "value"
      },
      owner = {
        valuetype = "Terrain",
        description = "Terrain*\nParent terrain.",
        type = "value"
      },
      northPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      southPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      westPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      eastPatch = {
        valuetype = "TerrainPatch",
        description = "(Readonly) TerrainPatch*",
        type = "value"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "BoundingBox&",
        type = "value"
      },
      coordinates = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPatch coordinates in the terrain. (0,0) is the northwest corner.",
        type = "value"
      },
      lodLevel = {
        description = "(Readonly) unsigned\nCurrent LOD level.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Text = {
    childs = {
      new = {
        args = "()",
        returns = "(Text*)",
        valuetype = "Text",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetFont = {
        args = "(const String fontName, int size = DEFAULT_FONT_SIZE)",
        description = "(bool) SetFont (Font* font, int size = DEFAULT_FONT_SIZE)\nSet font by looking from resource cache by name and font size. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetFontSize = {
        args = "(int size)",
        description = "Set font size only while retaining the existing font. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetText = {
        args = "(const String text)",
        description = "Set text. Text is assumed to be either ASCII or UTF8-encoded.",
        returns = "()",
        type = "method"
      },
      SetTextAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set row alignment.",
        returns = "()",
        type = "method"
      },
      SetRowSpacing = {
        args = "(float spacing)",
        description = "Set row spacing, 1.0 for original font spacing.",
        returns = "()",
        type = "method"
      },
      SetWordwrap = {
        args = "(bool enable)",
        description = "Set wordwrap. In wordwrap mode the text element will respect its current width. Otherwise it resizes itself freely.",
        returns = "()",
        type = "method"
      },
      SetSelection = {
        args = "(unsigned start, unsigned length = M_MAX_UNSIGNED)",
        description = "Set selection. When length is not provided, select until the text ends.",
        returns = "()",
        type = "method"
      },
      ClearSelection = {
        args = "()",
        description = "Clear selection.",
        returns = "()",
        type = "method"
      },
      SetSelectionColor = {
        args = "(const Color& color)",
        description = "Set selection background color. Color with 0 alpha (default) disables.",
        returns = "()",
        type = "method"
      },
      SetHoverColor = {
        args = "(const Color& color)",
        description = "Set hover background color. Color with 0 alpha (default) disables.",
        returns = "()",
        type = "method"
      },
      SetTextEffect = {
        args = "(TextEffect textEffect)",
        description = "Set text effect.",
        returns = "()",
        type = "method"
      },
      SetEffectShadowOffset = {
        args = "(const IntVector2& offset)",
        description = "Set shadow offset.",
        returns = "()",
        type = "method"
      },
      SetEffectStrokeThickness = {
        args = "(int thickness)",
        description = "Set stroke thickness.",
        returns = "()",
        type = "method"
      },
      SetEffectRoundStroke = {
        args = "(bool roundStroke)",
        description = "Set stroke rounding. Corners of the font will be rounded off in the stroke so the stroke won't have corners.",
        returns = "()",
        type = "method"
      },
      SetEffectColor = {
        args = "(const Color& effectColor)",
        description = "Set effect color.",
        returns = "()",
        type = "method"
      },
      GetAutoLocalizable = {
        args = "()",
        description = "Return auto localizable mode.",
        returns = "(bool)",
        type = "method"
      },
      SetAutoLocalizable = {
        args = "(bool enable)",
        description = "The text will be automatically translated. The text value used as string identifier.",
        returns = "()",
        type = "method"
      },
      GetFont = {
        args = "()",
        description = "Return font.",
        returns = "(Font*)",
        valuetype = "Font",
        type = "method"
      },
      GetFontSize = {
        args = "()",
        description = "Return font size.",
        returns = "(int)",
        type = "method"
      },
      GetText = {
        args = "()",
        description = "Return text.",
        returns = "(const String)",
        type = "method"
      },
      GetTextAlignment = {
        args = "()",
        description = "Return row alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetRowSpacing = {
        args = "()",
        description = "Return row spacing.",
        returns = "(float)",
        type = "method"
      },
      GetWordwrap = {
        args = "()",
        description = "Return wordwrap mode.",
        returns = "(bool)",
        type = "method"
      },
      GetSelectionStart = {
        args = "()",
        description = "Return selection start.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelectionLength = {
        args = "()",
        description = "Return selection length.",
        returns = "(unsigned)",
        type = "method"
      },
      GetSelectionColor = {
        args = "()",
        description = "Return selection background color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetHoverColor = {
        args = "()",
        description = "Return hover background color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetTextEffect = {
        args = "()",
        description = "Return text effect.",
        returns = "(TextEffect)",
        type = "method"
      },
      GetEffectShadowOffset = {
        args = "()",
        description = "Return effect shadow offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetEffectStrokeThickness = {
        args = "()",
        description = "Return effect stroke thickness.",
        returns = "(int)",
        type = "method"
      },
      GetEffectRoundStroke = {
        args = "()",
        description = "Return effect round stroke.",
        returns = "(bool)",
        type = "method"
      },
      GetEffectColor = {
        args = "()",
        description = "Return effect color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetRowHeight = {
        args = "()",
        description = "Return row height.",
        returns = "(int)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        description = "Return number of rows.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumChars = {
        args = "()",
        description = "Return number of characters.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowWidth = {
        args = "(unsigned index)",
        description = "Return width of row by index.",
        returns = "(int)",
        type = "method"
      },
      GetCharPosition = {
        args = "(unsigned index)",
        description = "Return position of character by index relative to the text element origin.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetCharSize = {
        args = "(unsigned index)",
        description = "Return size of character by index.",
        returns = "(IntVector2)",
        type = "method"
      },
      SetEffectDepthBias = {
        args = "(float bias)",
        description = "Set text effect Z bias. Zero by default, adjusted only in 3D mode.",
        returns = "()",
        type = "method"
      },
      GetEffectDepthBias = {
        args = "()",
        description = "Return effect Z bias.",
        returns = "(float)",
        type = "method"
      },
      font = {
        valuetype = "Font",
        description = "Font*\nFont.",
        type = "value"
      },
      fontSize = {
        description = "int\nFont size.",
        type = "value"
      },
      text = {
        description = "String\nUTF-8 encoded text.",
        type = "value"
      },
      textAlignment = {
        description = "HorizontalAlignment\nRow alignment.",
        type = "value"
      },
      rowSpacing = {
        description = "float\nRow spacing.",
        type = "value"
      },
      wordwrap = {
        description = "bool",
        type = "value"
      },
      autoLocalizable = {
        description = "bool\nThe text will be automatically translated.",
        type = "value"
      },
      selectionStart = {
        description = "(Readonly) unsigned\nSelection start.",
        type = "value"
      },
      selectionLength = {
        description = "(Readonly) unsigned\nSelection length.",
        type = "value"
      },
      selectionColor = {
        valuetype = "Color",
        description = "Color&\nSelection background color.",
        type = "value"
      },
      hoverColor = {
        valuetype = "Color",
        description = "Color&\nHover background color.",
        type = "value"
      },
      textEffect = {
        description = "TextEffect\nText effect.",
        type = "value"
      },
      effectShadowOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&",
        type = "value"
      },
      effectStrokeThickness = {
        description = "int",
        type = "value"
      },
      effectRoundStroke = {
        description = "bool",
        type = "value"
      },
      effectColor = {
        valuetype = "Color",
        description = "Color&\nEffect color.",
        type = "value"
      },
      rowHeight = {
        description = "(Readonly) int\nRow height.",
        type = "value"
      },
      numRows = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numChars = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Text3D = {
    childs = {
      new = {
        args = "()",
        returns = "(Text3D*)",
        valuetype = "Text3D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetFont = {
        args = "(const String fontName, int size = DEFAULT_FONT_SIZE)",
        description = "(bool) SetFont (Font* font, int size = DEFAULT_FONT_SIZE)\nSet font by looking from resource cache by name and font size. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetFontSize = {
        args = "(int size)",
        description = "Set font size only while retaining the existing font. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetMaterial = {
        args = "(Material* material)",
        description = "Set material.",
        returns = "()",
        type = "method"
      },
      SetText = {
        args = "(const String text)",
        description = "Set text. Text is assumed to be either ASCII or UTF8-encoded.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetTextAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set row alignment.",
        returns = "()",
        type = "method"
      },
      SetRowSpacing = {
        args = "(float spacing)",
        description = "Set row spacing, 1.0 for original font spacing.",
        returns = "()",
        type = "method"
      },
      SetWordwrap = {
        args = "(bool enable)",
        description = "Set wordwrap. In wordwrap mode the text element will respect its current width. Otherwise it resizes itself freely.",
        returns = "()",
        type = "method"
      },
      SetTextEffect = {
        args = "(TextEffect textEffect)",
        description = "Set text effect.",
        returns = "()",
        type = "method"
      },
      SetEffectShadowOffset = {
        args = "(const IntVector2& offset)",
        description = "Set shadow offset.",
        returns = "()",
        type = "method"
      },
      SetEffectStrokeThickness = {
        args = "(int thickness)",
        description = "Set stroke thickness.",
        returns = "()",
        type = "method"
      },
      SetEffectRoundStroke = {
        args = "(bool roundStroke)",
        description = "Set stroke rounding. Corners of the font will be rounded off in the stroke so the stroke won't have corners.",
        returns = "()",
        type = "method"
      },
      SetEffectColor = {
        args = "(const Color& effectColor)",
        description = "Set effect color.",
        returns = "()",
        type = "method"
      },
      SetEffectDepthBias = {
        args = "(float bias)",
        description = "Set effect Z bias.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set text width. Only has effect in word wrap mode.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetFixedScreenSize = {
        args = "(bool enable)",
        description = "Set whether text has fixed size on screen (pixel-perfect) regardless of distance to camera. Works best when combined with face camera rotation. Default false.",
        returns = "()",
        type = "method"
      },
      SetFaceCameraMode = {
        args = "(FaceCameraMode mode)",
        description = "Set how the text should rotate in relation to the camera. Default is to not rotate (FC_NONE.)",
        returns = "()",
        type = "method"
      },
      GetFont = {
        args = "()",
        description = "Return font.",
        returns = "(Font*)",
        valuetype = "Font",
        type = "method"
      },
      GetMaterial = {
        args = "()",
        description = "Return material.",
        returns = "(Material*)",
        valuetype = "Material",
        type = "method"
      },
      GetFontSize = {
        args = "()",
        description = "Return font size.",
        returns = "(int)",
        type = "method"
      },
      GetText = {
        args = "()",
        description = "Return text.",
        returns = "(const String)",
        type = "method"
      },
      GetTextAlignment = {
        args = "()",
        description = "Return row alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetRowSpacing = {
        args = "()",
        description = "Return row spacing.",
        returns = "(float)",
        type = "method"
      },
      GetWordwrap = {
        args = "()",
        description = "Return wordwrap mode.",
        returns = "(bool)",
        type = "method"
      },
      GetTextEffect = {
        args = "()",
        description = "Return text effect.",
        returns = "(TextEffect)",
        type = "method"
      },
      GetEffectShadowOffset = {
        args = "()",
        description = "Return effect shadow offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetEffectStrokeThickness = {
        args = "()",
        description = "Return effect stroke thickness.",
        returns = "(int)",
        type = "method"
      },
      GetEffectRoundStroke = {
        args = "()",
        description = "Return effect round stroke.",
        returns = "(bool)",
        type = "method"
      },
      GetEffectColor = {
        args = "()",
        description = "Return effect color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetEffectDepthBias = {
        args = "()",
        description = "Return effect depth bias.",
        returns = "(float)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return text width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return text height.",
        returns = "(int)",
        type = "method"
      },
      GetRowHeight = {
        args = "()",
        description = "Return row height.",
        returns = "(int)",
        type = "method"
      },
      GetNumRows = {
        args = "()",
        description = "Return number of rows.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNumChars = {
        args = "()",
        description = "Return number of characters.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowWidth = {
        args = "(unsigned index)",
        description = "Return width of row by index.",
        returns = "(int)",
        type = "method"
      },
      GetCharPosition = {
        args = "(unsigned index)",
        description = "Return position of character by index relative to the text element origin.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetCharSize = {
        args = "(unsigned index)",
        description = "Return size of character by index.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "Return corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      IsFixedScreenSize = {
        args = "()",
        description = "Return whether text has fixed screen size.",
        returns = "(bool)",
        type = "method"
      },
      GetFaceCameraMode = {
        args = "()",
        description = "Return how the text rotates in relation to the camera.",
        returns = "(FaceCameraMode)",
        type = "method"
      },
      font = {
        valuetype = "Font",
        description = "Font*",
        type = "value"
      },
      material = {
        valuetype = "Material",
        description = "Material*\nMaterial to use as a base for the text material(s).",
        type = "value"
      },
      fontSize = {
        description = "int",
        type = "value"
      },
      text = {
        description = "String\nInternally used text element.",
        type = "value"
      },
      textAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      rowSpacing = {
        description = "float",
        type = "value"
      },
      wordwrap = {
        description = "bool",
        type = "value"
      },
      textEffect = {
        description = "TextEffect",
        type = "value"
      },
      effectShadowOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&",
        type = "value"
      },
      effectStrokeThickness = {
        description = "int",
        type = "value"
      },
      effectRoundStroke = {
        description = "bool",
        type = "value"
      },
      effectColor = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      effectDepthBias = {
        description = "float",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      rowHeight = {
        description = "(Readonly) int",
        type = "value"
      },
      numRows = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      numChars = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      opacity = {
        description = "float",
        type = "value"
      },
      fixedScreenSize = {
        description = "bool\nFixed screen size flag.",
        type = "value"
      },
      faceCameraMode = {
        description = "FaceCameraMode\nText rotation mode in relation to the camera.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Texture = {
    childs = {
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        description = "Set filtering mode.",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        description = "Set addressing mode by texture coordinate.",
        returns = "()",
        type = "method"
      },
      SetAnisotropy = {
        args = "(unsigned level)",
        description = "Set texture max. anisotropy level. No effect if not using anisotropic filtering. Value 0 (default) uses the default setting from Renderer.",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        description = "Set border color for border addressing mode.",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        description = "Set sRGB sampling and writing mode.",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        description = "Set backup texture to use when rendering to this texture.",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int toSkip)",
        description = "Set mip levels to skip on a quality setting when loading. Ensures higher quality levels do not skip more.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return API-specific texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the texture format is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        description = "Return number of mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        description = "Return filtering mode.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        description = "Return addressing mode by texture coordinate.",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetAnisotropy = {
        args = "()",
        description = "Return texture max. anisotropy level. Value 0 means to use the default value from Renderer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        description = "Return border color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        description = "Return whether is using sRGB sampling and writing.",
        returns = "(bool)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        description = "Return texture multisampling level (1 = no multisampling).",
        returns = "(int)",
        type = "method"
      },
      GetAutoResolve = {
        args = "()",
        description = "Return texture multisampling autoresolve mode. When true, the texture is resolved before being sampled on SetTexture(). When false, the texture will not be resolved and must be read as individual samples in the shader.",
        returns = "(bool)",
        type = "method"
      },
      IsResolveDirty = {
        args = "()",
        description = "Return whether multisampled texture needs resolve.",
        returns = "(bool)",
        type = "method"
      },
      GetLevelsDirty = {
        args = "()",
        description = "Return whether rendertarget mipmap levels need regenration.",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        description = "Return backup texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        description = "Return mip levels to skip on a quality setting when loading.",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        description = "Return texture usage type.",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        description = "Return data size in bytes for a rectangular region.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        description = "Return data size in bytes for a pixel or block row.",
        returns = "(unsigned)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of image components required to receive pixel data from GetData(), or 0 for compressed images.",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned\nTexture format.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned\nCurrent mip levels.",
        type = "value"
      },
      width = {
        description = "(Readonly) int\nTexture width.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nTexture height.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode\nFiltering mode.",
        type = "value"
      },
      anisotropy = {
        description = "unsigned\nTexture anisotropy level.",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&\nBorder color.",
        type = "value"
      },
      sRGB = {
        description = "bool\nsRGB sampling and writing mode flag.",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int\nMultisampling level.",
        type = "value"
      },
      autoResolve = {
        description = "(Readonly) bool\nMultisampling autoresolve flag.",
        type = "value"
      },
      resolveDirty = {
        description = "(Readonly) bool\nMultisampling resolve needed -flag.",
        type = "value"
      },
      levelsDirty = {
        description = "(Readonly) bool\nMipmap levels regeneration needed -flag.",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*\nBackup texture.",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage\nTexture usage type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Texture2D = {
    childs = {
      new = {
        args = "()",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC, int multiSample = 1, bool autoResolve = true)",
        returns = "(bool)",
        type = "method"
      },
      SetData = {
        args = "(Image* image, bool useAlpha = false)",
        description = "Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.",
        returns = "(bool)",
        type = "method"
      },
      GetImage = {
        args = "()",
        description = "Get image data from zero mip level. Only RGB and RGBA textures are supported.",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      GetRenderSurface = {
        args = "()",
        description = "Return render surface.",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      renderSurface = {
        valuetype = "RenderSurface",
        description = "(Readonly) RenderSurface*\nRender surface.",
        type = "value"
      },
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        description = "Set filtering mode.",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        description = "Set addressing mode by texture coordinate.",
        returns = "()",
        type = "method"
      },
      SetAnisotropy = {
        args = "(unsigned level)",
        description = "Set texture max. anisotropy level. No effect if not using anisotropic filtering. Value 0 (default) uses the default setting from Renderer.",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        description = "Set border color for border addressing mode.",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        description = "Set sRGB sampling and writing mode.",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        description = "Set backup texture to use when rendering to this texture.",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int toSkip)",
        description = "Set mip levels to skip on a quality setting when loading. Ensures higher quality levels do not skip more.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return API-specific texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the texture format is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        description = "Return number of mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        description = "Return filtering mode.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        description = "Return addressing mode by texture coordinate.",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetAnisotropy = {
        args = "()",
        description = "Return texture max. anisotropy level. Value 0 means to use the default value from Renderer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        description = "Return border color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        description = "Return whether is using sRGB sampling and writing.",
        returns = "(bool)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        description = "Return texture multisampling level (1 = no multisampling).",
        returns = "(int)",
        type = "method"
      },
      GetAutoResolve = {
        args = "()",
        description = "Return texture multisampling autoresolve mode. When true, the texture is resolved before being sampled on SetTexture(). When false, the texture will not be resolved and must be read as individual samples in the shader.",
        returns = "(bool)",
        type = "method"
      },
      IsResolveDirty = {
        args = "()",
        description = "Return whether multisampled texture needs resolve.",
        returns = "(bool)",
        type = "method"
      },
      GetLevelsDirty = {
        args = "()",
        description = "Return whether rendertarget mipmap levels need regenration.",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        description = "Return backup texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        description = "Return mip levels to skip on a quality setting when loading.",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        description = "Return texture usage type.",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        description = "Return data size in bytes for a rectangular region.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        description = "Return data size in bytes for a pixel or block row.",
        returns = "(unsigned)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of image components required to receive pixel data from GetData(), or 0 for compressed images.",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned\nTexture format.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned\nCurrent mip levels.",
        type = "value"
      },
      width = {
        description = "(Readonly) int\nTexture width.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nTexture height.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode\nFiltering mode.",
        type = "value"
      },
      anisotropy = {
        description = "unsigned\nTexture anisotropy level.",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&\nBorder color.",
        type = "value"
      },
      sRGB = {
        description = "bool\nsRGB sampling and writing mode flag.",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int\nMultisampling level.",
        type = "value"
      },
      autoResolve = {
        description = "(Readonly) bool\nMultisampling autoresolve flag.",
        type = "value"
      },
      resolveDirty = {
        description = "(Readonly) bool\nMultisampling resolve needed -flag.",
        type = "value"
      },
      levelsDirty = {
        description = "(Readonly) bool\nMipmap levels regeneration needed -flag.",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*\nBackup texture.",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage\nTexture usage type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Texture2DArray = {
    childs = {
      new = {
        args = "()",
        returns = "(Texture2DArray*)",
        valuetype = "Texture2DArray",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetLayers = {
        args = "(unsigned layers)",
        description = "Set the number of layers in the texture. To be used before SetData.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(unsigned layers, int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC)",
        description = "Set layers, size, format and usage. Set layers to zero to leave them unchanged. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetData = {
        args = "(unsigned layer, Image* image, bool useAlpha = false)",
        description = "Set data of one layer from an image. Return true if successful. Optionally make a single channel image alpha-only.",
        returns = "(bool)",
        type = "method"
      },
      GetLayers = {
        args = "()",
        description = "Return number of layers in the texture.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRenderSurface = {
        args = "()",
        description = "Return render surface.",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      layers = {
        description = "unsigned\nTexture array layers number.",
        type = "value"
      },
      renderSurface = {
        valuetype = "RenderSurface",
        description = "(Readonly) RenderSurface*\nRender surface.",
        type = "value"
      },
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        description = "Set filtering mode.",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        description = "Set addressing mode by texture coordinate.",
        returns = "()",
        type = "method"
      },
      SetAnisotropy = {
        args = "(unsigned level)",
        description = "Set texture max. anisotropy level. No effect if not using anisotropic filtering. Value 0 (default) uses the default setting from Renderer.",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        description = "Set border color for border addressing mode.",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        description = "Set sRGB sampling and writing mode.",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        description = "Set backup texture to use when rendering to this texture.",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int toSkip)",
        description = "Set mip levels to skip on a quality setting when loading. Ensures higher quality levels do not skip more.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return API-specific texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the texture format is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        description = "Return number of mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        description = "Return filtering mode.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        description = "Return addressing mode by texture coordinate.",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetAnisotropy = {
        args = "()",
        description = "Return texture max. anisotropy level. Value 0 means to use the default value from Renderer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        description = "Return border color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        description = "Return whether is using sRGB sampling and writing.",
        returns = "(bool)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        description = "Return texture multisampling level (1 = no multisampling).",
        returns = "(int)",
        type = "method"
      },
      GetAutoResolve = {
        args = "()",
        description = "Return texture multisampling autoresolve mode. When true, the texture is resolved before being sampled on SetTexture(). When false, the texture will not be resolved and must be read as individual samples in the shader.",
        returns = "(bool)",
        type = "method"
      },
      IsResolveDirty = {
        args = "()",
        description = "Return whether multisampled texture needs resolve.",
        returns = "(bool)",
        type = "method"
      },
      GetLevelsDirty = {
        args = "()",
        description = "Return whether rendertarget mipmap levels need regenration.",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        description = "Return backup texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        description = "Return mip levels to skip on a quality setting when loading.",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        description = "Return texture usage type.",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        description = "Return data size in bytes for a rectangular region.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        description = "Return data size in bytes for a pixel or block row.",
        returns = "(unsigned)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of image components required to receive pixel data from GetData(), or 0 for compressed images.",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned\nTexture format.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned\nCurrent mip levels.",
        type = "value"
      },
      width = {
        description = "(Readonly) int\nTexture width.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nTexture height.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode\nFiltering mode.",
        type = "value"
      },
      anisotropy = {
        description = "unsigned\nTexture anisotropy level.",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&\nBorder color.",
        type = "value"
      },
      sRGB = {
        description = "bool\nsRGB sampling and writing mode flag.",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int\nMultisampling level.",
        type = "value"
      },
      autoResolve = {
        description = "(Readonly) bool\nMultisampling autoresolve flag.",
        type = "value"
      },
      resolveDirty = {
        description = "(Readonly) bool\nMultisampling resolve needed -flag.",
        type = "value"
      },
      levelsDirty = {
        description = "(Readonly) bool\nMipmap levels regeneration needed -flag.",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*\nBackup texture.",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage\nTexture usage type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Texture3D = {
    childs = {
      new = {
        args = "()",
        returns = "(Texture3D*)",
        valuetype = "Texture3D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(int width, int height, int depth, unsigned format, TextureUsage usage = TEXTURE_STATIC)",
        description = "Set size, format and usage. Zero size will follow application window size. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetData = {
        args = "(Image* image, bool useAlpha = false)",
        description = "Set data from an image. Return true if successful. Optionally make a single channel image alpha-only.",
        returns = "(bool)",
        type = "method"
      },
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        description = "Set filtering mode.",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        description = "Set addressing mode by texture coordinate.",
        returns = "()",
        type = "method"
      },
      SetAnisotropy = {
        args = "(unsigned level)",
        description = "Set texture max. anisotropy level. No effect if not using anisotropic filtering. Value 0 (default) uses the default setting from Renderer.",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        description = "Set border color for border addressing mode.",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        description = "Set sRGB sampling and writing mode.",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        description = "Set backup texture to use when rendering to this texture.",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int toSkip)",
        description = "Set mip levels to skip on a quality setting when loading. Ensures higher quality levels do not skip more.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return API-specific texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the texture format is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        description = "Return number of mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        description = "Return filtering mode.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        description = "Return addressing mode by texture coordinate.",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetAnisotropy = {
        args = "()",
        description = "Return texture max. anisotropy level. Value 0 means to use the default value from Renderer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        description = "Return border color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        description = "Return whether is using sRGB sampling and writing.",
        returns = "(bool)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        description = "Return texture multisampling level (1 = no multisampling).",
        returns = "(int)",
        type = "method"
      },
      GetAutoResolve = {
        args = "()",
        description = "Return texture multisampling autoresolve mode. When true, the texture is resolved before being sampled on SetTexture(). When false, the texture will not be resolved and must be read as individual samples in the shader.",
        returns = "(bool)",
        type = "method"
      },
      IsResolveDirty = {
        args = "()",
        description = "Return whether multisampled texture needs resolve.",
        returns = "(bool)",
        type = "method"
      },
      GetLevelsDirty = {
        args = "()",
        description = "Return whether rendertarget mipmap levels need regenration.",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        description = "Return backup texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        description = "Return mip levels to skip on a quality setting when loading.",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        description = "Return texture usage type.",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        description = "Return data size in bytes for a rectangular region.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        description = "Return data size in bytes for a pixel or block row.",
        returns = "(unsigned)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of image components required to receive pixel data from GetData(), or 0 for compressed images.",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned\nTexture format.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned\nCurrent mip levels.",
        type = "value"
      },
      width = {
        description = "(Readonly) int\nTexture width.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nTexture height.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode\nFiltering mode.",
        type = "value"
      },
      anisotropy = {
        description = "unsigned\nTexture anisotropy level.",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&\nBorder color.",
        type = "value"
      },
      sRGB = {
        description = "bool\nsRGB sampling and writing mode flag.",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int\nMultisampling level.",
        type = "value"
      },
      autoResolve = {
        description = "(Readonly) bool\nMultisampling autoresolve flag.",
        type = "value"
      },
      resolveDirty = {
        description = "(Readonly) bool\nMultisampling resolve needed -flag.",
        type = "value"
      },
      levelsDirty = {
        description = "(Readonly) bool\nMipmap levels regeneration needed -flag.",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*\nBackup texture.",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage\nTexture usage type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  TextureCube = {
    childs = {
      new = {
        args = "()",
        returns = "(TextureCube*)",
        valuetype = "TextureCube",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(int size, unsigned format, TextureUsage usage = TEXTURE_STATIC, int multiSample = 1)",
        description = "Set size, format, usage and multisampling parameter for rendertargets. Note that cube textures always use autoresolve when multisampled due to lacking support (on all APIs) to multisample them in a shader. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetData = {
        args = "(CubeMapFace face, Image* image, bool useAlpha = false)",
        description = "Set data of one face from an image. Return true if successful. Optionally make a single channel image alpha-only.",
        returns = "(bool)",
        type = "method"
      },
      GetImage = {
        args = "(CubeMapFace face)",
        description = "Get image data from a face's zero mip level. Only RGB and RGBA textures are supported.",
        returns = "(Image*)",
        valuetype = "Image",
        type = "method"
      },
      GetRenderSurface = {
        args = "(CubeMapFace face)",
        description = "Return render surface for one face.",
        returns = "(RenderSurface*)",
        valuetype = "RenderSurface",
        type = "method"
      },
      SetNumLevels = {
        args = "(unsigned levels)",
        returns = "()",
        type = "method"
      },
      SetFilterMode = {
        args = "(TextureFilterMode filter)",
        description = "Set filtering mode.",
        returns = "()",
        type = "method"
      },
      SetAddressMode = {
        args = "(TextureCoordinate coord, TextureAddressMode address)",
        description = "Set addressing mode by texture coordinate.",
        returns = "()",
        type = "method"
      },
      SetAnisotropy = {
        args = "(unsigned level)",
        description = "Set texture max. anisotropy level. No effect if not using anisotropic filtering. Value 0 (default) uses the default setting from Renderer.",
        returns = "()",
        type = "method"
      },
      SetBorderColor = {
        args = "(const Color& color)",
        description = "Set border color for border addressing mode.",
        returns = "()",
        type = "method"
      },
      SetSRGB = {
        args = "(bool enable)",
        description = "Set sRGB sampling and writing mode.",
        returns = "()",
        type = "method"
      },
      SetBackupTexture = {
        args = "(Texture* texture)",
        description = "Set backup texture to use when rendering to this texture.",
        returns = "()",
        type = "method"
      },
      SetMipsToSkip = {
        args = "(int quality, int toSkip)",
        description = "Set mip levels to skip on a quality setting when loading. Ensures higher quality levels do not skip more.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return API-specific texture format.",
        returns = "(unsigned)",
        type = "method"
      },
      IsCompressed = {
        args = "()",
        description = "Return whether the texture format is compressed.",
        returns = "(bool)",
        type = "method"
      },
      GetLevels = {
        args = "()",
        description = "Return number of mip levels.",
        returns = "(unsigned)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetFilterMode = {
        args = "()",
        description = "Return filtering mode.",
        returns = "(TextureFilterMode)",
        type = "method"
      },
      GetAddressMode = {
        args = "(TextureCoordinate coord)",
        description = "Return addressing mode by texture coordinate.",
        returns = "(TextureAddressMode)",
        type = "method"
      },
      GetAnisotropy = {
        args = "()",
        description = "Return texture max. anisotropy level. Value 0 means to use the default value from Renderer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetBorderColor = {
        args = "()",
        description = "Return border color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetSRGB = {
        args = "()",
        description = "Return whether is using sRGB sampling and writing.",
        returns = "(bool)",
        type = "method"
      },
      GetMultiSample = {
        args = "()",
        description = "Return texture multisampling level (1 = no multisampling).",
        returns = "(int)",
        type = "method"
      },
      GetAutoResolve = {
        args = "()",
        description = "Return texture multisampling autoresolve mode. When true, the texture is resolved before being sampled on SetTexture(). When false, the texture will not be resolved and must be read as individual samples in the shader.",
        returns = "(bool)",
        type = "method"
      },
      IsResolveDirty = {
        args = "()",
        description = "Return whether multisampled texture needs resolve.",
        returns = "(bool)",
        type = "method"
      },
      GetLevelsDirty = {
        args = "()",
        description = "Return whether rendertarget mipmap levels need regenration.",
        returns = "(bool)",
        type = "method"
      },
      GetBackupTexture = {
        args = "()",
        description = "Return backup texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetMipsToSkip = {
        args = "(int quality)",
        description = "Return mip levels to skip on a quality setting when loading.",
        returns = "(int)",
        type = "method"
      },
      GetLevelWidth = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetLevelHeight = {
        args = "(unsigned level)",
        description = "Return mip level width, or 0 if level does not exist.",
        returns = "(int)",
        type = "method"
      },
      GetUsage = {
        args = "()",
        description = "Return texture usage type.",
        returns = "(TextureUsage)",
        type = "method"
      },
      GetDataSize = {
        args = "(int width, int height)",
        description = "Return data size in bytes for a rectangular region.",
        returns = "(unsigned)",
        type = "method"
      },
      GetRowDataSize = {
        args = "(int width)",
        description = "Return data size in bytes for a pixel or block row.",
        returns = "(unsigned)",
        type = "method"
      },
      GetComponents = {
        args = "()",
        description = "Return number of image components required to receive pixel data from GetData(), or 0 for compressed images.",
        returns = "(unsigned)",
        type = "method"
      },
      format = {
        description = "(Readonly) unsigned\nTexture format.",
        type = "value"
      },
      compressed = {
        description = "(Readonly) bool",
        type = "value"
      },
      levels = {
        description = "(Readonly) unsigned\nCurrent mip levels.",
        type = "value"
      },
      width = {
        description = "(Readonly) int\nTexture width.",
        type = "value"
      },
      height = {
        description = "(Readonly) int\nTexture height.",
        type = "value"
      },
      components = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      filterMode = {
        description = "TextureFilterMode\nFiltering mode.",
        type = "value"
      },
      anisotropy = {
        description = "unsigned\nTexture anisotropy level.",
        type = "value"
      },
      borderColor = {
        valuetype = "Color",
        description = "Color&\nBorder color.",
        type = "value"
      },
      sRGB = {
        description = "bool\nsRGB sampling and writing mode flag.",
        type = "value"
      },
      multiSample = {
        description = "(Readonly) int\nMultisampling level.",
        type = "value"
      },
      autoResolve = {
        description = "(Readonly) bool\nMultisampling autoresolve flag.",
        type = "value"
      },
      resolveDirty = {
        description = "(Readonly) bool\nMultisampling resolve needed -flag.",
        type = "value"
      },
      levelsDirty = {
        description = "(Readonly) bool\nMipmap levels regeneration needed -flag.",
        type = "value"
      },
      backupTexture = {
        valuetype = "Texture",
        description = "Texture*\nBackup texture.",
        type = "value"
      },
      usage = {
        description = "(Readonly) TextureUsage\nTexture usage type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  TextureFrame = {
    childs = {
      new = {
        args = "()",
        returns = "(TextureFrame*)",
        valuetype = "TextureFrame",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      uv = {
        description = "Rect",
        type = "value"
      },
      time = {
        description = "float",
        type = "value"
      },
    },
    type = "class"
  },
  Tile2D = {
    childs = {
      GetGid = {
        args = "()",
        description = "Return gid.",
        returns = "(int)",
        type = "method"
      },
      GetSprite = {
        args = "()",
        description = "Return sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      HasProperty = {
        args = "(const String name)",
        description = "Return has property.",
        returns = "(bool)",
        type = "method"
      },
      GetProperty = {
        args = "(const String name)",
        description = "Return property.",
        returns = "(const String)",
        type = "method"
      },
      gid = {
        description = "(Readonly) int\nGid.",
        type = "value"
      },
      sprite = {
        valuetype = "Sprite2D",
        description = "(Readonly) Sprite2D*\nSprite.",
        type = "value"
      },
    },
    type = "class"
  },
  TileMap2D = {
    childs = {
      SetTmxFile = {
        args = "(TmxFile2D* tmxFile)",
        description = "Set tmx file.",
        returns = "()",
        type = "method"
      },
      GetTmxFile = {
        args = "()",
        description = "Return tmx file.",
        returns = "(TmxFile2D*)",
        valuetype = "TmxFile2D",
        type = "method"
      },
      GetInfo = {
        args = "()",
        description = "Return information.",
        returns = "(const TileMapInfo2D&)",
        valuetype = "TileMapInfo2D",
        type = "method"
      },
      GetNumLayers = {
        args = "()",
        description = "Return number of layers.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLayer = {
        args = "(unsigned index)",
        description = "Return tile map layer at index.",
        returns = "(TileMapLayer2D*)",
        valuetype = "TileMapLayer2D",
        type = "method"
      },
      TileIndexToPosition = {
        args = "(int x, int y)",
        description = "Convert tile index to position.",
        returns = "(Vector2)",
        type = "method"
      },
      PositionToTileIndex = {
        args = "(const Vector2& position, int x = 0, int y = 0)",
        returns = "(bool)",
        type = "method"
      },
      tmxFile = {
        valuetype = "TmxFile2D",
        description = "TmxFile2D*\nTmx file.",
        type = "value"
      },
      info = {
        valuetype = "TileMapInfo2D",
        description = "(Readonly) TileMapInfo2D&\nTile map information.",
        type = "value"
      },
      numLayers = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TileMapInfo2D = {
    childs = {
      GetMapWidth = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetMapHeight = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      orientation = {
        description = "Orientation2D",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      tileWidth = {
        description = "float",
        type = "value"
      },
      tileHeight = {
        description = "float",
        type = "value"
      },
      mapWidth = {
        description = "(Readonly) float",
        type = "value"
      },
      mapHeight = {
        description = "(Readonly) float",
        type = "value"
      },
    },
    type = "class"
  },
  TileMapLayer2D = {
    childs = {
      SetDrawOrder = {
        args = "(int drawOrder)",
        description = "Set draw order",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool visible)",
        description = "Set visible.",
        returns = "()",
        type = "method"
      },
      GetDrawOrder = {
        args = "()",
        description = "Return draw order.",
        returns = "(int)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return visible.",
        returns = "(bool)",
        type = "method"
      },
      HasProperty = {
        args = "(const String name)",
        description = "Return has property",
        returns = "(bool)",
        type = "method"
      },
      GetProperty = {
        args = "(const String name)",
        description = "Return property.",
        returns = "(const String)",
        type = "method"
      },
      GetLayerType = {
        args = "()",
        description = "Return layer type.",
        returns = "(TileMapLayerType2D)",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width (for tile layer only).",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height (for tile layer only).",
        returns = "(int)",
        type = "method"
      },
      GetTileNode = {
        args = "(int x, int y)",
        description = "Return tile node (for tile layer only).",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetTile = {
        args = "(int x, int y)",
        description = "Return tile (for tile layer only).",
        returns = "(Tile2D*)",
        valuetype = "Tile2D",
        type = "method"
      },
      GetNumObjects = {
        args = "()",
        description = "Return number of tile map objects (for object group only).",
        returns = "(unsigned)",
        type = "method"
      },
      GetObject = {
        args = "(unsigned index)",
        description = "Return tile map object (for object group only).",
        returns = "(TileMapObject2D*)",
        valuetype = "TileMapObject2D",
        type = "method"
      },
      GetObjectNode = {
        args = "(unsigned index)",
        description = "Return object node (for object group only).",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetImageNode = {
        args = "()",
        description = "Return image node (for image layer only).",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      drawOrder = {
        description = "(Readonly) int\nDraw order.",
        type = "value"
      },
      visible = {
        description = "(Readonly) bool\nVisible.",
        type = "value"
      },
      layerType = {
        description = "(Readonly) TileMapLayerType2D",
        type = "value"
      },
      width = {
        description = "(Readonly) int",
        type = "value"
      },
      height = {
        description = "(Readonly) int",
        type = "value"
      },
      numObjects = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      imageNode = {
        valuetype = "Node",
        description = "(Readonly) Node*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TileMapObject2D = {
    childs = {
      GetObjectType = {
        args = "()",
        description = "Return type.",
        returns = "(TileMapObjectType2D)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetType = {
        args = "()",
        description = "Return type.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size (for rectangle and ellipse).",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumPoints = {
        args = "()",
        description = "Return number of points (use for script).",
        returns = "(unsigned)",
        type = "method"
      },
      GetPoint = {
        args = "(unsigned index)",
        description = "Return point at index (use for script).",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetTileGid = {
        args = "()",
        description = "Return tile Gid.",
        returns = "(int)",
        type = "method"
      },
      GetTileSprite = {
        args = "()",
        description = "Return tile sprite.",
        returns = "(Sprite2D*)",
        valuetype = "Sprite2D",
        type = "method"
      },
      HasProperty = {
        args = "(const String name)",
        description = "Return has property.",
        returns = "(bool)",
        type = "method"
      },
      GetProperty = {
        args = "(const String name)",
        description = "Return property value.",
        returns = "(const String)",
        type = "method"
      },
      objectType = {
        description = "(Readonly) TileMapObjectType2D\nObject type.",
        type = "value"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      type = {
        description = "(Readonly) String\nType.",
        type = "value"
      },
      position = {
        description = "(Readonly) Vector2\nPosition.",
        type = "value"
      },
      size = {
        description = "(Readonly) Vector2\nSize (for rectangle and ellipse).",
        type = "value"
      },
      numPoints = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      tileGid = {
        description = "(Readonly) int",
        type = "value"
      },
      tileSprite = {
        valuetype = "Sprite2D",
        description = "(Readonly) Sprite2D*",
        type = "value"
      },
    },
    type = "class"
  },
  Time = {
    childs = {
      GetFrameNumber = {
        args = "()",
        description = "Return frame number, starting from 1 once BeginFrame() is called for the first time.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeStep = {
        args = "()",
        description = "Return current frame timestep as seconds.",
        returns = "(float)",
        type = "method"
      },
      GetTimerPeriod = {
        args = "()",
        description = "Return current low-resolution timer period in milliseconds.",
        returns = "(unsigned)",
        type = "method"
      },
      GetElapsedTime = {
        args = "()",
        description = "Return elapsed time from program start as seconds.",
        returns = "(float)",
        type = "method"
      },
      GetSystemTime = {
        args = "()",
        description = "Get system time as milliseconds.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeSinceEpoch = {
        args = "()",
        description = "Get system time as seconds since 1.1.1970.",
        returns = "(unsigned)",
        type = "method"
      },
      GetTimeStamp = {
        args = "()",
        description = "Get a date/time stamp as a string.",
        returns = "(String)",
        type = "method"
      },
      Sleep = {
        args = "(unsigned mSec)",
        description = "Sleep for a number of milliseconds.",
        returns = "()",
        type = "method"
      },
      frameNumber = {
        description = "(Readonly) unsigned\nFrame number.",
        type = "value"
      },
      timeStep = {
        description = "(Readonly) float\nTimestep in seconds.",
        type = "value"
      },
      timerPeriod = {
        description = "(Readonly) unsigned\nLow-resolution timer period.",
        type = "value"
      },
      elapsedTime = {
        description = "(Readonly) float\nElapsed time since program start.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TmxFile2D = {
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    type = "class"
  },
  ToolTip = {
    childs = {
      new = {
        args = "()",
        returns = "(ToolTip*)",
        valuetype = "ToolTip",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetDelay = {
        args = "(float delay)",
        description = "Set the delay in seconds until the tooltip shows once hovering. Set zero to use the default from the UI subsystem.",
        returns = "()",
        type = "method"
      },
      GetDelay = {
        args = "()",
        description = "Return the delay in seconds until the tooltip shows once hovering.",
        returns = "(float)",
        type = "method"
      },
      delay = {
        description = "float\nDelay from hover start to displaying the tooltip.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  TouchState = {
    childs = {
      GetTouchedElement = {
        args = "()",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      touchID = {
        description = "int",
        type = "value"
      },
      position = {
        description = "IntVector2",
        type = "value"
      },
      lastPosition = {
        description = "IntVector2",
        type = "value"
      },
      delta = {
        description = "IntVector2",
        type = "value"
      },
      pressure = {
        description = "float",
        type = "value"
      },
      touchedElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
    },
    type = "class"
  },
  UI = {
    childs = {
      SetCursor = {
        args = "(Cursor* cursor)",
        description = "Set cursor UI element.",
        returns = "()",
        type = "method"
      },
      SetFocusElement = {
        args = "(UIElement* element, bool byKey = false)",
        description = "Set focused UI element.",
        returns = "()",
        type = "method"
      },
      SetModalElement = {
        args = "(UIElement* modalElement, bool enable)",
        description = "Only the modal element can clear its modal status or when it is being destructed.",
        returns = "(bool)",
        type = "method"
      },
      Clear = {
        args = "()",
        description = "Clear the UI (excluding the cursor.)",
        returns = "()",
        type = "method"
      },
      DebugDraw = {
        args = "(UIElement* element)",
        description = "Debug draw a UI element.",
        returns = "()",
        type = "method"
      },
      LoadLayout = {
        args = "(File* source, XMLFile* styleFile = 0)",
        description = "(UIElement*) LoadLayout (const String fileName, XMLFile* styleFile = 0),\n(UIElement*) LoadLayout (XMLFile* file, XMLFile* styleFile = 0)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      SaveLayout = {
        args = "(Serializer& dest, UIElement* element)",
        description = "Save a UI layout to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetClipboardText = {
        args = "(const String text)",
        description = "Set clipboard text.",
        returns = "()",
        type = "method"
      },
      SetDoubleClickInterval = {
        args = "(float interval)",
        description = "Set UI element double click interval in seconds.",
        returns = "()",
        type = "method"
      },
      SetDragBeginInterval = {
        args = "(float interval)",
        description = "Set UI drag event start interval in seconds.",
        returns = "()",
        type = "method"
      },
      SetDragBeginDistance = {
        args = "(int pixels)",
        description = "Set UI drag event start distance threshold in pixels.",
        returns = "()",
        type = "method"
      },
      SetDefaultToolTipDelay = {
        args = "(float delay)",
        description = "Set tooltip default display delay in seconds.",
        returns = "()",
        type = "method"
      },
      SetMaxFontTextureSize = {
        args = "(int size)",
        description = "Set maximum font face texture size. Must be a power of two. Default is 2048.",
        returns = "()",
        type = "method"
      },
      SetNonFocusedMouseWheel = {
        args = "(bool nonFocusedMouseWheel)",
        description = "Set whether mouse wheel can control also a non-focused element.",
        returns = "()",
        type = "method"
      },
      SetUseSystemClipboard = {
        args = "(bool enable)",
        description = "Set whether to use system clipboard. Default false.",
        returns = "()",
        type = "method"
      },
      SetUseScreenKeyboard = {
        args = "(bool enable)",
        description = "Set whether to show the on-screen keyboard (if supported) when a %LineEdit is focused. Default true on mobile devices.",
        returns = "()",
        type = "method"
      },
      SetUseMutableGlyphs = {
        args = "(bool enable)",
        description = "Set whether to use mutable (eraseable) glyphs to ensure a font face never expands to more than one texture. Default false.",
        returns = "()",
        type = "method"
      },
      SetForceAutoHint = {
        args = "(bool enable)",
        description = "Set whether to force font autohinting instead of using FreeType's TTF bytecode interpreter.",
        returns = "()",
        type = "method"
      },
      SetScale = {
        args = "(float scale)",
        description = "Set %UI scale. 1.0 is default (pixel perfect). Resize the root element to match.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(float width)",
        description = "Scale %UI to the specified width in pixels.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(float height)",
        description = "Scale %UI to the specified height in pixels.",
        returns = "()",
        type = "method"
      },
      SetCustomSize = {
        args = "(const IntVector2& size)",
        description = "() SetCustomSize (int width, int height)\nSet custom size of the root element. This disables automatic resizing of the root element according to window size. Set custom size 0,0 to return to automatic resizing.",
        returns = "()",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root UI element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRootModalElement = {
        args = "()",
        description = "Return root modal element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetCursor = {
        args = "()",
        description = "Return cursor.",
        returns = "(Cursor*)",
        valuetype = "Cursor",
        type = "method"
      },
      GetCursorPosition = {
        args = "()",
        description = "Return cursor position.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetElementAt = {
        args = "(const IntVector2& position, bool enabledOnly = true)",
        description = "(UIElement*) GetElementAt (int x, int y, bool enabledOnly = true)\nReturn UI element at screen coordinates. By default returns only input-enabled elements.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetFocusElement = {
        args = "()",
        description = "Return focused element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetFrontElement = {
        args = "()",
        description = "Return topmost enabled root-level non-modal element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDragElement = {
        args = "(unsigned index)",
        description = "Return the drag element at index.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetClipboardText = {
        args = "()",
        description = "Return clipboard text.",
        returns = "(const String)",
        type = "method"
      },
      GetDoubleClickInterval = {
        args = "()",
        description = "Return UI element double click interval in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetDragBeginInterval = {
        args = "()",
        description = "Return UI drag start event interval in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetDragBeginDistance = {
        args = "()",
        description = "Return UI drag start event distance threshold in pixels.",
        returns = "(int)",
        type = "method"
      },
      GetDefaultToolTipDelay = {
        args = "()",
        description = "Return tooltip default display delay in seconds.",
        returns = "(float)",
        type = "method"
      },
      GetMaxFontTextureSize = {
        args = "()",
        description = "Return font texture maximum size.",
        returns = "(int)",
        type = "method"
      },
      IsNonFocusedMouseWheel = {
        args = "()",
        description = "Return whether mouse wheel can control also a non-focused element.",
        returns = "(bool)",
        type = "method"
      },
      GetUseSystemClipboard = {
        args = "()",
        description = "Return whether is using the system clipboard.",
        returns = "(bool)",
        type = "method"
      },
      GetUseScreenKeyboard = {
        args = "()",
        description = "Return whether focusing a %LineEdit will show the on-screen keyboard.",
        returns = "(bool)",
        type = "method"
      },
      GetUseMutableGlyphs = {
        args = "()",
        description = "Return whether is using mutable (eraseable) glyphs for fonts.",
        returns = "(bool)",
        type = "method"
      },
      GetForceAutoHint = {
        args = "()",
        description = "Return whether is using forced autohinting.",
        returns = "(bool)",
        type = "method"
      },
      HasModalElement = {
        args = "()",
        description = "Return true when UI has modal element(s).",
        returns = "(bool)",
        type = "method"
      },
      IsDragging = {
        args = "()",
        description = "Return whether a drag is in progress.",
        returns = "(bool)",
        type = "method"
      },
      GetScale = {
        args = "()",
        description = "Return current UI scale.",
        returns = "(float)",
        type = "method"
      },
      GetCustomSize = {
        args = "()",
        description = "Return root element custom size. Returns 0,0 when custom size is not being used and automatic resizing according to window size is in use instead (default.)",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      rootModalElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      cursor = {
        valuetype = "Cursor",
        description = "Cursor*",
        type = "value"
      },
      cursorPosition = {
        description = "(Readonly) IntVector2",
        type = "value"
      },
      focusElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      frontElement = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      clipboardText = {
        description = "String",
        type = "value"
      },
      doubleClickInterval = {
        description = "float",
        type = "value"
      },
      dragBeginInterval = {
        description = "float",
        type = "value"
      },
      dragBeginDistance = {
        description = "int",
        type = "value"
      },
      defaultToolTipDelay = {
        description = "float",
        type = "value"
      },
      maxFontTextureSize = {
        description = "int",
        type = "value"
      },
      nonFocusedMouseWheel = {
        description = "bool",
        type = "value"
      },
      useSystemClipboard = {
        description = "bool",
        type = "value"
      },
      useScreenKeyboard = {
        description = "bool",
        type = "value"
      },
      useMutableGlyphs = {
        description = "bool",
        type = "value"
      },
      forceAutoHint = {
        description = "bool",
        type = "value"
      },
      modalElement = {
        description = "(Readonly) bool",
        type = "value"
      },
      scale = {
        description = "float",
        type = "value"
      },
      customSize = {
        valuetype = "IntVector2",
        description = "IntVector2&",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  UIElement = {
    childs = {
      new = {
        args = "()",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  ValueAnimation = {
    childs = {
      new = {
        args = "()",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetInterpolationMethod = {
        args = "(InterpMethod method)",
        description = "Set interpolation method.",
        returns = "()",
        type = "method"
      },
      SetSplineTension = {
        args = "(float tension)",
        description = "Set spline tension, should be between 0.0f and 1.0f, but this is not a must.",
        returns = "()",
        type = "method"
      },
      SetValueType = {
        args = "(VariantType valueType)",
        description = "Set value type.",
        returns = "()",
        type = "method"
      },
      SetKeyFrame = {
        args = "(float time, const Variant& value)",
        description = "Set key frame.",
        returns = "(bool)",
        type = "method"
      },
      SetEventFrame = {
        args = "(float time, const StringHash& eventType)",
        description = "() SetEventFrame (float time, const StringHash& eventType, const VariantMap& eventData)",
        returns = "()",
        type = "method"
      },
      GetInterpolationMethod = {
        args = "()",
        description = "Return interpolation method.",
        returns = "(InterpMethod)",
        type = "method"
      },
      GetSplineTension = {
        args = "()",
        description = "Return spline tension.",
        returns = "(float)",
        type = "method"
      },
      GetValueType = {
        args = "()",
        description = "Return value type.",
        returns = "(VariantType)",
        type = "method"
      },
      interpolationMethod = {
        description = "InterpMethod\nInterpolation method.",
        type = "value"
      },
      splineTension = {
        description = "float\nSpline tension.",
        type = "value"
      },
      valueType = {
        description = "VariantType\nValue type.",
        type = "value"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Variant = {
    childs = {
      _Setup = {
        args = "(const char* type)",
        returns = "()",
        type = "method"
      },
      new = {
        args = "()",
        description = "(Variant*) new (const Variant& value),\n(Variant*) new (const char* type, const char* value),\n(Variant*) new (VariantType type, const char* value)",
        returns = "(Variant*)",
        valuetype = "Variant",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Set = {
        args = "(const Variant& rhs)",
        returns = "()",
        type = "method"
      },
      Get = {
        args = "(const char* type = 0)",
        returns = "(void*)",
        type = "method"
      },
      GetInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetInt64 = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetUInt64 = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      GetStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      GetBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      GetDouble = {
        args = "()",
        returns = "(double)",
        type = "method"
      },
      GetVector2 = {
        args = "()",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetVector3 = {
        args = "()",
        returns = "(const Vector3&)",
        valuetype = "Vector3",
        type = "method"
      },
      GetVector4 = {
        args = "()",
        returns = "(const Vector4&)",
        valuetype = "Vector4",
        type = "method"
      },
      GetQuaternion = {
        args = "()",
        returns = "(const Quaternion&)",
        valuetype = "Quaternion",
        type = "method"
      },
      GetColor = {
        args = "()",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetString = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetRawBuffer = {
        args = "()",
        returns = "(const PODVector<unsigned char>&)",
        valuetype = "PODVector<unsigned char>",
        type = "method"
      },
      GetBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      GetVoidPtr = {
        args = "(const char* type)",
        returns = "(void*)",
        type = "method"
      },
      GetResourceRef = {
        args = "()",
        returns = "(const ResourceRef&)",
        valuetype = "ResourceRef",
        type = "method"
      },
      GetResourceRefList = {
        args = "()",
        returns = "(const ResourceRefList&)",
        valuetype = "ResourceRefList",
        type = "method"
      },
      GetVariantVector = {
        args = "()",
        returns = "(const Vector<Variant>&)",
        valuetype = "Vector<Variant>",
        type = "method"
      },
      GetVariantMap = {
        args = "()",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      GetStringVector = {
        args = "()",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "method"
      },
      GetRect = {
        args = "()",
        returns = "(const Rect&)",
        valuetype = "Rect",
        type = "method"
      },
      GetIntRect = {
        args = "()",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetIntVector2 = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetIntVector3 = {
        args = "()",
        returns = "(const IntVector3&)",
        valuetype = "IntVector3",
        type = "method"
      },
      GetPtr = {
        args = "(const char* type)",
        returns = "(RefCounted*)",
        valuetype = "RefCounted",
        type = "method"
      },
      GetMatrix3 = {
        args = "()",
        returns = "(const Matrix3&)",
        valuetype = "Matrix3",
        type = "method"
      },
      GetMatrix3x4 = {
        args = "()",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetMatrix4 = {
        args = "()",
        returns = "(const Matrix4&)",
        valuetype = "Matrix4",
        type = "method"
      },
      GetType = {
        args = "()",
        returns = "(VariantType)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      IsZero = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      IsEmpty = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) VariantType",
        type = "value"
      },
      typeName = {
        description = "(Readonly) String",
        type = "value"
      },
      zero = {
        description = "(Readonly) bool",
        type = "value"
      },
      empty = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  VariantMap = {
    childs = {
      _Setup = {
        args = "(const char* type)",
        returns = "()",
        type = "method"
      },
      new = {
        args = "()",
        returns = "(VariantMap*)",
        valuetype = "VariantMap",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
    },
    type = "class"
  },
  Vector2 = {
    childs = {
      new = {
        args = "()",
        description = "(Vector2*) new (const Vector2& vector),\n(Vector2*) new (const IntVector2& vector),\n(Vector2*) new (float x, float y)",
        returns = "(Vector2*)",
        valuetype = "Vector2",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Normalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Length = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      LengthSquared = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      DotProduct = {
        args = "(const Vector2& rhs)",
        returns = "(float)",
        type = "method"
      },
      AbsDotProduct = {
        args = "(const Vector2& rhs)",
        returns = "(float)",
        type = "method"
      },
      ProjectOntoAxis = {
        args = "(const Vector2& axis)",
        returns = "(float)",
        type = "method"
      },
      Angle = {
        args = "(const Vector2& rhs)",
        returns = "(float)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      Lerp = {
        args = "(const Vector2& rhs, float t)",
        returns = "(Vector2)",
        type = "method"
      },
      Equals = {
        args = "(const Vector2& rhs)",
        returns = "(bool)",
        type = "method"
      },
      IsNaN = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Normalized = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Vector2",
        type = "value"
      },
      LEFT = {
        description = "const Vector2",
        type = "value"
      },
      RIGHT = {
        description = "const Vector2",
        type = "value"
      },
      UP = {
        description = "const Vector2",
        type = "value"
      },
      DOWN = {
        description = "const Vector2",
        type = "value"
      },
      ONE = {
        description = "const Vector2",
        type = "value"
      },
    },
    type = "class"
  },
  Vector3 = {
    childs = {
      new = {
        args = "()",
        description = "(Vector3*) new (const Vector3& vector),\n(Vector3*) new (const Vector2& vector, float z),\n(Vector3*) new (const Vector2& vector),\n(Vector3*) new (const IntVector3& vector),\n(Vector3*) new (float x, float y, float z),\n(Vector3*) new (float x, float y)",
        returns = "(Vector3*)",
        valuetype = "Vector3",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Normalize = {
        args = "()",
        returns = "()",
        type = "method"
      },
      Length = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      LengthSquared = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      DotProduct = {
        args = "(const Vector3& rhs)",
        returns = "(float)",
        type = "method"
      },
      AbsDotProduct = {
        args = "(const Vector3& rhs)",
        returns = "(float)",
        type = "method"
      },
      ProjectOntoAxis = {
        args = "(const Vector3& axis)",
        returns = "(float)",
        type = "method"
      },
      CrossProduct = {
        args = "(const Vector3& rhs)",
        returns = "(Vector3)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      Lerp = {
        args = "(const Vector3& rhs, float t)",
        returns = "(Vector3)",
        type = "method"
      },
      Equals = {
        args = "(const Vector3& rhs)",
        returns = "(bool)",
        type = "method"
      },
      IsNaN = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      Angle = {
        args = "(const Vector3& rhs)",
        returns = "(float)",
        type = "method"
      },
      Normalized = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      z = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Vector3",
        type = "value"
      },
      LEFT = {
        description = "const Vector3",
        type = "value"
      },
      RIGHT = {
        description = "const Vector3",
        type = "value"
      },
      UP = {
        description = "const Vector3",
        type = "value"
      },
      DOWN = {
        description = "const Vector3",
        type = "value"
      },
      FORWARD = {
        description = "const Vector3",
        type = "value"
      },
      BACK = {
        description = "const Vector3",
        type = "value"
      },
      ONE = {
        description = "const Vector3",
        type = "value"
      },
    },
    type = "class"
  },
  Vector4 = {
    childs = {
      new = {
        args = "()",
        description = "(Vector4*) new (const Vector4& vector),\n(Vector4*) new (const Vector3& vector, float w),\n(Vector4*) new (float x, float y, float z, float w)",
        returns = "(Vector4*)",
        valuetype = "Vector4",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      DotProduct = {
        args = "(const Vector4& rhs)",
        returns = "(float)",
        type = "method"
      },
      AbsDotProduct = {
        args = "(const Vector4& rhs)",
        returns = "(float)",
        type = "method"
      },
      ProjectOntoAxis = {
        args = "(const Vector3& axis)",
        returns = "(float)",
        type = "method"
      },
      Abs = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      Lerp = {
        args = "(const Vector4& rhs, float t)",
        returns = "(Vector4)",
        type = "method"
      },
      Equals = {
        args = "(const Vector4& rhs)",
        returns = "(bool)",
        type = "method"
      },
      IsNaN = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ToString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      x = {
        description = "float",
        type = "value"
      },
      y = {
        description = "float",
        type = "value"
      },
      z = {
        description = "float",
        type = "value"
      },
      w = {
        description = "float",
        type = "value"
      },
      ZERO = {
        description = "const Vector4",
        type = "value"
      },
      ONE = {
        description = "const Vector4",
        type = "value"
      },
    },
    type = "class"
  },
  VectorBuffer = {
    childs = {
      new = {
        args = "()",
        description = "(VectorBuffer*) new (Deserializer& source, unsigned size)",
        returns = "(VectorBuffer*)",
        valuetype = "VectorBuffer",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetData = {
        args = "(Deserializer& source, unsigned size)",
        description = "Set data from a stream.",
        returns = "()",
        type = "method"
      },
      Clear = {
        args = "()",
        description = "Reset to zero size.",
        returns = "()",
        type = "method"
      },
      Resize = {
        args = "(unsigned size)",
        description = "Set size.",
        returns = "()",
        type = "method"
      },
      GetData = {
        args = "()",
        description = "Return data.",
        returns = "(const void*)",
        type = "method"
      },
      GetModifiableData = {
        args = "()",
        description = "Return non-const data.",
        returns = "(void*)",
        type = "method"
      },
      Read = {
        args = "(unsigned size)",
        returns = "(VectorBuffer)",
        type = "method"
      },
      Seek = {
        args = "(unsigned position)",
        description = "Set position from the beginning of the buffer.",
        returns = "(unsigned)",
        type = "method"
      },
      GetName = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      GetChecksum = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      GetSize = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      IsEof = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadInt = {
        args = "()",
        returns = "(int)",
        type = "method"
      },
      ReadInt64 = {
        args = "()",
        returns = "(long)",
        type = "method"
      },
      ReadShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadUInt = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadUInt64 = {
        args = "()",
        returns = "(long)",
        type = "method"
      },
      ReadUShort = {
        args = "()",
        returns = "(short)",
        type = "method"
      },
      ReadUByte = {
        args = "()",
        returns = "(char)",
        type = "method"
      },
      ReadBool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      ReadFloat = {
        args = "()",
        returns = "(float)",
        type = "method"
      },
      ReadDouble = {
        args = "()",
        returns = "(double)",
        type = "method"
      },
      ReadIntRect = {
        args = "()",
        returns = "(IntRect)",
        type = "method"
      },
      ReadIntVector2 = {
        args = "()",
        returns = "(IntVector2)",
        type = "method"
      },
      ReadIntVector3 = {
        args = "()",
        returns = "(IntVector3)",
        type = "method"
      },
      ReadRect = {
        args = "()",
        returns = "(Rect)",
        type = "method"
      },
      ReadVector2 = {
        args = "()",
        returns = "(Vector2)",
        type = "method"
      },
      ReadVector3 = {
        args = "()",
        returns = "(Vector3)",
        type = "method"
      },
      ReadPackedVector3 = {
        args = "(float maxAbsCoord)",
        returns = "(Vector3)",
        type = "method"
      },
      ReadVector4 = {
        args = "()",
        returns = "(Vector4)",
        type = "method"
      },
      ReadQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadPackedQuaternion = {
        args = "()",
        returns = "(Quaternion)",
        type = "method"
      },
      ReadMatrix3 = {
        args = "()",
        returns = "(Matrix3)",
        type = "method"
      },
      ReadMatrix3x4 = {
        args = "()",
        returns = "(Matrix3x4)",
        type = "method"
      },
      ReadMatrix4 = {
        args = "()",
        returns = "(Matrix4)",
        type = "method"
      },
      ReadColor = {
        args = "()",
        returns = "(Color)",
        type = "method"
      },
      ReadBoundingBox = {
        args = "()",
        returns = "(BoundingBox)",
        type = "method"
      },
      ReadString = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadFileID = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      ReadStringHash = {
        args = "()",
        returns = "(StringHash)",
        type = "method"
      },
      ReadBuffer = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      ReadResourceRef = {
        args = "()",
        returns = "(ResourceRef)",
        type = "method"
      },
      ReadResourceRefList = {
        args = "()",
        returns = "(ResourceRefList)",
        type = "method"
      },
      ReadVariant = {
        args = "()",
        description = "(Variant) ReadVariant (VariantType type)",
        returns = "(Variant)",
        type = "method"
      },
      ReadVariantVector = {
        args = "()",
        returns = "(VariantVector)",
        type = "method"
      },
      ReadVariantMap = {
        args = "()",
        returns = "(VariantMap)",
        type = "method"
      },
      ReadVLE = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadNetID = {
        args = "()",
        returns = "(unsigned)",
        type = "method"
      },
      ReadLine = {
        args = "()",
        returns = "(String)",
        type = "method"
      },
      Write = {
        args = "(const VectorBuffer& buffer)",
        returns = "(unsigned)",
        type = "method"
      },
      WriteInt = {
        args = "(int value)",
        returns = "(bool)",
        type = "method"
      },
      WriteInt64 = {
        args = "(long value)",
        returns = "(bool)",
        type = "method"
      },
      WriteShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUInt64 = {
        args = "(long value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUShort = {
        args = "(short value)",
        returns = "(bool)",
        type = "method"
      },
      WriteUByte = {
        args = "(char value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBool = {
        args = "(bool value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFloat = {
        args = "(float value)",
        returns = "(bool)",
        type = "method"
      },
      WriteDouble = {
        args = "(double value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntRect = {
        args = "(const IntRect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector2 = {
        args = "(const IntVector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteIntVector3 = {
        args = "(const IntVector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteRect = {
        args = "(const Rect& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector2 = {
        args = "(const Vector2& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector3 = {
        args = "(const Vector3& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedVector3 = {
        args = "(const Vector3& value, float maxAbsCoord)",
        returns = "(bool)",
        type = "method"
      },
      WriteVector4 = {
        args = "(const Vector4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WritePackedQuaternion = {
        args = "(const Quaternion& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3 = {
        args = "(const Matrix3& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix3x4 = {
        args = "(const Matrix3x4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteMatrix4 = {
        args = "(const Matrix4& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteColor = {
        args = "(const Color& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBoundingBox = {
        args = "(const BoundingBox& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteString = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteFileID = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      WriteStringHash = {
        args = "(const StringHash& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteBuffer = {
        args = "(const VectorBuffer& buffer)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRef = {
        args = "(const ResourceRef& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteResourceRefList = {
        args = "(const ResourceRefList& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariant = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantData = {
        args = "(const Variant& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantVector = {
        args = "(const VariantVector& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVariantMap = {
        args = "(const VariantMap& value)",
        returns = "(bool)",
        type = "method"
      },
      WriteVLE = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteNetID = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "method"
      },
      WriteLine = {
        args = "(const String value)",
        returns = "(bool)",
        type = "method"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      checksum = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      position = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      size = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      eof = {
        description = "(Readonly) bool",
        type = "value"
      },
    },
    type = "class"
  },
  VertexBuffer = {
    childs = {
      new = {
        args = "()",
        returns = "(VertexBuffer*)",
        valuetype = "VertexBuffer",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetShadowed = {
        args = "(bool enable)",
        description = "Enable shadowing in CPU memory. Shadowing is forced on if the graphics subsystem does not exist.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(unsigned vertexCount, const PODVector<VertexElement>& elements, bool dynamic = false)",
        description = "(bool) SetSize (unsigned vertexCount, unsigned elementMask, bool dynamic = false)",
        returns = "(bool)",
        type = "method"
      },
      SetData = {
        args = "(VectorBuffer& data)",
        returns = "(bool)",
        type = "method"
      },
      SetDataRange = {
        args = "(VectorBuffer& data, unsigned start, unsigned count, bool discard = false)",
        returns = "(bool)",
        type = "method"
      },
      GetData = {
        args = "()",
        returns = "(VectorBuffer)",
        type = "method"
      },
      IsShadowed = {
        args = "()",
        description = "Return whether CPU memory shadowing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsDynamic = {
        args = "()",
        description = "Return whether is dynamic.",
        returns = "(bool)",
        type = "method"
      },
      GetVertexCount = {
        args = "()",
        description = "Return number of vertices.",
        returns = "(unsigned)",
        type = "method"
      },
      GetVertexSize = {
        args = "()",
        description = "Return vertex size in bytes.",
        returns = "(unsigned)",
        type = "method"
      },
      GetElements = {
        args = "()",
        description = "Return vertex elements.",
        returns = "(const PODVector<VertexElement>&)",
        valuetype = "PODVector<VertexElement>",
        type = "method"
      },
      HasElement = {
        args = "(VertexElementSemantic semantic, char index = 0)",
        description = "(bool) HasElement (VertexElementType type, VertexElementSemantic semantic, char index = 0)",
        returns = "(bool)",
        type = "method"
      },
      GetElementOffset = {
        args = "(VertexElementSemantic semantic, char index = 0)",
        description = "(unsigned) GetElementOffset (VertexElementType type, VertexElementSemantic semantic, char index = 0)",
        returns = "(unsigned)",
        type = "method"
      },
      GetElementMask = {
        args = "()",
        description = "Return legacy vertex element mask. Note that both semantic and type must match the legacy element for a mask bit to be set.",
        returns = "(unsigned)",
        type = "method"
      },
      shadowed = {
        description = "bool\nShadowed flag.",
        type = "value"
      },
      dynamic = {
        description = "(Readonly) bool\nDynamic flag.",
        type = "value"
      },
      vertexCount = {
        description = "(Readonly) unsigned\nNumber of vertices.",
        type = "value"
      },
      vertexSize = {
        description = "(Readonly) unsigned\nVertex size.",
        type = "value"
      },
      elementMask = {
        description = "(Readonly) unsigned\nVertex element legacy bitmask.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  VertexElement = {
    childs = {
      new = {
        args = "()",
        description = "(VertexElement*) new (VertexElementType type, VertexElementSemantic semantic, char index = 0, bool perInstance = false)",
        returns = "(VertexElement*)",
        valuetype = "VertexElement",
        type = "method"
      },
      type = {
        description = "VertexElementType",
        type = "value"
      },
      semantic = {
        description = "VertexElementSemantic",
        type = "value"
      },
      index = {
        description = "char",
        type = "value"
      },
      perInstance = {
        description = "bool",
        type = "value"
      },
      offset = {
        description = "unsigned",
        type = "value"
      },
    },
    type = "class"
  },
  View3D = {
    childs = {
      new = {
        args = "()",
        returns = "(View3D*)",
        valuetype = "View3D",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetView = {
        args = "(Scene* scene, Camera* camera, bool ownScene = true)",
        description = "Define the scene and camera to use in rendering. When ownScene is true the View3D will take ownership of them with shared pointers.",
        returns = "()",
        type = "method"
      },
      SetFormat = {
        args = "(unsigned format)",
        description = "Set render texture pixel format. Default is RGB.",
        returns = "()",
        type = "method"
      },
      SetAutoUpdate = {
        args = "(bool enable)",
        description = "Set render target auto update mode. Default is true.",
        returns = "()",
        type = "method"
      },
      QueueUpdate = {
        args = "()",
        description = "Queue manual update on the render texture.",
        returns = "()",
        type = "method"
      },
      GetFormat = {
        args = "()",
        description = "Return render texture pixel format.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAutoUpdate = {
        args = "()",
        description = "Return whether render target updates automatically.",
        returns = "(bool)",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return scene.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      GetCameraNode = {
        args = "()",
        description = "Return camera scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetRenderTexture = {
        args = "()",
        description = "Return render texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetDepthTexture = {
        args = "()",
        description = "Return depth stencil texture.",
        returns = "(Texture2D*)",
        valuetype = "Texture2D",
        type = "method"
      },
      GetViewport = {
        args = "()",
        description = "Return viewport.",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      format = {
        description = "unsigned",
        type = "value"
      },
      autoUpdate = {
        description = "bool\nRender texture auto update mode.",
        type = "value"
      },
      SetMovable = {
        args = "(bool enable)",
        description = "Set whether can be moved.",
        returns = "()",
        type = "method"
      },
      SetResizable = {
        args = "(bool enable)",
        description = "Set whether can be resized.",
        returns = "()",
        type = "method"
      },
      SetFixedWidthResizing = {
        args = "(bool enable)",
        description = "Set whether resizing width is fixed.",
        returns = "()",
        type = "method"
      },
      SetFixedHeightResizing = {
        args = "(bool enable)",
        description = "Set whether resizing height is fixed.",
        returns = "()",
        type = "method"
      },
      SetResizeBorder = {
        args = "(const IntRect& rect)",
        description = "Set resize area width at edges.",
        returns = "()",
        type = "method"
      },
      SetModal = {
        args = "(bool modal)",
        description = "Set modal flag. When the modal flag is set, the focused window needs to be dismissed first to allow other UI elements to gain focus.",
        returns = "()",
        type = "method"
      },
      SetModalShadeColor = {
        args = "(const Color& color)",
        description = "Set modal shade color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameColor = {
        args = "(const Color& color)",
        description = "Set modal frame color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameSize = {
        args = "(const IntVector2& size)",
        description = "Set modal frame size.",
        returns = "()",
        type = "method"
      },
      SetModalAutoDismiss = {
        args = "(bool enable)",
        description = "Set whether model window can be dismissed with the escape key. Default true.",
        returns = "()",
        type = "method"
      },
      IsMovable = {
        args = "()",
        description = "Return whether is movable.",
        returns = "(bool)",
        type = "method"
      },
      IsResizable = {
        args = "()",
        description = "Return whether is resizable.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedWidthResizing = {
        args = "()",
        description = "Return whether is resizing width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedHeightResizing = {
        args = "()",
        description = "Return whether is resizing height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetResizeBorder = {
        args = "()",
        description = "Return resize area width at edges.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      IsModal = {
        args = "()",
        description = "Return modal flag.",
        returns = "(bool)",
        type = "method"
      },
      GetModalShadeColor = {
        args = "()",
        description = "Get modal shade color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameColor = {
        args = "()",
        description = "Get modal frame color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameSize = {
        args = "()",
        description = "Get modal frame size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetModalAutoDismiss = {
        args = "()",
        description = "Return whether can be dismissed with escape key.",
        returns = "(bool)",
        type = "method"
      },
      movable = {
        description = "bool\nMovable flag.",
        type = "value"
      },
      resizable = {
        description = "bool\nResizable flag.",
        type = "value"
      },
      fixedWidthResizing = {
        description = "bool\nFixed width resize flag.",
        type = "value"
      },
      fixedHeightResizing = {
        description = "bool\nFixed height resize flag.",
        type = "value"
      },
      resizeBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nResize area width at edges.",
        type = "value"
      },
      modal = {
        description = "bool\nModal flag.",
        type = "value"
      },
      modalShadeColor = {
        valuetype = "Color",
        description = "Color&\nModal shade color, used when modal flag is set.",
        type = "value"
      },
      modalFrameColor = {
        valuetype = "Color",
        description = "Color&\nModal frame color, used when modal flag is set.",
        type = "value"
      },
      modalFrameSize = {
        valuetype = "IntVector2",
        description = "IntVector2&\nModal frame size, used when modal flag is set.",
        type = "value"
      },
      modalAutoDismiss = {
        description = "bool\nModal auto dismiss (with escape key) flag. Default true.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  Viewport = {
    childs = {
      new = {
        args = "()",
        description = "(Viewport*) new (Scene* scene, Camera* camera, RenderPath* renderPath = 0),\n(Viewport*) new (Scene* scene, Camera* camera, const IntRect& rect, RenderPath* renderPath = 0)",
        returns = "(Viewport*)",
        valuetype = "Viewport",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetScene = {
        args = "(Scene* scene)",
        description = "Set scene.",
        returns = "()",
        type = "method"
      },
      SetCamera = {
        args = "(Camera* camera)",
        description = "Set viewport camera.",
        returns = "()",
        type = "method"
      },
      SetCullCamera = {
        args = "(Camera* camera)",
        description = "Set separate camera to use for culling. Sharing a culling camera between several viewports allows to prepare the view only once, saving in CPU use. The culling camera's frustum should cover all the viewport cameras' frusta or else objects may be missing from the rendered view.",
        returns = "()",
        type = "method"
      },
      SetRect = {
        args = "(const IntRect& rect)",
        description = "Set view rectangle. A zero rectangle (0 0 0 0) means to use the rendertarget's full dimensions.",
        returns = "()",
        type = "method"
      },
      SetRenderPath = {
        args = "(RenderPath* path)",
        description = "() SetRenderPath (XMLFile* file)\nSet rendering path.",
        returns = "()",
        type = "method"
      },
      SetDrawDebug = {
        args = "(bool enable)",
        description = "Set whether to render debug geometry. Default true.",
        returns = "()",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return scene.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      GetCamera = {
        args = "()",
        description = "Return viewport camera.",
        returns = "(Camera*)",
        valuetype = "Camera",
        type = "method"
      },
      GetCullCamera = {
        args = "()",
        description = "Return the culling camera. If null, the viewport camera will be used for culling (normal case.)",
        returns = "(Camera*)",
        valuetype = "Camera",
        type = "method"
      },
      GetRect = {
        args = "()",
        description = "Return view rectangle. A zero rectangle (0 0 0 0) means to use the rendertarget's full dimensions. In this case you could fetch the actual view rectangle from View object, though it will be valid only after the first frame.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetRenderPath = {
        args = "()",
        description = "Return rendering path.",
        returns = "(RenderPath*)",
        valuetype = "RenderPath",
        type = "method"
      },
      GetDrawDebug = {
        args = "()",
        description = "Return whether to draw debug geometry.",
        returns = "(bool)",
        type = "method"
      },
      GetScreenRay = {
        args = "(int x, int y)",
        description = "Return ray corresponding to normalized screen coordinates.",
        returns = "(Ray)",
        type = "method"
      },
      WorldToScreenPoint = {
        args = "(const Vector3& worldPos)",
        description = "Convert a world space point to normalized screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ScreenToWorldPoint = {
        args = "(int x, int y, float depth)",
        description = "Convert screen coordinates and depth to a world space point.",
        returns = "(Vector3)",
        type = "method"
      },
      scene = {
        valuetype = "Scene",
        description = "Scene*\nScene pointer.",
        type = "value"
      },
      camera = {
        valuetype = "Camera",
        description = "Camera*\nCamera pointer.",
        type = "value"
      },
      cullCamera = {
        valuetype = "Camera",
        description = "Camera*\nCulling camera pointer.",
        type = "value"
      },
      rect = {
        valuetype = "IntRect",
        description = "IntRect&\nViewport rectangle.",
        type = "value"
      },
      renderPath = {
        valuetype = "RenderPath",
        description = "RenderPath*\nRendering path.",
        type = "value"
      },
      drawDebug = {
        description = "bool\nDebug draw flag.",
        type = "value"
      },
    },
    type = "class"
  },
  Window = {
    childs = {
      new = {
        args = "()",
        returns = "(Window*)",
        valuetype = "Window",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      SetMovable = {
        args = "(bool enable)",
        description = "Set whether can be moved.",
        returns = "()",
        type = "method"
      },
      SetResizable = {
        args = "(bool enable)",
        description = "Set whether can be resized.",
        returns = "()",
        type = "method"
      },
      SetFixedWidthResizing = {
        args = "(bool enable)",
        description = "Set whether resizing width is fixed.",
        returns = "()",
        type = "method"
      },
      SetFixedHeightResizing = {
        args = "(bool enable)",
        description = "Set whether resizing height is fixed.",
        returns = "()",
        type = "method"
      },
      SetResizeBorder = {
        args = "(const IntRect& rect)",
        description = "Set resize area width at edges.",
        returns = "()",
        type = "method"
      },
      SetModal = {
        args = "(bool modal)",
        description = "Set modal flag. When the modal flag is set, the focused window needs to be dismissed first to allow other UI elements to gain focus.",
        returns = "()",
        type = "method"
      },
      SetModalShadeColor = {
        args = "(const Color& color)",
        description = "Set modal shade color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameColor = {
        args = "(const Color& color)",
        description = "Set modal frame color.",
        returns = "()",
        type = "method"
      },
      SetModalFrameSize = {
        args = "(const IntVector2& size)",
        description = "Set modal frame size.",
        returns = "()",
        type = "method"
      },
      SetModalAutoDismiss = {
        args = "(bool enable)",
        description = "Set whether model window can be dismissed with the escape key. Default true.",
        returns = "()",
        type = "method"
      },
      IsMovable = {
        args = "()",
        description = "Return whether is movable.",
        returns = "(bool)",
        type = "method"
      },
      IsResizable = {
        args = "()",
        description = "Return whether is resizable.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedWidthResizing = {
        args = "()",
        description = "Return whether is resizing width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetFixedHeightResizing = {
        args = "()",
        description = "Return whether is resizing height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetResizeBorder = {
        args = "()",
        description = "Return resize area width at edges.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      IsModal = {
        args = "()",
        description = "Return modal flag.",
        returns = "(bool)",
        type = "method"
      },
      GetModalShadeColor = {
        args = "()",
        description = "Get modal shade color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameColor = {
        args = "()",
        description = "Get modal frame color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetModalFrameSize = {
        args = "()",
        description = "Get modal frame size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetModalAutoDismiss = {
        args = "()",
        description = "Return whether can be dismissed with escape key.",
        returns = "(bool)",
        type = "method"
      },
      movable = {
        description = "bool\nMovable flag.",
        type = "value"
      },
      resizable = {
        description = "bool\nResizable flag.",
        type = "value"
      },
      fixedWidthResizing = {
        description = "bool\nFixed width resize flag.",
        type = "value"
      },
      fixedHeightResizing = {
        description = "bool\nFixed height resize flag.",
        type = "value"
      },
      resizeBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nResize area width at edges.",
        type = "value"
      },
      modal = {
        description = "bool\nModal flag.",
        type = "value"
      },
      modalShadeColor = {
        valuetype = "Color",
        description = "Color&\nModal shade color, used when modal flag is set.",
        type = "value"
      },
      modalFrameColor = {
        valuetype = "Color",
        description = "Color&\nModal frame color, used when modal flag is set.",
        type = "value"
      },
      modalFrameSize = {
        valuetype = "IntVector2",
        description = "IntVector2&\nModal frame size, used when modal flag is set.",
        type = "value"
      },
      modalAutoDismiss = {
        description = "bool\nModal auto dismiss (with escape key) flag. Default true.",
        type = "value"
      },
      SetTexture = {
        args = "(Texture* texture)",
        description = "Set texture.",
        returns = "()",
        type = "method"
      },
      SetImageRect = {
        args = "(const IntRect& rect)",
        description = "Set part of texture to use as the image.",
        returns = "()",
        type = "method"
      },
      SetFullImageRect = {
        args = "()",
        description = "Use whole texture as the image.",
        returns = "()",
        type = "method"
      },
      SetBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the screen.",
        returns = "()",
        type = "method"
      },
      SetImageBorder = {
        args = "(const IntRect& rect)",
        description = "Set border dimensions on the image. If zero (default) uses the screen dimensions, resulting in pixel-perfect borders.",
        returns = "()",
        type = "method"
      },
      SetHoverOffset = {
        args = "(const IntVector2& offset)",
        description = "() SetHoverOffset (int x, int y)\nSet offset to image rectangle used on hover.",
        returns = "()",
        type = "method"
      },
      SetBlendMode = {
        args = "(BlendMode mode)",
        description = "Set blend mode.",
        returns = "()",
        type = "method"
      },
      SetTiled = {
        args = "(bool enable)",
        description = "Set tiled mode.",
        returns = "()",
        type = "method"
      },
      GetTexture = {
        args = "()",
        description = "Return texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      GetImageRect = {
        args = "()",
        description = "Return image rectangle.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetBorder = {
        args = "()",
        description = "Return border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetImageBorder = {
        args = "()",
        description = "Return border image dimensions. Zero rect uses border screen dimensions.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetHoverOffset = {
        args = "()",
        description = "Return offset to image rectangle used on hover.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetBlendMode = {
        args = "()",
        description = "Return blend mode.",
        returns = "(BlendMode)",
        type = "method"
      },
      IsTiled = {
        args = "()",
        description = "Return whether is tiled.",
        returns = "(bool)",
        type = "method"
      },
      texture = {
        valuetype = "Texture",
        description = "Texture*\nTexture.",
        type = "value"
      },
      imageRect = {
        valuetype = "IntRect",
        description = "IntRect&\nImage rectangle.",
        type = "value"
      },
      border = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on screen.",
        type = "value"
      },
      imageBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nBorder dimensions on the image.",
        type = "value"
      },
      hoverOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nOffset to image rectangle on hover.",
        type = "value"
      },
      blendMode = {
        description = "BlendMode\nBlend mode flag.",
        type = "value"
      },
      tiled = {
        description = "bool\nTiled flag.",
        type = "value"
      },
      GetScreenPosition = {
        args = "()",
        description = "Update and return screen position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      LoadXML = {
        args = "(Deserializer& source)",
        description = "(bool) LoadXML (const String fileName)\nLoad from an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SaveXML = {
        args = "(Serializer& dest, const String indentation = \"\t\")",
        description = "(bool) SaveXML (const String fileName, const String indentation = \"\t\")\nSave to an XML file. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      FilterAttributes = {
        args = "(XMLElement& dest)",
        description = "Filter attributes in serialization process.",
        returns = "(bool)",
        type = "method"
      },
      SetName = {
        args = "(const String name)",
        description = "Set name.",
        returns = "()",
        type = "method"
      },
      SetPosition = {
        args = "(const IntVector2& position)",
        description = "() SetPosition (int x, int y)\nSet position.",
        returns = "()",
        type = "method"
      },
      SetSize = {
        args = "(const IntVector2& size)",
        description = "() SetSize (int width, int height)\nSet size.",
        returns = "()",
        type = "method"
      },
      SetWidth = {
        args = "(int width)",
        description = "Set width only.",
        returns = "()",
        type = "method"
      },
      SetHeight = {
        args = "(int height)",
        description = "Set height only.",
        returns = "()",
        type = "method"
      },
      SetMinSize = {
        args = "(const IntVector2& minSize)",
        description = "() SetMinSize (int width, int height)\nSet minimum size.",
        returns = "()",
        type = "method"
      },
      SetMinWidth = {
        args = "(int width)",
        description = "Set minimum width.",
        returns = "()",
        type = "method"
      },
      SetMinHeight = {
        args = "(int height)",
        description = "Set minimum height.",
        returns = "()",
        type = "method"
      },
      SetMaxSize = {
        args = "(const IntVector2& maxSize)",
        description = "() SetMaxSize (int width, int height)\nSet maximum size.",
        returns = "()",
        type = "method"
      },
      SetMaxWidth = {
        args = "(int width)",
        description = "Set maximum width.",
        returns = "()",
        type = "method"
      },
      SetMaxHeight = {
        args = "(int height)",
        description = "Set maximum height.",
        returns = "()",
        type = "method"
      },
      SetFixedSize = {
        args = "(const IntVector2& size)",
        description = "() SetFixedSize (int width, int height)\nSet fixed size.",
        returns = "()",
        type = "method"
      },
      SetFixedWidth = {
        args = "(int width)",
        description = "Set fixed width.",
        returns = "()",
        type = "method"
      },
      SetFixedHeight = {
        args = "(int height)",
        description = "Set fixed height.",
        returns = "()",
        type = "method"
      },
      SetAlignment = {
        args = "(HorizontalAlignment hAlign, VerticalAlignment vAlign)",
        description = "Set horizontal and vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetHorizontalAlignment = {
        args = "(HorizontalAlignment align)",
        description = "Set horizontal alignment.",
        returns = "()",
        type = "method"
      },
      SetVerticalAlignment = {
        args = "(VerticalAlignment align)",
        description = "Set vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetEnableAnchor = {
        args = "(bool enable)",
        description = "Enable automatic positioning & sizing of the element relative to its parent using min/max anchor and min/max offset. Default false.",
        returns = "()",
        type = "method"
      },
      SetMinAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMinAnchor (float x, float y)\nSet minimum (top left) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxAnchor = {
        args = "(const Vector2& anchor)",
        description = "() SetMaxAnchor (float x, float y)\nSet maximum (bottom right) anchor in relation to the parent element (from 0 to 1.) No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMinOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's top left from the minimum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetMaxOffset = {
        args = "(const IntVector2& offset)",
        description = "Set offset of element's bottom right from the maximum anchor in pixels. No effect when anchor is not enabled.",
        returns = "()",
        type = "method"
      },
      SetPivot = {
        args = "(const Vector2& pivot)",
        description = "() SetPivot (float x, float y)\nSet pivot relative to element's size (from 0 to 1, where 0.5 is center.) Overrides horizontal & vertical alignment.",
        returns = "()",
        type = "method"
      },
      SetClipBorder = {
        args = "(const IntRect& rect)",
        description = "Set child element clipping border.",
        returns = "()",
        type = "method"
      },
      SetColor = {
        args = "(const Color& color)",
        description = "() SetColor (Corner corner, const Color& color)\nSet color on all corners.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set priority.",
        returns = "()",
        type = "method"
      },
      SetOpacity = {
        args = "(float opacity)",
        description = "Set opacity.",
        returns = "()",
        type = "method"
      },
      SetBringToFront = {
        args = "(bool enable)",
        description = "Set whether should be brought to front when focused.",
        returns = "()",
        type = "method"
      },
      SetBringToBack = {
        args = "(bool enable)",
        description = "Set whether should be put to background when another element is focused.",
        returns = "()",
        type = "method"
      },
      SetClipChildren = {
        args = "(bool enable)",
        description = "Set whether should clip child elements. Default false.",
        returns = "()",
        type = "method"
      },
      SetSortChildren = {
        args = "(bool enable)",
        description = "Set whether should sort child elements according to priority. Default true.",
        returns = "()",
        type = "method"
      },
      SetUseDerivedOpacity = {
        args = "(bool enable)",
        description = "Set whether parent elements' opacity affects opacity. Default true.",
        returns = "()",
        type = "method"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set whether reacts to input. Default false, but is enabled by subclasses if applicable.",
        returns = "()",
        type = "method"
      },
      SetDeepEnabled = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Elements' own enabled state is remembered (IsEnabledSelf) and can be restored.",
        returns = "()",
        type = "method"
      },
      ResetDeepEnabled = {
        args = "()",
        description = "Reset enabled state to the element's remembered state prior to calling SetDeepEnabled.",
        returns = "()",
        type = "method"
      },
      SetEnabledRecursive = {
        args = "(bool enable)",
        description = "Set enabled state on self and child elements. Unlike SetDeepEnabled this does not remember the elements' own enabled state, but overwrites it.",
        returns = "()",
        type = "method"
      },
      SetEditable = {
        args = "(bool enable)",
        description = "Set whether value is editable through input. Not applicable to all elements. Default true.",
        returns = "()",
        type = "method"
      },
      SetFocus = {
        args = "(bool enable)",
        description = "Set whether is focused. Only one element can be focused at a time.",
        returns = "()",
        type = "method"
      },
      SetSelected = {
        args = "(bool enable)",
        description = "Set selected mode. Actual meaning is element dependent, for example constant hover or pressed effect.",
        returns = "()",
        type = "method"
      },
      SetVisible = {
        args = "(bool enable)",
        description = "Set whether is visible. Visibility propagates to child elements.",
        returns = "()",
        type = "method"
      },
      SetFocusMode = {
        args = "(FocusMode mode)",
        description = "Set focus mode.",
        returns = "()",
        type = "method"
      },
      SetDragDropMode = {
        args = "(unsigned mode)",
        description = "Set drag and drop flags.",
        returns = "()",
        type = "method"
      },
      SetStyle = {
        args = "(const String styleName, XMLFile* file = 0)",
        description = "(bool) SetStyle (const XMLElement& element)\nSet style from an XML file. Find the style element by name. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetStyleAuto = {
        args = "(XMLFile* file = 0)",
        description = "Set style from an XML file. Find the style element automatically by using the element's typename. If the style file is not explicitly provided, use the default style from parental chain. Return true if the style is applied successfully.",
        returns = "(bool)",
        type = "method"
      },
      SetDefaultStyle = {
        args = "(XMLFile* style)",
        description = "Set default style file for later use by children elements.",
        returns = "()",
        type = "method"
      },
      SetLayout = {
        args = "(LayoutMode mode, int spacing = 0)",
        description = "() SetLayout (LayoutMode mode, int spacing, const IntRect& border)\nSet layout parameters.",
        returns = "()",
        type = "method"
      },
      SetLayoutMode = {
        args = "(LayoutMode mode)",
        description = "Set layout mode only.",
        returns = "()",
        type = "method"
      },
      SetLayoutSpacing = {
        args = "(int spacing)",
        description = "Set layout spacing.",
        returns = "()",
        type = "method"
      },
      SetLayoutBorder = {
        args = "(const IntRect& border)",
        description = "Set layout border.",
        returns = "()",
        type = "method"
      },
      SetLayoutFlexScale = {
        args = "(const Vector2& scale)",
        description = "Set layout flex scale.",
        returns = "()",
        type = "method"
      },
      SetIndent = {
        args = "(int indent)",
        description = "Set horizontal indentation.",
        returns = "()",
        type = "method"
      },
      SetIndentSpacing = {
        args = "(int indentSpacing)",
        description = "Set indent spacing (number of pixels per indentation level).",
        returns = "()",
        type = "method"
      },
      UpdateLayout = {
        args = "()",
        description = "Manually update layout. Should not be necessary in most cases, but is provided for completeness.",
        returns = "()",
        type = "method"
      },
      DisableLayoutUpdate = {
        args = "()",
        description = "Disable automatic layout update. Should only be used if there are performance problems.",
        returns = "()",
        type = "method"
      },
      EnableLayoutUpdate = {
        args = "()",
        description = "Enable automatic layout update.",
        returns = "()",
        type = "method"
      },
      BringToFront = {
        args = "()",
        description = "Bring UI element to front.",
        returns = "()",
        type = "method"
      },
      CreateChild = {
        args = "(const String type, const String name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      AddChild = {
        args = "(UIElement* element)",
        description = "Add a child element.",
        returns = "()",
        type = "method"
      },
      InsertChild = {
        args = "(unsigned index, UIElement* element)",
        description = "Insert a child element into a specific position in the child list.",
        returns = "()",
        type = "method"
      },
      RemoveChild = {
        args = "(UIElement* element, unsigned index = 0)",
        description = "Remove a child element. Starting search at specified index if provided.",
        returns = "()",
        type = "method"
      },
      RemoveChildAtIndex = {
        args = "(unsigned index)",
        description = "Remove a child element at index.",
        returns = "()",
        type = "method"
      },
      RemoveAllChildren = {
        args = "()",
        description = "Remove all child elements.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the parent element. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      FindChild = {
        args = "(UIElement* element)",
        description = "Find child index. Return M_MAX_UNSIGNED if not found.",
        returns = "(unsigned)",
        type = "method"
      },
      SetParent = {
        args = "(UIElement* parent, unsigned index = M_MAX_UNSIGNED)",
        description = "Set parent element. Same as parent->InsertChild(index, this).",
        returns = "()",
        type = "method"
      },
      SetVar = {
        args = "(StringHash key, const Variant& value)",
        description = "Set a user variable.",
        returns = "()",
        type = "method"
      },
      SetInternal = {
        args = "(bool enable)",
        description = "Mark as internally (programmatically) created. Used when an element composes itself out of child elements.",
        returns = "()",
        type = "method"
      },
      SetTraversalMode = {
        args = "(TraversalMode traversalMode)",
        description = "Set traversal mode for rendering. The default traversal mode is TM_BREADTH_FIRST for non-root element. Root element should be set to TM_DEPTH_FIRST to avoid artifacts during rendering.",
        returns = "()",
        type = "method"
      },
      SetElementEventSender = {
        args = "(bool flag)",
        description = "Set element event sender flag. When child element is added or deleted, the event would be sent using UIElement found in the parental chain having this flag set. If not set, the event is sent using UI's root as per normal.",
        returns = "()",
        type = "method"
      },
      AddTag = {
        args = "(const String tag)",
        description = "Add a tag.",
        returns = "()",
        type = "method"
      },
      AddTags = {
        args = "(const String tags, char separator)",
        returns = "()",
        type = "method"
      },
      RemoveTag = {
        args = "(const String tag)",
        description = "Remove specific tag. Return true if existed.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAllTags = {
        args = "()",
        description = "Remove all tags.",
        returns = "()",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetPosition = {
        args = "()",
        description = "Return position.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetSize = {
        args = "()",
        description = "Return size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetWidth = {
        args = "()",
        description = "Return width.",
        returns = "(int)",
        type = "method"
      },
      GetHeight = {
        args = "()",
        description = "Return height.",
        returns = "(int)",
        type = "method"
      },
      GetMinSize = {
        args = "()",
        description = "Return minimum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMinWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMinHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      GetMaxSize = {
        args = "()",
        description = "Return maximum size.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxWidth = {
        args = "()",
        description = "Return minimum width.",
        returns = "(int)",
        type = "method"
      },
      GetMaxHeight = {
        args = "()",
        description = "Return minimum height.",
        returns = "(int)",
        type = "method"
      },
      IsFixedSize = {
        args = "()",
        description = "Return true if size is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedWidth = {
        args = "()",
        description = "Return true if width is fixed.",
        returns = "(bool)",
        type = "method"
      },
      IsFixedHeight = {
        args = "()",
        description = "Return true if height is fixed.",
        returns = "(bool)",
        type = "method"
      },
      GetChildOffset = {
        args = "()",
        description = "Return child element offset.",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetHorizontalAlignment = {
        args = "()",
        description = "Return horizontal alignment. If pivot has been adjusted to a custom horizontal setting, returns HA_CUSTOM.",
        returns = "(HorizontalAlignment)",
        type = "method"
      },
      GetVerticalAlignment = {
        args = "()",
        description = "Return vertical alignment. If pivot has been adjusted to a custom vertical setting, returns VA_CUSTOM.",
        returns = "(VerticalAlignment)",
        type = "method"
      },
      GetEnableAnchor = {
        args = "()",
        description = "Return whether anchor positioning & sizing is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetMinAnchor = {
        args = "()",
        description = "Return minimum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMaxAnchor = {
        args = "()",
        description = "Return maximum anchor.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetMinOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetMaxOffset = {
        args = "()",
        returns = "(const IntVector2&)",
        valuetype = "IntVector2",
        type = "method"
      },
      GetPivot = {
        args = "()",
        description = "Return pivot.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetClipBorder = {
        args = "()",
        description = "Return child element clipping border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetColor = {
        args = "(Corner corner)",
        description = "(const Color&) GetColor ()\nReturn corner color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return priority.",
        returns = "(int)",
        type = "method"
      },
      GetOpacity = {
        args = "()",
        description = "Return opacity.",
        returns = "(float)",
        type = "method"
      },
      GetDerivedOpacity = {
        args = "()",
        description = "Return derived opacity (affected by parent elements.) If UseDerivedOpacity is false, returns same as element's own opacity.",
        returns = "(float)",
        type = "method"
      },
      GetBringToFront = {
        args = "()",
        description = "Return whether should be brought to front when focused.",
        returns = "(bool)",
        type = "method"
      },
      GetBringToBack = {
        args = "()",
        description = "Return whether should be put to background when another element is focused.",
        returns = "(bool)",
        type = "method"
      },
      GetClipChildren = {
        args = "()",
        description = "Return whether should clip child elements.",
        returns = "(bool)",
        type = "method"
      },
      GetSortChildren = {
        args = "()",
        description = "Return whether should sort child elements according to priority.",
        returns = "(bool)",
        type = "method"
      },
      GetUseDerivedOpacity = {
        args = "()",
        description = "Return whether parent elements' opacity affects opacity.",
        returns = "(bool)",
        type = "method"
      },
      HasFocus = {
        args = "()",
        description = "Return whether has focus.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether reacts to input.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledSelf = {
        args = "()",
        description = "Returns the element's last own enabled state. May be different than the value returned by IsEnabled when SetDeepEnabled has been used.",
        returns = "(bool)",
        type = "method"
      },
      IsEditable = {
        args = "()",
        description = "Return whether value is editable through input.",
        returns = "(bool)",
        type = "method"
      },
      IsSelected = {
        args = "()",
        description = "Return whether is selected. Actual meaning is element dependent.",
        returns = "(bool)",
        type = "method"
      },
      IsVisible = {
        args = "()",
        description = "Return whether element itself should be visible. Elements can be also hidden due to the parent being not visible, use IsVisibleEffective() to check.",
        returns = "(bool)",
        type = "method"
      },
      IsVisibleEffective = {
        args = "()",
        description = "Return whether element is effectively visible (parent element chain is visible.)",
        returns = "(bool)",
        type = "method"
      },
      IsHovering = {
        args = "()",
        description = "Return whether the cursor is hovering on this element.",
        returns = "(bool)",
        type = "method"
      },
      IsInternal = {
        args = "()",
        description = "Return whether is internally created.",
        returns = "(bool)",
        type = "method"
      },
      HasColorGradient = {
        args = "()",
        description = "Return whether has different color in at least one corner.",
        returns = "(bool)",
        type = "method"
      },
      GetFocusMode = {
        args = "()",
        description = "Return focus mode.",
        returns = "(FocusMode)",
        type = "method"
      },
      GetDragDropMode = {
        args = "()",
        description = "Return drag and drop flags.",
        returns = "(unsigned)",
        type = "method"
      },
      GetAppliedStyle = {
        args = "()",
        description = "Return applied style name. Return an empty string when the applied style is an 'auto' style (i.e. style derived from instance's type).",
        returns = "(const String)",
        type = "method"
      },
      GetDefaultStyle = {
        args = "(bool recursiveUp = true)",
        description = "Return default style.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      GetLayoutMode = {
        args = "()",
        description = "Return layout mode.",
        returns = "(LayoutMode)",
        type = "method"
      },
      GetLayoutSpacing = {
        args = "()",
        description = "Return layout spacing.",
        returns = "(int)",
        type = "method"
      },
      GetLayoutBorder = {
        args = "()",
        description = "Return layout border.",
        returns = "(const IntRect&)",
        valuetype = "IntRect",
        type = "method"
      },
      GetLayoutFlexScale = {
        args = "()",
        description = "Return layout flex scale.",
        returns = "(const Vector2&)",
        valuetype = "Vector2",
        type = "method"
      },
      GetNumChildren = {
        args = "(bool recursive = false)",
        description = "Return number of child elements.",
        returns = "(unsigned)",
        type = "method"
      },
      GetDragButtonCombo = {
        args = "()",
        description = "Return the drag button combo if this element is being dragged.",
        returns = "(int)",
        type = "method"
      },
      GetDragButtonCount = {
        args = "()",
        description = "Return the number of buttons dragging this element.",
        returns = "(unsigned)",
        type = "method"
      },
      GetChild = {
        args = "(const String name, bool recursive = false)",
        description = "(UIElement*) GetChild (unsigned index)\nReturn child element by name.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetRoot = {
        args = "()",
        description = "Return root element.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      GetDerivedColor = {
        args = "()",
        description = "Return derived color. Only valid when no gradient.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetVar = {
        args = "(StringHash key)",
        returns = "(const Variant&)",
        valuetype = "Variant",
        type = "method"
      },
      GetVars = {
        args = "()",
        description = "Return all user variables.",
        returns = "(const VariantMap&)",
        valuetype = "VariantMap",
        type = "method"
      },
      HasTag = {
        args = "(const String tag)",
        description = "Return whether element is tagged by a specific tag.",
        returns = "(bool)",
        type = "method"
      },
      GetTags = {
        args = "()",
        description = "Return all tags.",
        returns = "(const StringVector&)",
        valuetype = "StringVector",
        type = "method"
      },
      GetChildrenWithTag = {
        args = "(const String tag, bool recursive = false)",
        description = "Return child elements with a specific tag either recursively or non-recursively.",
        returns = "(const PODVector<UIElement*>&)",
        valuetype = "PODVector<UIElement*>",
        type = "method"
      },
      ScreenToElement = {
        args = "(const IntVector2& screenPosition)",
        description = "Convert screen coordinates to element coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      ElementToScreen = {
        args = "(const IntVector2& position)",
        description = "Convert element coordinates to screen coordinates.",
        returns = "(IntVector2)",
        type = "method"
      },
      IsInside = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the element.",
        returns = "(bool)",
        type = "method"
      },
      IsInsideCombined = {
        args = "(IntVector2 position, bool isScreen)",
        description = "Return whether a point (either in element or screen coordinates) is inside the combined rect of the element and its children.",
        returns = "(bool)",
        type = "method"
      },
      GetCombinedScreenRect = {
        args = "()",
        description = "Return combined screen coordinate rect of element and its children.",
        returns = "(IntRect)",
        type = "method"
      },
      SortChildren = {
        args = "()",
        description = "Sort child elements if sorting enabled and order dirty. Called by UI.",
        returns = "()",
        type = "method"
      },
      GetIndent = {
        args = "()",
        description = "Return horizontal indentation.",
        returns = "(int)",
        type = "method"
      },
      GetIndentSpacing = {
        args = "()",
        description = "Return indent spacing (number of pixels per indentation level).",
        returns = "(int)",
        type = "method"
      },
      GetIndentWidth = {
        args = "()",
        description = "Return indent width in pixels.",
        returns = "(int)",
        type = "method"
      },
      SetChildOffset = {
        args = "(const IntVector2& offset)",
        description = "Set child offset.",
        returns = "()",
        type = "method"
      },
      SetHovering = {
        args = "(bool enable)",
        description = "Set hovering state.",
        returns = "()",
        type = "method"
      },
      GetTraversalMode = {
        args = "()",
        description = "Return traversal mode for rendering.",
        returns = "(TraversalMode)",
        type = "method"
      },
      IsElementEventSender = {
        args = "()",
        description = "Return whether element should send child added / removed events by itself. If false, defers to parent element.",
        returns = "(bool)",
        type = "method"
      },
      GetElementEventSender = {
        args = "()",
        description = "Get element which should send child added / removed events.",
        returns = "(UIElement*)",
        valuetype = "UIElement",
        type = "method"
      },
      screenPosition = {
        valuetype = "IntVector2",
        description = "(Readonly) IntVector2&\nScreen position.",
        type = "value"
      },
      name = {
        description = "String\nName.",
        type = "value"
      },
      position = {
        valuetype = "IntVector2",
        description = "IntVector2&\nPosition.",
        type = "value"
      },
      size = {
        description = "IntVector2\nSize.",
        type = "value"
      },
      width = {
        description = "int",
        type = "value"
      },
      height = {
        description = "int",
        type = "value"
      },
      minSize = {
        description = "IntVector2\nMinimum size.",
        type = "value"
      },
      minWidth = {
        description = "int",
        type = "value"
      },
      minHeight = {
        description = "int",
        type = "value"
      },
      maxSize = {
        description = "IntVector2\nMaximum size.",
        type = "value"
      },
      maxWidth = {
        description = "int",
        type = "value"
      },
      maxHeight = {
        description = "int",
        type = "value"
      },
      fixedSize = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedWidth = {
        description = "(Readonly) bool",
        type = "value"
      },
      fixedHeight = {
        description = "(Readonly) bool",
        type = "value"
      },
      childOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nChild elements' offset. Used internally.",
        type = "value"
      },
      horizontalAlignment = {
        description = "HorizontalAlignment",
        type = "value"
      },
      verticalAlignment = {
        description = "VerticalAlignment",
        type = "value"
      },
      enableAnchor = {
        description = "bool\nUse min/max anchor & min/max offset for position & size instead of setting explicitly.",
        type = "value"
      },
      minOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMinimum offset.",
        type = "value"
      },
      maxOffset = {
        valuetype = "IntVector2",
        description = "IntVector2&\nMaximum offset.",
        type = "value"
      },
      minAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      maxAnchor = {
        valuetype = "Vector2",
        description = "Vector2&",
        type = "value"
      },
      pivot = {
        valuetype = "Vector2",
        description = "Vector2&\nPivot Position",
        type = "value"
      },
      clipBorder = {
        description = "IntRect\nChild element clipping border.",
        type = "value"
      },
      color = {
        valuetype = "Color",
        description = "Color&\nColors.",
        type = "value"
      },
      priority = {
        description = "int\nPriority.",
        type = "value"
      },
      opacity = {
        description = "float\nOpacity.",
        type = "value"
      },
      derivedOpacity = {
        description = "(Readonly) float\nDerived opacity.",
        type = "value"
      },
      bringToFront = {
        description = "bool\nBring to front when focused flag.",
        type = "value"
      },
      bringToBack = {
        description = "bool\nBring to back when defocused flag.",
        type = "value"
      },
      clipChildren = {
        description = "bool\nClip children flag.",
        type = "value"
      },
      sortChildren = {
        description = "bool\nSort children according to priority flag.",
        type = "value"
      },
      useDerivedOpacity = {
        description = "bool\nUse derived opacity flag.",
        type = "value"
      },
      focus = {
        description = "bool",
        type = "value"
      },
      enabled = {
        description = "bool\nInput enabled flag.",
        type = "value"
      },
      enabledSelf = {
        description = "(Readonly) bool",
        type = "value"
      },
      editable = {
        description = "bool\nValue editable flag.",
        type = "value"
      },
      selected = {
        description = "bool\nSelected flag.",
        type = "value"
      },
      visible = {
        description = "bool\nVisible flag.",
        type = "value"
      },
      visibleEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      hovering = {
        description = "bool\nHovering flag.",
        type = "value"
      },
      internal = {
        description = "bool\nInternally created flag.",
        type = "value"
      },
      colorGradient = {
        description = "(Readonly) bool\nHas color gradient flag.",
        type = "value"
      },
      focusMode = {
        description = "FocusMode\nFocus mode.",
        type = "value"
      },
      dragDropMode = {
        description = "unsigned\nDrag and drop flags.",
        type = "value"
      },
      style = {
        description = "String",
        type = "value"
      },
      defaultStyle = {
        valuetype = "XMLFile",
        description = "XMLFile*\nDefault style file.",
        type = "value"
      },
      layoutMode = {
        description = "LayoutMode\nLayout mode.",
        type = "value"
      },
      layoutSpacing = {
        description = "int\nLayout spacing.",
        type = "value"
      },
      layoutBorder = {
        valuetype = "IntRect",
        description = "IntRect&\nLayout borders.",
        type = "value"
      },
      layoutFlexScale = {
        valuetype = "Vector2",
        description = "Vector2&\nLayout flex scale.",
        type = "value"
      },
      numChildren = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      parent = {
        valuetype = "UIElement",
        description = "UIElement*\nParent element.",
        type = "value"
      },
      root = {
        valuetype = "UIElement",
        description = "(Readonly) UIElement*",
        type = "value"
      },
      derivedColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nDerived color. Only valid when no gradient.",
        type = "value"
      },
      combinedScreenRect = {
        description = "(Readonly) IntRect",
        type = "value"
      },
      indent = {
        description = "int\nHorizontal indentation.",
        type = "value"
      },
      indentSpacing = {
        description = "int\nIndent spacing (number of pixels per indentation level).",
        type = "value"
      },
      indentWidth = {
        description = "(Readonly) int",
        type = "value"
      },
      traversalMode = {
        description = "TraversalMode\nTraversal mode for rendering.",
        type = "value"
      },
      elementEventSender = {
        description = "bool\nFlag whether node should send child added / removed events by itself.",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },
  XMLElement = {
    childs = {
      CreateChild = {
        args = "(const String name)",
        description = "Create a child element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetOrCreateChild = {
        args = "(const String name)",
        description = "Return the first child element with name or create if does not exist.",
        returns = "(XMLElement)",
        type = "method"
      },
      RemoveChild = {
        args = "(const XMLElement& element)",
        description = "(bool) RemoveChild (const String name)\nRemove a child element. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      RemoveChildren = {
        args = "(const String name = String::EMPTY)",
        description = "Remove child elements of certain name, or all child elements if name is empty. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      RemoveAttribute = {
        args = "(const String name = String::EMPTY)",
        description = "Remove an attribute by name. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      SetValue = {
        args = "(const String value)",
        description = "Set the value for an inner node in the following format <node>value</node>.",
        returns = "(bool)",
        type = "method"
      },
      SetAttribute = {
        args = "(const String name, const String value)",
        description = "(bool) SetAttribute (const String value)\nSet an attribute.\nSet an attribute. Only valid if it is an attribute only XPath query result.",
        returns = "(bool)",
        type = "method"
      },
      SetBool = {
        args = "(const String name, bool value)",
        description = "Set a bool attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetBoundingBox = {
        args = "(const BoundingBox& value)",
        description = "Set a BoundingBox attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetColor = {
        args = "(const String name, const Color& value)",
        description = "Set a color attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetFloat = {
        args = "(const String name, float value)",
        description = "Set a float attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetDouble = {
        args = "(const String name, double value)",
        description = "Set a double attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetUInt = {
        args = "(const String name, unsigned value)",
        description = "Set an unsigned integer attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetInt = {
        args = "(const String name, int value)",
        description = "Set an integer attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetUInt64 = {
        args = "(const String name, long value)",
        returns = "(bool)",
        type = "method"
      },
      SetInt64 = {
        args = "(const String name, long value)",
        description = "Set a long long integer attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetIntRect = {
        args = "(const String name, const IntRect& value)",
        description = "Set an IntRect attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetIntVector2 = {
        args = "(const String name, const IntVector2& value)",
        description = "Set an IntVector2 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetIntVector3 = {
        args = "(const String name, const IntVector3& value)",
        description = "Set an IntVector3 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetRect = {
        args = "(const String name, const Rect& value)",
        description = "Set a Rect attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetQuaternion = {
        args = "(const String name, const Quaternion& value)",
        description = "Set a quaternion attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetString = {
        args = "(const String name, const String value)",
        description = "Set a string attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVariant = {
        args = "(const Variant& value)",
        description = "Set a variant attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVariantValue = {
        args = "(const Variant& value)",
        description = "Set a variant attribute excluding the type.",
        returns = "(bool)",
        type = "method"
      },
      SetResourceRef = {
        args = "(const ResourceRef& value)",
        description = "Set a resource reference attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetResourceRefList = {
        args = "(const ResourceRefList& value)",
        description = "Set a resource reference list attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVector2 = {
        args = "(const String name, const Vector2& value)",
        description = "Set a Vector2 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVector3 = {
        args = "(const String name, const Vector3& value)",
        description = "Set a Vector3 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVector4 = {
        args = "(const String name, const Vector4& value)",
        description = "Set a Vector4 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetVectorVariant = {
        args = "(const String name, const Variant& value)",
        description = "Set a float, Vector or Matrix attribute stored in a variant.",
        returns = "(bool)",
        type = "method"
      },
      SetMatrix3 = {
        args = "(const String name, const Matrix3& value)",
        description = "Set a Matrix3 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetMatrix3x4 = {
        args = "(const String name, const Matrix3x4& value)",
        description = "Set a Matrix3x4 attribute.",
        returns = "(bool)",
        type = "method"
      },
      SetMatrix4 = {
        args = "(const String name, const Matrix4& value)",
        description = "Set a Matrix4 attribute.",
        returns = "(bool)",
        type = "method"
      },
      IsNull = {
        args = "()",
        description = "Return whether does not refer to an element or an XPath node.",
        returns = "(bool)",
        type = "method"
      },
      NotNull = {
        args = "()",
        description = "Return whether refers to an element or an XPath node.",
        returns = "(bool)",
        type = "method"
      },
      operatorbool = {
        args = "()",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return element name (or attribute name if it is an attribute only XPath query result).",
        returns = "(String)",
        type = "method"
      },
      HasChild = {
        args = "(const String name)",
        description = "Return whether has a child element.",
        returns = "(bool)",
        type = "method"
      },
      GetChild = {
        args = "(const String name = String::EMPTY)",
        description = "Return child element, or null if missing.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetNext = {
        args = "(const String name = String::EMPTY)",
        description = "Return next sibling element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetParent = {
        args = "()",
        description = "Return parent element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetNumAttributes = {
        args = "()",
        description = "Return number of attributes.",
        returns = "(unsigned)",
        type = "method"
      },
      HasAttribute = {
        args = "(const String name)",
        description = "Return whether has an attribute.",
        returns = "(bool)",
        type = "method"
      },
      GetValue = {
        args = "()",
        description = "Return inner value, or empty if missing for nodes like <node>value</node>",
        returns = "(String)",
        type = "method"
      },
      GetAttribute = {
        args = "(const String name = String::EMPTY)",
        description = "Return attribute, or empty if missing.",
        returns = "(String)",
        type = "method"
      },
      GetAttributeLower = {
        args = "(const String name)",
        description = "Return attribute in lowercase, or empty if missing.",
        returns = "(String)",
        type = "method"
      },
      GetAttributeUpper = {
        args = "(const String name)",
        description = "Return attribute in lowercase, or empty if missing.",
        returns = "(String)",
        type = "method"
      },
      GetAttributeNames = {
        args = "()",
        description = "Return names of all attributes.",
        returns = "(Vector<String>)",
        type = "method"
      },
      GetBool = {
        args = "(const String name)",
        description = "Return bool attribute, or false if missing.",
        returns = "(bool)",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return bounding box attribute, or empty if missing.",
        returns = "(BoundingBox)",
        type = "method"
      },
      GetColor = {
        args = "(const String name)",
        description = "Return a color attribute, or default if missing.",
        returns = "(Color)",
        type = "method"
      },
      GetFloat = {
        args = "(const String name)",
        description = "Return a float attribute, or zero if missing.",
        returns = "(float)",
        type = "method"
      },
      GetDouble = {
        args = "(const String name)",
        description = "Return a double attribute, or zero if missing.",
        returns = "(double)",
        type = "method"
      },
      GetUInt = {
        args = "(const String name)",
        description = "Return an unsigned integer attribute, or zero if missing.",
        returns = "(unsigned)",
        type = "method"
      },
      GetInt = {
        args = "(const String name)",
        description = "Return an integer attribute, or zero if missing.",
        returns = "(int)",
        type = "method"
      },
      GetUInt64 = {
        args = "(const String name)",
        description = "Return an unsigned long long integer attribute, or zero if missing.",
        returns = "(long)",
        type = "method"
      },
      GetInt64 = {
        args = "(const String name)",
        description = "Return a long long integer attribute, or zero if missing.",
        returns = "(long)",
        type = "method"
      },
      GetIntRect = {
        args = "(const String name)",
        description = "Return an IntRect attribute, or default if missing.",
        returns = "(IntRect)",
        type = "method"
      },
      GetIntVector2 = {
        args = "(const String name)",
        description = "Return an IntVector2 attribute, or default if missing.",
        returns = "(IntVector2)",
        type = "method"
      },
      GetIntVector3 = {
        args = "(const String name)",
        description = "Return an IntVector3 attribute, or default if missing.",
        returns = "(IntVector3)",
        type = "method"
      },
      GetRect = {
        args = "(const String name)",
        description = "Return a Rect attribute, or default if missing.",
        returns = "(Rect)",
        type = "method"
      },
      GetQuaternion = {
        args = "(const String name)",
        description = "Return a quaternion attribute, or default if missing.",
        returns = "(Quaternion)",
        type = "method"
      },
      GetVariant = {
        args = "()",
        description = "Return a variant attribute, or empty if missing.",
        returns = "(Variant)",
        type = "method"
      },
      GetVariantValue = {
        args = "(VariantType type)",
        description = "Return a variant attribute with static type.",
        returns = "(Variant)",
        type = "method"
      },
      GetResourceRef = {
        args = "()",
        description = "Return a resource reference attribute, or empty if missing.",
        returns = "(ResourceRef)",
        type = "method"
      },
      GetResourceRefList = {
        args = "()",
        description = "Return a resource reference list attribute, or empty if missing.",
        returns = "(ResourceRefList)",
        type = "method"
      },
      GetVariantMap = {
        args = "()",
        description = "Return a variant map attribute, or empty if missing.",
        returns = "(VariantMap)",
        type = "method"
      },
      GetVector2 = {
        args = "(const String name)",
        description = "Return a Vector2 attribute, or zero vector if missing.",
        returns = "(Vector2)",
        type = "method"
      },
      GetVector3 = {
        args = "(const String name)",
        description = "Return a Vector3 attribute, or zero vector if missing.",
        returns = "(Vector3)",
        type = "method"
      },
      GetVector4 = {
        args = "(const String name)",
        description = "Return a Vector4 attribute, or zero vector if missing.",
        returns = "(Vector4)",
        type = "method"
      },
      GetVector = {
        args = "(const String name)",
        description = "Return any Vector attribute as Vector4. Missing coordinates will be zero.",
        returns = "(Vector4)",
        type = "method"
      },
      GetMatrix3 = {
        args = "(const String name)",
        description = "Return a Matrix3 attribute, or zero matrix if missing.",
        returns = "(Matrix3)",
        type = "method"
      },
      GetMatrix3x4 = {
        args = "(const String name)",
        description = "Return a Matrix3x4 attribute, or zero matrix if missing.",
        returns = "(Matrix3x4)",
        type = "method"
      },
      GetMatrix4 = {
        args = "(const String name)",
        description = "Return a Matrix4 attribute, or zero matrix if missing.",
        returns = "(Matrix4)",
        type = "method"
      },
      GetFile = {
        args = "()",
        description = "Return XML file.",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      EMPTY = {
        description = "const XMLElement\nEmpty XMLElement.",
        type = "value"
      },
      null = {
        description = "(Readonly) bool",
        type = "value"
      },
      name = {
        description = "(Readonly) String",
        type = "value"
      },
      parent = {
        description = "(Readonly) XMLElement",
        type = "value"
      },
      value = {
        description = "(Readonly) String",
        type = "value"
      },
      numAttributes = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      file = {
        valuetype = "XMLFile",
        description = "(Readonly) XMLFile*\nXML file.",
        type = "value"
      },
    },
    type = "class"
  },
  XMLFile = {
    childs = {
      new = {
        args = "()",
        returns = "(XMLFile*)",
        valuetype = "XMLFile",
        type = "method"
      },
      delete = {
        args = "()",
        returns = "()",
        type = "method"
      },
      FromString = {
        args = "(const String source)",
        description = "Deserialize from a string. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      CreateRoot = {
        args = "(const String name = String::EMPTY)",
        description = "Clear the document and create a root element.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetOrCreateRoot = {
        args = "(const String name = String::EMPTY)",
        description = "Get the root element if it has matching name, otherwise create it and clear the document.",
        returns = "(XMLElement)",
        type = "method"
      },
      GetRoot = {
        args = "(const String name = String::EMPTY)",
        description = "Return the root element, with optionally specified name. Return null element if not found.",
        returns = "(XMLElement)",
        type = "method"
      },
      ToString = {
        args = "(const String indentation = \"\t\")",
        description = "Serialize the XML content to a string.",
        returns = "(String)",
        type = "method"
      },
      Patch = {
        args = "(XMLFile* patchFile)",
        description = "() Patch (XMLElement patchElement)\nPatch the XMLFile with another XMLFile. Based on RFC 5261.",
        returns = "()",
        type = "method"
      },
      Save = {
        args = "(const String fileName, const String indentation = \"\t\")",
        returns = "(bool)",
        type = "method"
      },
      Load = {
        args = "(Deserializer& source)",
        description = "(bool) Load (const String fileName)\nLoad resource synchronously. Call both BeginLoad() & EndLoad() and return true if both succeeded.",
        returns = "(bool)",
        type = "method"
      },
      Save = {
        args = "(Serializer& dest)",
        description = "(bool) Save (const String fileName)\nSave resource. Return true if successful.",
        returns = "(bool)",
        type = "method"
      },
      GetName = {
        args = "()",
        description = "Return name.",
        returns = "(const String)",
        type = "method"
      },
      GetNameHash = {
        args = "()",
        description = "Return name hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetMemoryUse = {
        args = "()",
        description = "Return memory use in bytes, possibly approximate.",
        returns = "(unsigned)",
        type = "method"
      },
      name = {
        description = "(Readonly) String\nName.",
        type = "value"
      },
      nameHash = {
        description = "(Readonly) StringHash\nName hash.",
        type = "value"
      },
      memoryUse = {
        description = "(Readonly) unsigned\nMemory use in bytes.",
        type = "value"
      },
    },
    type = "class"
  },
  Zone = {
    childs = {
      SetBoundingBox = {
        args = "(const BoundingBox& box)",
        description = "Set local-space bounding box. Will be used as an oriented bounding box to test whether objects or the camera are inside.",
        returns = "()",
        type = "method"
      },
      SetAmbientColor = {
        args = "(const Color& color)",
        description = "Set ambient color",
        returns = "()",
        type = "method"
      },
      SetFogColor = {
        args = "(const Color& color)",
        description = "Set fog color.",
        returns = "()",
        type = "method"
      },
      SetFogStart = {
        args = "(float start)",
        description = "Set fog start distance.",
        returns = "()",
        type = "method"
      },
      SetFogEnd = {
        args = "(float end)",
        description = "Set fog end distance.",
        returns = "()",
        type = "method"
      },
      SetFogHeight = {
        args = "(float height)",
        description = "Set fog height distance relative to the scene node's world position. Effective only in height fog mode.",
        returns = "()",
        type = "method"
      },
      SetFogHeightScale = {
        args = "(float scale)",
        description = "Set fog height scale. Effective only in height fog mode.",
        returns = "()",
        type = "method"
      },
      SetPriority = {
        args = "(int priority)",
        description = "Set zone priority. If an object or camera is inside several zones, the one with highest priority is used.",
        returns = "()",
        type = "method"
      },
      SetHeightFog = {
        args = "(bool enable)",
        description = "Set height fog mode.",
        returns = "()",
        type = "method"
      },
      SetOverride = {
        args = "(bool enable)",
        description = "Set override mode. If camera is inside an override zone, that zone will be used for all rendered objects instead of their own zone.",
        returns = "()",
        type = "method"
      },
      SetAmbientGradient = {
        args = "(bool enable)",
        description = "Set ambient gradient mode. In gradient mode ambient color is interpolated from neighbor zones.",
        returns = "()",
        type = "method"
      },
      SetZoneTexture = {
        args = "(Texture* texture)",
        description = "Set zone texture. This will be bound to the zone texture unit when rendering objects inside the zone. Note that the default shaders do not use it.",
        returns = "()",
        type = "method"
      },
      GetInverseWorldTransform = {
        args = "()",
        description = "Return inverse world transform.",
        returns = "(const Matrix3x4&)",
        valuetype = "Matrix3x4",
        type = "method"
      },
      GetAmbientColor = {
        args = "()",
        description = "Return zone's own ambient color, disregarding gradient mode.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetAmbientStartColor = {
        args = "()",
        description = "Return ambient start color. Not safe to call from worker threads due to possible octree query.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetAmbientEndColor = {
        args = "()",
        description = "Return ambient end color. Not safe to call from worker threads due to possible octree query.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetFogColor = {
        args = "()",
        description = "Return fog color.",
        returns = "(const Color&)",
        valuetype = "Color",
        type = "method"
      },
      GetFogStart = {
        args = "()",
        description = "Return fog start distance.",
        returns = "(float)",
        type = "method"
      },
      GetFogEnd = {
        args = "()",
        description = "Return fog end distance.",
        returns = "(float)",
        type = "method"
      },
      GetFogHeight = {
        args = "()",
        description = "Return fog height distance relative to the scene node's world position.",
        returns = "(float)",
        type = "method"
      },
      GetFogHeightScale = {
        args = "()",
        description = "Return fog height scale.",
        returns = "(float)",
        type = "method"
      },
      GetPriority = {
        args = "()",
        description = "Return zone priority.",
        returns = "(int)",
        type = "method"
      },
      GetHeightFog = {
        args = "()",
        description = "Return whether height fog mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetOverride = {
        args = "()",
        description = "Return whether override mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetAmbientGradient = {
        args = "()",
        description = "Return whether ambient gradient mode is enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetZoneTexture = {
        args = "()",
        description = "Return zone texture.",
        returns = "(Texture*)",
        valuetype = "Texture",
        type = "method"
      },
      IsInside = {
        args = "(const Vector3& point)",
        description = "Check whether a point is inside.",
        returns = "(bool)",
        type = "method"
      },
      boundingBox = {
        valuetype = "BoundingBox",
        description = "BoundingBox&",
        type = "value"
      },
      inverseWorldTransform = {
        valuetype = "Matrix3x4",
        description = "(Readonly) Matrix3x4&",
        type = "value"
      },
      ambientColor = {
        valuetype = "Color",
        description = "Color&\nAmbient color.",
        type = "value"
      },
      ambientStartColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nCached ambient start color.",
        type = "value"
      },
      ambientEndColor = {
        valuetype = "Color",
        description = "(Readonly) Color&\nCached ambient end color.",
        type = "value"
      },
      fogColor = {
        valuetype = "Color",
        description = "Color&\nFog color.",
        type = "value"
      },
      fogStart = {
        description = "float\nFog start distance.",
        type = "value"
      },
      fogEnd = {
        description = "float\nFog end distance.",
        type = "value"
      },
      fogHeight = {
        description = "float\nFog height distance.",
        type = "value"
      },
      fogHeightScale = {
        description = "float\nFog height cale.",
        type = "value"
      },
      priority = {
        description = "int\nZone priority.",
        type = "value"
      },
      heightFog = {
        description = "bool\nHeight fog mode flag.",
        type = "value"
      },
      override = {
        description = "bool\nOverride mode flag.",
        type = "value"
      },
      ambientGradient = {
        description = "bool\nAmbient gradient mode flag.",
        type = "value"
      },
      zoneTexture = {
        valuetype = "Texture",
        description = "Texture*\nZone texture.",
        type = "value"
      },
      SetDrawDistance = {
        args = "(float distance)",
        description = "Set draw distance.",
        returns = "()",
        type = "method"
      },
      SetShadowDistance = {
        args = "(float distance)",
        description = "Set shadow draw distance.",
        returns = "()",
        type = "method"
      },
      SetLodBias = {
        args = "(float bias)",
        description = "Set LOD bias.",
        returns = "()",
        type = "method"
      },
      SetViewMask = {
        args = "(unsigned mask)",
        description = "Set view mask. Is and'ed with camera's view mask to see if the object should be rendered.",
        returns = "()",
        type = "method"
      },
      SetLightMask = {
        args = "(unsigned mask)",
        description = "Set light mask. Is and'ed with light's and zone's light mask to see if the object should be lit.",
        returns = "()",
        type = "method"
      },
      SetShadowMask = {
        args = "(unsigned mask)",
        description = "Set shadow mask. Is and'ed with light's light mask and zone's shadow mask to see if the object should be rendered to a shadow map.",
        returns = "()",
        type = "method"
      },
      SetZoneMask = {
        args = "(unsigned mask)",
        description = "Set zone mask. Is and'ed with zone's zone mask to see if the object should belong to the zone.",
        returns = "()",
        type = "method"
      },
      SetMaxLights = {
        args = "(unsigned num)",
        description = "Set maximum number of per-pixel lights. Default 0 is unlimited.",
        returns = "()",
        type = "method"
      },
      SetCastShadows = {
        args = "(bool enable)",
        description = "Set shadowcaster flag.",
        returns = "()",
        type = "method"
      },
      SetOccluder = {
        args = "(bool enable)",
        description = "Set occlusion flag.",
        returns = "()",
        type = "method"
      },
      SetOccludee = {
        args = "(bool enable)",
        description = "Set occludee flag.",
        returns = "()",
        type = "method"
      },
      MarkForUpdate = {
        args = "()",
        description = "Mark for update and octree reinsertion. Update is automatically queued when the drawable's scene node moves or changes scale.",
        returns = "()",
        type = "method"
      },
      GetBoundingBox = {
        args = "()",
        description = "Return local space bounding box. May not be applicable or properly updated on all drawables.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetWorldBoundingBox = {
        args = "()",
        description = "Return world-space bounding box.",
        returns = "(const BoundingBox&)",
        valuetype = "BoundingBox",
        type = "method"
      },
      GetDrawableFlags = {
        args = "()",
        description = "Return drawable flags.",
        returns = "(char)",
        type = "method"
      },
      GetDrawDistance = {
        args = "()",
        description = "Return draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetShadowDistance = {
        args = "()",
        description = "Return shadow draw distance.",
        returns = "(float)",
        type = "method"
      },
      GetLodBias = {
        args = "()",
        description = "Return LOD bias.",
        returns = "(float)",
        type = "method"
      },
      GetViewMask = {
        args = "()",
        description = "Return view mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetLightMask = {
        args = "()",
        description = "Return light mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetShadowMask = {
        args = "()",
        description = "Return shadow mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetZoneMask = {
        args = "()",
        description = "Return zone mask.",
        returns = "(unsigned)",
        type = "method"
      },
      GetMaxLights = {
        args = "()",
        description = "Return maximum number of per-pixel lights.",
        returns = "(unsigned)",
        type = "method"
      },
      GetCastShadows = {
        args = "()",
        description = "Return shadowcaster flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccluder = {
        args = "()",
        description = "Return occluder flag.",
        returns = "(bool)",
        type = "method"
      },
      IsOccludee = {
        args = "()",
        description = "Return occludee flag.",
        returns = "(bool)",
        type = "method"
      },
      IsInView = {
        args = "()",
        description = "(bool) IsInView (Camera* tolua_var_2)\nReturn whether is in view this frame from any viewport camera. Excludes shadow map cameras.",
        returns = "(bool)",
        type = "method"
      },
      GetZone = {
        args = "()",
        returns = "(Zone*)",
        valuetype = "Zone",
        type = "method"
      },
      worldBoundingBox = {
        valuetype = "BoundingBox",
        description = "(Readonly) BoundingBox&",
        type = "value"
      },
      drawableFlags = {
        description = "(Readonly) char",
        type = "value"
      },
      drawDistance = {
        description = "float",
        type = "value"
      },
      shadowDistance = {
        description = "float",
        type = "value"
      },
      lodBias = {
        description = "float",
        type = "value"
      },
      viewMask = {
        description = "unsigned",
        type = "value"
      },
      lightMask = {
        description = "unsigned",
        type = "value"
      },
      shadowMask = {
        description = "unsigned",
        type = "value"
      },
      zoneMask = {
        description = "unsigned",
        type = "value"
      },
      maxLights = {
        description = "unsigned",
        type = "value"
      },
      castShadows = {
        description = "bool",
        type = "value"
      },
      occluder = {
        description = "bool",
        type = "value"
      },
      occludee = {
        description = "bool",
        type = "value"
      },
      inView = {
        description = "(Readonly) bool",
        type = "value"
      },
      zone = {
        valuetype = "Zone",
        description = "(Readonly) Zone*",
        type = "value"
      },
      SetEnabled = {
        args = "(bool enable)",
        description = "Set enabled/disabled state.",
        returns = "()",
        type = "method"
      },
      Remove = {
        args = "()",
        description = "Remove from the scene node. If no other shared pointer references exist, causes immediate deletion.",
        returns = "()",
        type = "method"
      },
      DrawDebugGeometry = {
        args = "(DebugRenderer* debug, bool depthTest)",
        description = "Visualize the component as debug geometry.",
        returns = "()",
        type = "method"
      },
      GetID = {
        args = "()",
        description = "Return ID.",
        returns = "(unsigned)",
        type = "method"
      },
      GetNode = {
        args = "()",
        description = "Return scene node.",
        returns = "(Node*)",
        valuetype = "Node",
        type = "method"
      },
      GetScene = {
        args = "()",
        description = "Return the scene the node belongs to.",
        returns = "(Scene*)",
        valuetype = "Scene",
        type = "method"
      },
      IsEnabled = {
        args = "()",
        description = "Return whether is enabled.",
        returns = "(bool)",
        type = "method"
      },
      IsEnabledEffective = {
        args = "()",
        description = "Return whether is effectively enabled (node is also enabled.)",
        returns = "(bool)",
        type = "method"
      },
      GetComponent = {
        args = "(StringHash type)",
        description = "(Component*) GetComponent (const String type)\nReturn component in the same scene node by type. If there are several, returns the first.",
        returns = "(Component*)",
        valuetype = "Component",
        type = "method"
      },
      ID = {
        description = "(Readonly) unsigned",
        type = "value"
      },
      enabled = {
        description = "bool\nEnabled flag.",
        type = "value"
      },
      enabledEffective = {
        description = "(Readonly) bool",
        type = "value"
      },
      node = {
        valuetype = "Node",
        description = "(Readonly) Node*\nScene node.",
        type = "value"
      },
      scene = {
        valuetype = "Scene",
        description = "(Readonly) Scene*",
        type = "value"
      },
      SetAnimationEnabled = {
        args = "(bool enable)",
        description = "Set automatic update of animation, default true.",
        returns = "()",
        type = "method"
      },
      SetAnimationTime = {
        args = "(float time)",
        description = "Set time position of all attribute animations or an object animation manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      SetObjectAnimation = {
        args = "(ObjectAnimation* objectAnimation)",
        description = "Set object animation.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimation = {
        args = "(const String name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationWrapMode = {
        args = "(const String name, WrapMode wrapMode)",
        description = "Set attribute animation wrap mode.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationSpeed = {
        args = "(const String name, float speed)",
        description = "Set attribute animation speed.",
        returns = "()",
        type = "method"
      },
      SetAttributeAnimationTime = {
        args = "(const String name, float time)",
        description = "Set attribute animation time position manually. Automatic update should be disabled in this case.",
        returns = "()",
        type = "method"
      },
      RemoveObjectAnimation = {
        args = "()",
        description = "Remove object animation. Same as calling SetObjectAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      RemoveAttributeAnimation = {
        args = "(const String name)",
        description = "Remove attribute animation. Same as calling SetAttributeAnimation with a null pointer.",
        returns = "()",
        type = "method"
      },
      GetAnimationEnabled = {
        args = "()",
        description = "Return animation enabled.",
        returns = "(bool)",
        type = "method"
      },
      GetObjectAnimation = {
        args = "()",
        description = "Return object animation.",
        returns = "(ObjectAnimation*)",
        valuetype = "ObjectAnimation",
        type = "method"
      },
      GetAttributeAnimation = {
        args = "(const String name)",
        description = "Return attribute animation.",
        returns = "(ValueAnimation*)",
        valuetype = "ValueAnimation",
        type = "method"
      },
      GetAttributeAnimationWrapMode = {
        args = "(const String name)",
        description = "Return attribute animation wrap mode.",
        returns = "(WrapMode)",
        type = "method"
      },
      GetAttributeAnimationSpeed = {
        args = "(const String name)",
        description = "Return attribute animation speed.",
        returns = "(float)",
        type = "method"
      },
      GetAttributeAnimationTime = {
        args = "(const String name)",
        description = "Return attribute animation time position.",
        returns = "(float)",
        type = "method"
      },
      animationEnabled = {
        description = "bool\nAnimation enabled.",
        type = "value"
      },
      objectAnimation = {
        valuetype = "ObjectAnimation",
        description = "ObjectAnimation*\nAnimation.",
        type = "value"
      },
      SetTemporary = {
        args = "(bool enable)",
        description = "Set temporary flag. Temporary objects will not be saved.",
        returns = "()",
        type = "method"
      },
      IsTemporary = {
        args = "()",
        description = "Return whether is temporary.",
        returns = "(bool)",
        type = "method"
      },
      SetInterceptNetworkUpdate = {
        args = "(const String attributeName, bool enable)",
        description = "Enable interception of an attribute from network updates. Intercepted attributes are sent as events instead of applying directly. This can be used to implement client side prediction.",
        returns = "()",
        type = "method"
      },
      GetInterceptNetworkUpdate = {
        args = "(const String attributeName)",
        description = "Return whether an attribute's network updates are being intercepted.",
        returns = "(bool)",
        type = "method"
      },
      temporary = {
        description = "bool\nTemporary flag.",
        type = "value"
      },
      GetType = {
        args = "()",
        description = "Return type hash.",
        returns = "(StringHash)",
        type = "method"
      },
      GetTypeName = {
        args = "()",
        description = "Return type name.",
        returns = "(const String)",
        type = "method"
      },
      GetCategory = {
        args = "()",
        returns = "(const String)",
        type = "method"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap* eventData = 0)",
        returns = "()",
        type = "method"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        description = "(bool) HasSubscribedToEvent (Object* sender, const String eventName)",
        returns = "(bool)",
        type = "method"
      },
      type = {
        description = "(Readonly) StringHash",
        type = "value"
      },
      typeName = {
        description = "(Readonly) const String",
        type = "value"
      },
      category = {
        description = "(Readonly) const String",
        type = "value"
      },
    },
    type = "class"
  },

  -- Enumerations

      FABRIK = {
        description = "(Readonly) int for 'Algorithm'",
        type = "value"
      },
      ABM_LERP = {
        description = "(Readonly) int for 'AnimationBlendMode'",
        type = "value"
      },
      ABM_ADDITIVE = {
        description = "(Readonly) int for 'AnimationBlendMode'",
        type = "value"
      },
      REMOVE_DISABLED = {
        description = "(Readonly) int for 'AutoRemoveMode'",
        type = "value"
      },
      REMOVE_COMPONENT = {
        description = "(Readonly) int for 'AutoRemoveMode'",
        type = "value"
      },
      REMOVE_NODE = {
        description = "(Readonly) int for 'AutoRemoveMode'",
        type = "value"
      },
      BLEND_REPLACE = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_ADD = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_MULTIPLY = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_ALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_ADDALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_PREMULALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_INVDESTALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_SUBTRACT = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BLEND_SUBTRACTALPHA = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      MAX_BLENDMODES = {
        description = "(Readonly) int for 'BlendMode'",
        type = "value"
      },
      BT_STATIC = {
        description = "(Readonly) int for 'BodyType2D'",
        type = "value"
      },
      BT_KINEMATIC = {
        description = "(Readonly) int for 'BodyType2D'",
        type = "value"
      },
      BT_DYNAMIC = {
        description = "(Readonly) int for 'BodyType2D'",
        type = "value"
      },
      COLLISION_NEVER = {
        description = "(Readonly) int for 'CollisionEventMode'",
        type = "value"
      },
      COLLISION_ACTIVE = {
        description = "(Readonly) int for 'CollisionEventMode'",
        type = "value"
      },
      COLLISION_ALWAYS = {
        description = "(Readonly) int for 'CollisionEventMode'",
        type = "value"
      },
      CMP_ALWAYS = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_EQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_NOTEQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_LESS = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_LESSEQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_GREATER = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CMP_GREATEREQUAL = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      MAX_COMPAREMODES = {
        description = "(Readonly) int for 'CompareMode'",
        type = "value"
      },
      CF_NONE = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_RGBA = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_DXT1 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_DXT3 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_DXT5 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_ETC1 = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGB_2BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGBA_2BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGB_4BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CF_PVRTC_RGBA_4BPP = {
        description = "(Readonly) int for 'CompressedFormat'",
        type = "value"
      },
      CONSTRAINT_POINT = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      CONSTRAINT_HINGE = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      CONSTRAINT_SLIDER = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      CONSTRAINT_CONETWIST = {
        description = "(Readonly) int for 'ConstraintType'",
        type = "value"
      },
      C_TOPLEFT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      C_TOPRIGHT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      C_BOTTOMLEFT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      C_BOTTOMRIGHT = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      MAX_UIELEMENT_CORNERS = {
        description = "(Readonly) int for 'Corner'",
        type = "value"
      },
      REPLICATED = {
        description = "(Readonly) int for 'CreateMode'",
        type = "value"
      },
      LOCAL = {
        description = "(Readonly) int for 'CreateMode'",
        type = "value"
      },
      CA_REQUESTEDTARGET_NONE = {
        description = "(Readonly) int for 'CrowdAgentRequestedTarget'",
        type = "value"
      },
      CA_REQUESTEDTARGET_POSITION = {
        description = "(Readonly) int for 'CrowdAgentRequestedTarget'",
        type = "value"
      },
      CA_REQUESTEDTARGET_VELOCITY = {
        description = "(Readonly) int for 'CrowdAgentRequestedTarget'",
        type = "value"
      },
      CA_STATE_INVALID = {
        description = "(Readonly) int for 'CrowdAgentState'",
        type = "value"
      },
      CA_STATE_WALKING = {
        description = "(Readonly) int for 'CrowdAgentState'",
        type = "value"
      },
      CA_STATE_OFFMESH = {
        description = "(Readonly) int for 'CrowdAgentState'",
        type = "value"
      },
      CA_TARGET_NONE = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      CA_TARGET_FAILED = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      CA_TARGET_VALID = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      CA_TARGET_REQUESTING = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      CA_TARGET_WAITINGFORQUEUE = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      CA_TARGET_WAITINGFORPATH = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      CA_TARGET_VELOCITY = {
        description = "(Readonly) int for 'CrowdAgentTargetState'",
        type = "value"
      },
      FACE_POSITIVE_X = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_NEGATIVE_X = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_POSITIVE_Y = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_NEGATIVE_Y = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_POSITIVE_Z = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      FACE_NEGATIVE_Z = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      MAX_CUBEMAP_FACES = {
        description = "(Readonly) int for 'CubeMapFace'",
        type = "value"
      },
      CULL_NONE = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      CULL_CCW = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      CULL_CW = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      MAX_CULLMODES = {
        description = "(Readonly) int for 'CullMode'",
        type = "value"
      },
      CS_NORMAL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_IBEAM = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_CROSS = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEVERTICAL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEDIAGONAL_TOPRIGHT = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEHORIZONTAL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZEDIAGONAL_TOPLEFT = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_RESIZE_ALL = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_ACCEPTDROP = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_REJECTDROP = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_BUSY = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_BUSY_ARROW = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      CS_MAX_SHAPES = {
        description = "(Readonly) int for 'CursorShape'",
        type = "value"
      },
      DBAPI_SQLITE = {
        description = "(Readonly) int for 'DBAPI'",
        type = "value"
      },
      DBAPI_ODBC = {
        description = "(Readonly) int for 'DBAPI'",
        type = "value"
      },
      EMITTER_SPHERE = {
        description = "(Readonly) int for 'EmitterType'",
        type = "value"
      },
      EMITTER_BOX = {
        description = "(Readonly) int for 'EmitterType'",
        type = "value"
      },
      EMITTER_TYPE_GRAVITY = {
        description = "(Readonly) int for 'EmitterType2D'",
        type = "value"
      },
      EMITTER_TYPE_RADIAL = {
        description = "(Readonly) int for 'EmitterType2D'",
        type = "value"
      },
      FC_NONE = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_ROTATE_XYZ = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_ROTATE_Y = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_LOOKAT_XYZ = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_LOOKAT_Y = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_LOOKAT_MIXED = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_DIRECTION = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_NONE = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_ROTATE_XYZ = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_ROTATE_Y = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_LOOKAT_XYZ = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_LOOKAT_Y = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_LOOKAT_MIXED = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FC_DIRECTION = {
        description = "(Readonly) int for 'FaceCameraMode'",
        type = "value"
      },
      FILE_READ = {
        description = "(Readonly) int for 'FileMode'",
        type = "value"
      },
      FILE_WRITE = {
        description = "(Readonly) int for 'FileMode'",
        type = "value"
      },
      FILE_READWRITE = {
        description = "(Readonly) int for 'FileMode'",
        type = "value"
      },
      FILL_SOLID = {
        description = "(Readonly) int for 'FillMode'",
        type = "value"
      },
      FILL_WIREFRAME = {
        description = "(Readonly) int for 'FillMode'",
        type = "value"
      },
      FILL_POINT = {
        description = "(Readonly) int for 'FillMode'",
        type = "value"
      },
      FM_NOTFOCUSABLE = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FM_RESETFOCUS = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FM_FOCUSABLE = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FM_FOCUSABLE_DEFOCUSABLE = {
        description = "(Readonly) int for 'FocusMode'",
        type = "value"
      },
      FONT_NONE = {
        description = "(Readonly) int for 'FontType'",
        type = "value"
      },
      FONT_FREETYPE = {
        description = "(Readonly) int for 'FontType'",
        type = "value"
      },
      FONT_BITMAP = {
        description = "(Readonly) int for 'FontType'",
        type = "value"
      },
      MAX_FONT_TYPES = {
        description = "(Readonly) int for 'FontType'",
        type = "value"
      },
      PLANE_NEAR = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_LEFT = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_RIGHT = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_UP = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_DOWN = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      PLANE_FAR = {
        description = "(Readonly) int for 'FrustumPlane'",
        type = "value"
      },
      GEOM_STATIC = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_SKINNED = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_INSTANCED = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_BILLBOARD = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      GEOM_STATIC_NOINSTANCING = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      MAX_GEOMETRYTYPES = {
        description = "(Readonly) int for 'GeometryType'",
        type = "value"
      },
      HM_NEVER = {
        description = "(Readonly) int for 'HighlightMode'",
        type = "value"
      },
      HM_FOCUS = {
        description = "(Readonly) int for 'HighlightMode'",
        type = "value"
      },
      HM_ALWAYS = {
        description = "(Readonly) int for 'HighlightMode'",
        type = "value"
      },
      HA_LEFT = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HA_CENTER = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HA_RIGHT = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HA_CUSTOM = {
        description = "(Readonly) int for 'HorizontalAlignment'",
        type = "value"
      },
      HTTP_INITIALIZING = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      HTTP_ERROR = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      HTTP_OPEN = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      HTTP_CLOSED = {
        description = "(Readonly) int for 'HttpRequestState'",
        type = "value"
      },
      IM_NONE = {
        description = "(Readonly) int for 'InterpMethod'",
        type = "value"
      },
      IM_LINEAR = {
        description = "(Readonly) int for 'InterpMethod'",
        type = "value"
      },
      IM_SPLINE = {
        description = "(Readonly) int for 'InterpMethod'",
        type = "value"
      },
      BEZIER_CURVE = {
        description = "(Readonly) int for 'InterpolationMode'",
        type = "value"
      },
      CATMULL_ROM_CURVE = {
        description = "(Readonly) int for 'InterpolationMode'",
        type = "value"
      },
      LINEAR_CURVE = {
        description = "(Readonly) int for 'InterpolationMode'",
        type = "value"
      },
      CATMULL_ROM_FULL_CURVE = {
        description = "(Readonly) int for 'InterpolationMode'",
        type = "value"
      },
      OUTSIDE = {
        description = "(Readonly) int for 'Intersection'",
        type = "value"
      },
      INTERSECTS = {
        description = "(Readonly) int for 'Intersection'",
        type = "value"
      },
      INSIDE = {
        description = "(Readonly) int for 'Intersection'",
        type = "value"
      },
      JSONNT_NAN = {
        description = "(Readonly) int for 'JSONNumberType'",
        type = "value"
      },
      JSONNT_INT = {
        description = "(Readonly) int for 'JSONNumberType'",
        type = "value"
      },
      JSONNT_UINT = {
        description = "(Readonly) int for 'JSONNumberType'",
        type = "value"
      },
      JSONNT_FLOAT_DOUBLE = {
        description = "(Readonly) int for 'JSONNumberType'",
        type = "value"
      },
      JSON_NULL = {
        description = "(Readonly) int for 'JSONValueType'",
        type = "value"
      },
      JSON_BOOL = {
        description = "(Readonly) int for 'JSONValueType'",
        type = "value"
      },
      JSON_NUMBER = {
        description = "(Readonly) int for 'JSONValueType'",
        type = "value"
      },
      JSON_STRING = {
        description = "(Readonly) int for 'JSONValueType'",
        type = "value"
      },
      JSON_ARRAY = {
        description = "(Readonly) int for 'JSONValueType'",
        type = "value"
      },
      JSON_OBJECT = {
        description = "(Readonly) int for 'JSONValueType'",
        type = "value"
      },
      LM_FREE = {
        description = "(Readonly) int for 'LayoutMode'",
        type = "value"
      },
      LM_HORIZONTAL = {
        description = "(Readonly) int for 'LayoutMode'",
        type = "value"
      },
      LM_VERTICAL = {
        description = "(Readonly) int for 'LayoutMode'",
        type = "value"
      },
      ELEMENT_POSITION = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_NORMAL = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_COLOR = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_TEXCOORD1 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_TEXCOORD2 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_CUBETEXCOORD1 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_CUBETEXCOORD2 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_TANGENT = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_BLENDWEIGHTS = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_BLENDINDICES = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_INSTANCEMATRIX1 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_INSTANCEMATRIX2 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_INSTANCEMATRIX3 = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      ELEMENT_OBJECTINDEX = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      MAX_LEGACY_VERTEX_ELEMENTS = {
        description = "(Readonly) int for 'LegacyVertexElement'",
        type = "value"
      },
      LIGHT_DIRECTIONAL = {
        description = "(Readonly) int for 'LightType'",
        type = "value"
      },
      LIGHT_SPOT = {
        description = "(Readonly) int for 'LightType'",
        type = "value"
      },
      LIGHT_POINT = {
        description = "(Readonly) int for 'LightType'",
        type = "value"
      },
      LOAD_RESOURCES_ONLY = {
        description = "(Readonly) int for 'LoadMode'",
        type = "value"
      },
      LOAD_SCENE = {
        description = "(Readonly) int for 'LoadMode'",
        type = "value"
      },
      LOAD_SCENE_AND_RESOURCES = {
        description = "(Readonly) int for 'LoadMode'",
        type = "value"
      },
      LOCK_NONE = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LOCK_HARDWARE = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LOCK_SHADOW = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LOCK_SCRATCH = {
        description = "(Readonly) int for 'LockState'",
        type = "value"
      },
      LM_DEFAULT = {
        description = "(Readonly) int for 'LoopMode2D'",
        type = "value"
      },
      LM_FORCE_LOOPED = {
        description = "(Readonly) int for 'LoopMode2D'",
        type = "value"
      },
      LM_FORCE_CLAMPED = {
        description = "(Readonly) int for 'LoopMode2D'",
        type = "value"
      },
      MM_ABSOLUTE = {
        description = "(Readonly) int for 'MouseMode'",
        type = "value"
      },
      MM_RELATIVE = {
        description = "(Readonly) int for 'MouseMode'",
        type = "value"
      },
      MM_WRAP = {
        description = "(Readonly) int for 'MouseMode'",
        type = "value"
      },
      MM_FREE = {
        description = "(Readonly) int for 'MouseMode'",
        type = "value"
      },
      NAVIGATIONPUSHINESS_LOW = {
        description = "(Readonly) int for 'NavigationPushiness'",
        type = "value"
      },
      NAVIGATIONPUSHINESS_MEDIUM = {
        description = "(Readonly) int for 'NavigationPushiness'",
        type = "value"
      },
      NAVIGATIONPUSHINESS_HIGH = {
        description = "(Readonly) int for 'NavigationPushiness'",
        type = "value"
      },
      NAVIGATIONPUSHINESS_NONE = {
        description = "(Readonly) int for 'NavigationPushiness'",
        type = "value"
      },
      NAVIGATIONQUALITY_LOW = {
        description = "(Readonly) int for 'NavigationQuality'",
        type = "value"
      },
      NAVIGATIONQUALITY_MEDIUM = {
        description = "(Readonly) int for 'NavigationQuality'",
        type = "value"
      },
      NAVIGATIONQUALITY_HIGH = {
        description = "(Readonly) int for 'NavigationQuality'",
        type = "value"
      },
      NAVMESH_PARTITION_WATERSHED = {
        description = "(Readonly) int for 'NavmeshPartitionType'",
        type = "value"
      },
      NAVMESH_PARTITION_MONOTONE = {
        description = "(Readonly) int for 'NavmeshPartitionType'",
        type = "value"
      },
      O_HORIZONTAL = {
        description = "(Readonly) int for 'Orientation'",
        type = "value"
      },
      O_VERTICAL = {
        description = "(Readonly) int for 'Orientation'",
        type = "value"
      },
      O_ORTHOGONAL = {
        description = "(Readonly) int for 'Orientation2D'",
        type = "value"
      },
      O_ISOMETRIC = {
        description = "(Readonly) int for 'Orientation2D'",
        type = "value"
      },
      O_STAGGERED = {
        description = "(Readonly) int for 'Orientation2D'",
        type = "value"
      },
      O_HEXAGONAL = {
        description = "(Readonly) int for 'Orientation2D'",
        type = "value"
      },
      LIGHTING_UNLIT = {
        description = "(Readonly) int for 'PassLightingMode'",
        type = "value"
      },
      LIGHTING_PERVERTEX = {
        description = "(Readonly) int for 'PassLightingMode'",
        type = "value"
      },
      LIGHTING_PERPIXEL = {
        description = "(Readonly) int for 'PassLightingMode'",
        type = "value"
      },
      TRIANGLE_LIST = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      LINE_LIST = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      POINT_LIST = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      TRIANGLE_STRIP = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      LINE_STRIP = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      TRIANGLE_FAN = {
        description = "(Readonly) int for 'PrimitiveType'",
        type = "value"
      },
      RAY_AABB = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      RAY_OBB = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      RAY_TRIANGLE = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      RAY_TRIANGLE_UV = {
        description = "(Readonly) int for 'RayQueryLevel'",
        type = "value"
      },
      SORT_FRONTTOBACK = {
        description = "(Readonly) int for 'RenderCommandSortMode'",
        type = "value"
      },
      SORT_BACKTOFRONT = {
        description = "(Readonly) int for 'RenderCommandSortMode'",
        type = "value"
      },
      CMD_NONE = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_CLEAR = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_SCENEPASS = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_QUAD = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_FORWARDLIGHTS = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_LIGHTVOLUMES = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_RENDERUI = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      CMD_SENDEVENT = {
        description = "(Readonly) int for 'RenderCommandType'",
        type = "value"
      },
      SURFACE_MANUALUPDATE = {
        description = "(Readonly) int for 'RenderSurfaceUpdateMode'",
        type = "value"
      },
      SURFACE_UPDATEVISIBLE = {
        description = "(Readonly) int for 'RenderSurfaceUpdateMode'",
        type = "value"
      },
      SURFACE_UPDATEALWAYS = {
        description = "(Readonly) int for 'RenderSurfaceUpdateMode'",
        type = "value"
      },
      SIZE_ABSOLUTE = {
        description = "(Readonly) int for 'RenderTargetSizeMode'",
        type = "value"
      },
      SIZE_VIEWPORTDIVISOR = {
        description = "(Readonly) int for 'RenderTargetSizeMode'",
        type = "value"
      },
      SIZE_VIEWPORTMULTIPLIER = {
        description = "(Readonly) int for 'RenderTargetSizeMode'",
        type = "value"
      },
      VS = {
        description = "(Readonly) int for 'ShaderType'",
        type = "value"
      },
      PS = {
        description = "(Readonly) int for 'ShaderType'",
        type = "value"
      },
      SHADOWQUALITY_SIMPLE_16BIT = {
        description = "(Readonly) int for 'ShadowQuality'",
        type = "value"
      },
      SHADOWQUALITY_SIMPLE_24BIT = {
        description = "(Readonly) int for 'ShadowQuality'",
        type = "value"
      },
      SHADOWQUALITY_PCF_16BIT = {
        description = "(Readonly) int for 'ShadowQuality'",
        type = "value"
      },
      SHADOWQUALITY_PCF_24BIT = {
        description = "(Readonly) int for 'ShadowQuality'",
        type = "value"
      },
      SHADOWQUALITY_VSM = {
        description = "(Readonly) int for 'ShadowQuality'",
        type = "value"
      },
      SHADOWQUALITY_BLUR_VSM = {
        description = "(Readonly) int for 'ShadowQuality'",
        type = "value"
      },
      SHAPE_BOX = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_SPHERE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_STATICPLANE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CYLINDER = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CAPSULE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CONE = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_TRIANGLEMESH = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_CONVEXHULL = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      SHAPE_TERRAIN = {
        description = "(Readonly) int for 'ShapeType'",
        type = "value"
      },
      OP_KEEP = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_ZERO = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_REF = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_INCR = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      OP_DECR = {
        description = "(Readonly) int for 'StencilOp'",
        type = "value"
      },
      TE_NONE = {
        description = "(Readonly) int for 'TextEffect'",
        type = "value"
      },
      TE_SHADOW = {
        description = "(Readonly) int for 'TextEffect'",
        type = "value"
      },
      TE_STROKE = {
        description = "(Readonly) int for 'TextEffect'",
        type = "value"
      },
      ADDRESS_WRAP = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      ADDRESS_MIRROR = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      ADDRESS_CLAMP = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      ADDRESS_BORDER = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      MAX_ADDRESSMODES = {
        description = "(Readonly) int for 'TextureAddressMode'",
        type = "value"
      },
      COORD_U = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      COORD_V = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      COORD_W = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      MAX_COORDS = {
        description = "(Readonly) int for 'TextureCoordinate'",
        type = "value"
      },
      FILTER_NEAREST = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_BILINEAR = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_TRILINEAR = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_ANISOTROPIC = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_NEAREST_ANISOTROPIC = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      FILTER_DEFAULT = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      MAX_FILTERMODES = {
        description = "(Readonly) int for 'TextureFilterMode'",
        type = "value"
      },
      TU_DIFFUSE = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_ALBEDOBUFFER = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_NORMAL = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_NORMALBUFFER = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_SPECULAR = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_EMISSIVE = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TU_ENVIRONMENT = {
        description = "(Readonly) int for 'TextureUnit'",
        type = "value"
      },
      TEXTURE_STATIC = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TEXTURE_DYNAMIC = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TEXTURE_RENDERTARGET = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      TEXTURE_DEPTHSTENCIL = {
        description = "(Readonly) int for 'TextureUsage'",
        type = "value"
      },
      LT_TILE_LAYER = {
        description = "(Readonly) int for 'TileMapLayerType2D'",
        type = "value"
      },
      LT_OBJECT_GROUP = {
        description = "(Readonly) int for 'TileMapLayerType2D'",
        type = "value"
      },
      LT_IMAGE_LAYER = {
        description = "(Readonly) int for 'TileMapLayerType2D'",
        type = "value"
      },
      LT_INVALID = {
        description = "(Readonly) int for 'TileMapLayerType2D'",
        type = "value"
      },
      OT_RECTANGLE = {
        description = "(Readonly) int for 'TileMapObjectType2D'",
        type = "value"
      },
      OT_ELLIPSE = {
        description = "(Readonly) int for 'TileMapObjectType2D'",
        type = "value"
      },
      OT_POLYGON = {
        description = "(Readonly) int for 'TileMapObjectType2D'",
        type = "value"
      },
      OT_POLYLINE = {
        description = "(Readonly) int for 'TileMapObjectType2D'",
        type = "value"
      },
      OT_TILE = {
        description = "(Readonly) int for 'TileMapObjectType2D'",
        type = "value"
      },
      OT_INVALID = {
        description = "(Readonly) int for 'TileMapObjectType2D'",
        type = "value"
      },
      TT_FACE_CAMERA = {
        description = "(Readonly) int for 'TrailType'",
        type = "value"
      },
      TT_BONE = {
        description = "(Readonly) int for 'TrailType'",
        type = "value"
      },
      TS_LOCAL = {
        description = "(Readonly) int for 'TransformSpace'",
        type = "value"
      },
      TS_PARENT = {
        description = "(Readonly) int for 'TransformSpace'",
        type = "value"
      },
      TS_WORLD = {
        description = "(Readonly) int for 'TransformSpace'",
        type = "value"
      },
      TM_BREADTH_FIRST = {
        description = "(Readonly) int for 'TraversalMode'",
        type = "value"
      },
      TM_DEPTH_FIRST = {
        description = "(Readonly) int for 'TraversalMode'",
        type = "value"
      },
      VAR_NONE = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_BOOL = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_FLOAT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VECTOR2 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VECTOR3 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VECTOR4 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_QUATERNION = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_COLOR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_STRING = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_BUFFER = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VOIDPTR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_RESOURCEREF = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_RESOURCEREFLIST = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VARIANTVECTOR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_VARIANTMAP = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INTRECT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INTVECTOR2 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_PTR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_MATRIX3 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_MATRIX3X4 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_MATRIX4 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_DOUBLE = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_STRINGVECTOR = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_RECT = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INTVECTOR3 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      VAR_INT64 = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      MAX_VAR_TYPES = {
        description = "(Readonly) int for 'VariantType'",
        type = "value"
      },
      SEM_POSITION = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_NORMAL = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_BINORMAL = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_TANGENT = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_TEXCOORD = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_COLOR = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_BLENDWEIGHTS = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_BLENDINDICES = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      SEM_OBJECTINDEX = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      MAX_VERTEX_ELEMENT_SEMANTICS = {
        description = "(Readonly) int for 'VertexElementSemantic'",
        type = "value"
      },
      TYPE_INT = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      TYPE_FLOAT = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      TYPE_VECTOR2 = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      TYPE_VECTOR3 = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      TYPE_VECTOR4 = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      TYPE_UBYTE4 = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      TYPE_UBYTE4_NORM = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      MAX_VERTEX_ELEMENT_TYPES = {
        description = "(Readonly) int for 'VertexElementType'",
        type = "value"
      },
      VA_TOP = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      VA_CENTER = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      VA_BOTTOM = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      VA_CUSTOM = {
        description = "(Readonly) int for 'VerticalAlignment'",
        type = "value"
      },
      DRAG_NONE = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_MOVE = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_TOPLEFT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_TOP = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_TOPRIGHT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_RIGHT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_BOTTOMRIGHT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_BOTTOM = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_BOTTOMLEFT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      DRAG_RESIZE_LEFT = {
        description = "(Readonly) int for 'WindowDragMode'",
        type = "value"
      },
      WM_LOOP = {
        description = "(Readonly) int for 'WrapMode'",
        type = "value"
      },
      WM_ONCE = {
        description = "(Readonly) int for 'WrapMode'",
        type = "value"
      },
      WM_CLAMP = {
        description = "(Readonly) int for 'WrapMode'",
        type = "value"
      },

  -- Global Functions

      Abs = {
        args = "(float value)",
        returns = "(float)",
        type = "function"
      },
      AbsInt = {
        args = "(int value)",
        returns = "(int)",
        type = "function"
      },
      Acos = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      AddTrailingSlash = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      Asin = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      Atan = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      Atan2 = {
        args = "(float y, float x)",
        returns = "(float)",
        type = "function"
      },
      Ceil = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      CeilToInt = {
        args = "(float x)",
        returns = "(int)",
        type = "function"
      },
      Clamp = {
        args = "(float value, float min, float max)",
        returns = "(float)",
        type = "function"
      },
      ClampInt = {
        args = "(int value, int min, int max)",
        returns = "(int)",
        type = "function"
      },
      CompressVectorBuffer = {
        args = "(VectorBuffer& src)",
        returns = "(VectorBuffer)",
        type = "function"
      },
      Cos = {
        args = "(float angle)",
        returns = "(float)",
        type = "function"
      },
      CountSetBits = {
        args = "(unsigned value)",
        returns = "(unsigned)",
        type = "function"
      },
      DecompressVectorBuffer = {
        args = "(VectorBuffer& src)",
        returns = "(VectorBuffer)",
        type = "function"
      },
      Equals = {
        args = "(float lhs, float rhs)",
        returns = "(bool)",
        type = "function"
      },
      ErrorDialog = {
        args = "(const String title, const String message)",
        returns = "()",
        type = "function"
      },
      ErrorExit = {
        args = "(const String message = String::EMPTY, int exitCode = EXIT_FAILURE)",
        returns = "()",
        type = "function"
      },
      Floor = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      FloorToInt = {
        args = "(float x)",
        returns = "(int)",
        type = "function"
      },
      Fract = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      GetArguments = {
        args = "()",
        returns = "(const Vector<String>&)",
        valuetype = "Vector<String>",
        type = "function"
      },
      GetAudio = {
        args = "()",
        returns = "(Audio*)",
        valuetype = "Audio",
        type = "function"
      },
      GetCache = {
        args = "()",
        returns = "(ResourceCache*)",
        valuetype = "ResourceCache",
        type = "function"
      },
      GetConsole = {
        args = "()",
        returns = "(Console*)",
        valuetype = "Console",
        type = "function"
      },
      GetConsoleInput = {
        args = "()",
        returns = "(String)",
        type = "function"
      },
      GetContext = {
        args = "()",
        returns = "(Context*)",
        valuetype = "Context",
        type = "function"
      },
      GetDBAPI = {
        args = "()",
        returns = "(DBAPI)",
        type = "function"
      },
      GetDatabase = {
        args = "()",
        returns = "(Database*)",
        valuetype = "Database",
        type = "function"
      },
      GetDebugHud = {
        args = "()",
        returns = "(DebugHud*)",
        valuetype = "DebugHud",
        type = "function"
      },
      GetEngine = {
        args = "()",
        returns = "(Engine*)",
        valuetype = "Engine",
        type = "function"
      },
      GetEventHandler = {
        args = "()",
        returns = "(EventHandler*)",
        valuetype = "EventHandler",
        type = "function"
      },
      GetEventSender = {
        args = "()",
        returns = "(Object*)",
        valuetype = "Object",
        type = "function"
      },
      GetExecuteConsoleCommands = {
        args = "()",
        returns = "(bool)",
        type = "function"
      },
      GetExtension = {
        args = "(const String fullPath, bool lowercaseExtension = true)",
        returns = "(String)",
        type = "function"
      },
      GetFileName = {
        args = "(const String fullPath)",
        returns = "(String)",
        type = "function"
      },
      GetFileNameAndExtension = {
        args = "(const String fullPath, bool lowercaseExtension = false)",
        returns = "(String)",
        type = "function"
      },
      GetFileSizeString = {
        args = "(long memorySize)",
        returns = "(String)",
        type = "function"
      },
      GetFileSystem = {
        args = "()",
        returns = "(FileSystem*)",
        valuetype = "FileSystem",
        type = "function"
      },
      GetGlobalVar = {
        args = "(const String key)",
        returns = "(Variant)",
        type = "function"
      },
      GetGlobalVars = {
        args = "()",
        returns = "(VariantMap&)",
        valuetype = "VariantMap",
        type = "function"
      },
      GetGraphics = {
        args = "()",
        returns = "(Graphics*)",
        valuetype = "Graphics",
        type = "function"
      },
      GetInput = {
        args = "()",
        returns = "(Input*)",
        valuetype = "Input",
        type = "function"
      },
      GetInternalPath = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      GetLocalization = {
        args = "()",
        returns = "(Localization*)",
        valuetype = "Localization",
        type = "function"
      },
      GetLog = {
        args = "()",
        returns = "(Log*)",
        valuetype = "Log",
        type = "function"
      },
      GetMiniDumpDir = {
        args = "()",
        returns = "(String)",
        type = "function"
      },
      GetNativePath = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      GetNetwork = {
        args = "()",
        returns = "(Network*)",
        valuetype = "Network",
        type = "function"
      },
      GetNumLogicalCPUs = {
        args = "()",
        returns = "(unsigned)",
        type = "function"
      },
      GetNumPhysicalCPUs = {
        args = "()",
        returns = "(unsigned)",
        type = "function"
      },
      GetParentPath = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      GetPath = {
        args = "(const String fullPath)",
        returns = "(String)",
        type = "function"
      },
      GetPlatform = {
        args = "()",
        returns = "(String)",
        type = "function"
      },
      GetRandomSeed = {
        args = "()",
        returns = "(unsigned)",
        type = "function"
      },
      GetRenderer = {
        args = "()",
        returns = "(Renderer*)",
        valuetype = "Renderer",
        type = "function"
      },
      GetTime = {
        args = "()",
        returns = "(Time*)",
        valuetype = "Time",
        type = "function"
      },
      GetUI = {
        args = "()",
        returns = "(UI*)",
        valuetype = "UI",
        type = "function"
      },
      HasSubscribedToEvent = {
        args = "(Object* sender, const String eventName)",
        returns = "(bool)",
        type = "function"
      },
      HasSubscribedToEvent = {
        args = "(const String eventName)",
        returns = "(bool)",
        type = "function"
      },
      InverseLerp = {
        args = "(float lhs, float rhs, float x)",
        returns = "(float)",
        type = "function"
      },
      IsAbsolutePath = {
        args = "(const String pathName)",
        returns = "(bool)",
        type = "function"
      },
      IsAlpha = {
        args = "(unsigned ch)",
        returns = "(bool)",
        type = "function"
      },
      IsDigit = {
        args = "(unsigned ch)",
        returns = "(bool)",
        type = "function"
      },
      IsNaN = {
        args = "(float value)",
        returns = "(bool)",
        type = "function"
      },
      IsPowerOfTwo = {
        args = "(unsigned value)",
        returns = "(bool)",
        type = "function"
      },
      Lerp = {
        args = "(float lhs, float rhs, float t)",
        returns = "(float)",
        type = "function"
      },
      Ln = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      Max = {
        args = "(float lhs, float rhs)",
        returns = "(float)",
        type = "function"
      },
      MaxInt = {
        args = "(int lhs, int rhs)",
        returns = "(int)",
        type = "function"
      },
      Min = {
        args = "(float lhs, float rhs)",
        returns = "(float)",
        type = "function"
      },
      MinInt = {
        args = "(int lhs, int rhs)",
        returns = "(int)",
        type = "function"
      },
      Mod = {
        args = "(float x, float y)",
        returns = "(float)",
        type = "function"
      },
      NextPowerOfTwo = {
        args = "(unsigned value)",
        returns = "(unsigned)",
        type = "function"
      },
      OpenConsoleWindow = {
        args = "()",
        returns = "()",
        type = "function"
      },
      Pow = {
        args = "(float x, float y)",
        returns = "(float)",
        type = "function"
      },
      PrintLine = {
        args = "(const String str, bool error = false)",
        returns = "()",
        type = "function"
      },
      Rand = {
        args = "()",
        returns = "(int)",
        type = "function"
      },
      RandStandardNormal = {
        args = "()",
        returns = "(float)",
        type = "function"
      },
      Random = {
        args = "(float min, float max)",
        returns = "(float)",
        type = "function"
      },
      Random = {
        args = "(float range)",
        returns = "(float)",
        type = "function"
      },
      Random = {
        args = "()",
        returns = "(float)",
        type = "function"
      },
      RandomInt = {
        args = "(int range)",
        returns = "(int)",
        type = "function"
      },
      RandomInt = {
        args = "(int min, int max)",
        returns = "(int)",
        type = "function"
      },
      RandomNormal = {
        args = "(float meanValue, float variance)",
        returns = "(float)",
        type = "function"
      },
      RegisterEventName = {
        args = "(const String eventName)",
        returns = "()",
        type = "function"
      },
      RemoveTrailingSlash = {
        args = "(const String pathName)",
        returns = "(String)",
        type = "function"
      },
      ReplaceExtension = {
        args = "(const String fullPath, const String newExtension)",
        returns = "(String)",
        type = "function"
      },
      Round = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      RoundToInt = {
        args = "(float x)",
        returns = "(int)",
        type = "function"
      },
      SDBMHash = {
        args = "(unsigned hash, char c)",
        returns = "(unsigned)",
        type = "function"
      },
      SendEvent = {
        args = "(const String eventName, VariantMap& eventData)",
        returns = "()",
        type = "function"
      },
      SetExecuteConsoleCommands = {
        args = "(bool enable)",
        returns = "()",
        type = "function"
      },
      SetGlobalVar = {
        args = "(const String key, Variant value)",
        returns = "()",
        type = "function"
      },
      SetMiniDumpDir = {
        args = "(const String pathName)",
        returns = "()",
        type = "function"
      },
      SetRandomSeed = {
        args = "(unsigned seed)",
        returns = "()",
        type = "function"
      },
      Sign = {
        args = "(float value)",
        returns = "(float)",
        type = "function"
      },
      Sin = {
        args = "(float angle)",
        returns = "(float)",
        type = "function"
      },
      SmoothStep = {
        args = "(float lhs, float rhs, float t)",
        returns = "(float)",
        type = "function"
      },
      Sqrt = {
        args = "(float x)",
        returns = "(float)",
        type = "function"
      },
      StableRandom = {
        args = "(const Vector3& seed)",
        returns = "(float)",
        type = "function"
      },
      StableRandom = {
        args = "(float seed)",
        returns = "(float)",
        type = "function"
      },
      StableRandom = {
        args = "(const Vector2& seed)",
        returns = "(float)",
        type = "function"
      },
      SubscribeToEvent = {
        args = "(const String eventName, void* functionOrFunctionName)",
        returns = "()",
        type = "function"
      },
      SubscribeToEvent = {
        args = "(void* sender, const String eventName, void* functionOrFunctionName)",
        returns = "()",
        type = "function"
      },
      Tan = {
        args = "(float angle)",
        returns = "(float)",
        type = "function"
      },
      ToBool = {
        args = "(const String source)",
        returns = "(bool)",
        type = "function"
      },
      ToColor = {
        args = "(const String source)",
        returns = "(Color)",
        type = "function"
      },
      ToFloat = {
        args = "(const String source)",
        returns = "(float)",
        type = "function"
      },
      ToInt = {
        args = "(const String source, int base = 10)",
        returns = "(int)",
        type = "function"
      },
      ToInt64 = {
        args = "(const String source, int base = 10)",
        returns = "(int)",
        type = "function"
      },
      ToIntRect = {
        args = "(const String source)",
        returns = "(IntRect)",
        type = "function"
      },
      ToIntVector2 = {
        args = "(const String source)",
        returns = "(IntVector2)",
        type = "function"
      },
      ToIntVector3 = {
        args = "(const String source)",
        returns = "(IntVector3)",
        type = "function"
      },
      ToLower = {
        args = "(unsigned ch)",
        returns = "(unsigned)",
        type = "function"
      },
      ToMatrix3 = {
        args = "(const String source)",
        returns = "(Matrix3)",
        type = "function"
      },
      ToMatrix3x4 = {
        args = "(const String source)",
        returns = "(Matrix3x4)",
        type = "function"
      },
      ToMatrix4 = {
        args = "(const String source)",
        returns = "(Matrix4)",
        type = "function"
      },
      ToQuaternion = {
        args = "(const String source)",
        returns = "(Quaternion)",
        type = "function"
      },
      ToRect = {
        args = "(const String source)",
        returns = "(Rect)",
        type = "function"
      },
      ToString = {
        args = "(void* value)",
        returns = "(String)",
        type = "function"
      },
      ToStringHex = {
        args = "(unsigned value)",
        returns = "(String)",
        type = "function"
      },
      ToUInt = {
        args = "(const String source, int base = 10)",
        returns = "(unsigned)",
        type = "function"
      },
      ToUInt64 = {
        args = "(const String source, int base = 10)",
        returns = "(int)",
        type = "function"
      },
      ToUpper = {
        args = "(unsigned ch)",
        returns = "(unsigned)",
        type = "function"
      },
      ToVector2 = {
        args = "(const String source)",
        returns = "(Vector2)",
        type = "function"
      },
      ToVector3 = {
        args = "(const String source)",
        returns = "(Vector3)",
        type = "function"
      },
      ToVector4 = {
        args = "(const String source, bool allowMissingCoords = false)",
        returns = "(Vector4)",
        type = "function"
      },
      UnsubscribeFromAllEvents = {
        args = "()",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromAllEventsExcept = {
        args = "(const Vector<String>& exceptionNames)",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromEvent = {
        args = "(Object* sender, const String eventName)",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromEvent = {
        args = "(const String eventName)",
        returns = "()",
        type = "function"
      },
      UnsubscribeFromEvents = {
        args = "(Object* sender)",
        returns = "()",
        type = "function"
      },
      VectorCeil = {
        args = "(const Vector2& vec)",
        returns = "(Vector2)",
        type = "function"
      },
      VectorCeil = {
        args = "(const Vector4& vec)",
        returns = "(Vector4)",
        type = "function"
      },
      VectorCeil = {
        args = "(const Vector3& vec)",
        returns = "(Vector3)",
        type = "function"
      },
      VectorCeilToInt = {
        args = "(const Vector3& vec)",
        returns = "(IntVector3)",
        type = "function"
      },
      VectorCeilToInt = {
        args = "(const Vector2& vec)",
        returns = "(IntVector2)",
        type = "function"
      },
      VectorFloor = {
        args = "(const Vector2& vec)",
        returns = "(Vector2)",
        type = "function"
      },
      VectorFloor = {
        args = "(const Vector3& vec)",
        returns = "(Vector3)",
        type = "function"
      },
      VectorFloor = {
        args = "(const Vector4& vec)",
        returns = "(Vector4)",
        type = "function"
      },
      VectorFloorToInt = {
        args = "(const Vector2& vec)",
        returns = "(IntVector2)",
        type = "function"
      },
      VectorFloorToInt = {
        args = "(const Vector3& vec)",
        returns = "(IntVector3)",
        type = "function"
      },
      VectorLerp = {
        args = "(const Vector2& lhs, const Vector2& rhs, const Vector2& t)",
        returns = "(Vector2)",
        type = "function"
      },
      VectorLerp = {
        args = "(const Vector4& lhs, const Vector4& rhs, const Vector4& t)",
        returns = "(Vector4)",
        type = "function"
      },
      VectorLerp = {
        args = "(const Vector3& lhs, const Vector3& rhs, const Vector3& t)",
        returns = "(Vector3)",
        type = "function"
      },
      VectorMax = {
        args = "(const Vector4& lhs, const Vector4& rhs)",
        returns = "(Vector4)",
        type = "function"
      },
      VectorMax = {
        args = "(const Vector2& lhs, const Vector2& rhs)",
        returns = "(Vector2)",
        type = "function"
      },
      VectorMax = {
        args = "(const IntVector2& lhs, const IntVector2& rhs)",
        returns = "(IntVector2)",
        type = "function"
      },
      VectorMax = {
        args = "(const IntVector3& lhs, const IntVector3& rhs)",
        returns = "(IntVector3)",
        type = "function"
      },
      VectorMax = {
        args = "(const Vector3& lhs, const Vector3& rhs)",
        returns = "(Vector3)",
        type = "function"
      },
      VectorMin = {
        args = "(const Vector2& lhs, const Vector2& rhs)",
        returns = "(Vector2)",
        type = "function"
      },
      VectorMin = {
        args = "(const IntVector3& lhs, const IntVector3& rhs)",
        returns = "(IntVector3)",
        type = "function"
      },
      VectorMin = {
        args = "(const Vector4& lhs, const Vector4& rhs)",
        returns = "(Vector4)",
        type = "function"
      },
      VectorMin = {
        args = "(const Vector3& lhs, const Vector3& rhs)",
        returns = "(Vector3)",
        type = "function"
      },
      VectorMin = {
        args = "(const IntVector2& lhs, const IntVector2& rhs)",
        returns = "(IntVector2)",
        type = "function"
      },
      VectorRound = {
        args = "(const Vector4& vec)",
        returns = "(Vector4)",
        type = "function"
      },
      VectorRound = {
        args = "(const Vector2& vec)",
        returns = "(Vector2)",
        type = "function"
      },
      VectorRound = {
        args = "(const Vector3& vec)",
        returns = "(Vector3)",
        type = "function"
      },
      VectorRoundToInt = {
        args = "(const Vector3& vec)",
        returns = "(IntVector3)",
        type = "function"
      },
      VectorRoundToInt = {
        args = "(const Vector2& vec)",
        returns = "(IntVector2)",
        type = "function"
      },

      audio = {
        valuetype = "Audio",
        description = "(Readonly) Audio*",
        type = "value"
      },
      context = {
        valuetype = "Context",
        description = "(Readonly) Context*",
        type = "value"
      },
      eventSender = {
        valuetype = "EventSender",
        description = "(Readonly) EventSender*",
        type = "value"
      },
      eventHandler = {
        valuetype = "EventHandler",
        description = "(Readonly) EventHandler*",
        type = "value"
      },
      time = {
        valuetype = "Time",
        description = "(Readonly) Time*",
        type = "value"
      },
      database = {
        valuetype = "Database",
        description = "(Readonly) Database*",
        type = "value"
      },
      console = {
        valuetype = "Console",
        description = "(Readonly) Console*",
        type = "value"
      },
      debugHud = {
        valuetype = "DebugHud",
        description = "(Readonly) DebugHud*",
        type = "value"
      },
      engine = {
        valuetype = "Engine",
        description = "(Readonly) Engine*",
        type = "value"
      },
      graphics = {
        valuetype = "Graphics",
        description = "(Readonly) Graphics*",
        type = "value"
      },
      renderer = {
        valuetype = "Renderer",
        description = "(Readonly) Renderer*",
        type = "value"
      },
      fileSystem = {
        valuetype = "FileSystem",
        description = "(Readonly) FileSystem*",
        type = "value"
      },
      log = {
        valuetype = "Log",
        description = "(Readonly) Log*",
        type = "value"
      },
      input = {
        valuetype = "Input",
        description = "(Readonly) Input*",
        type = "value"
      },
      network = {
        valuetype = "Network",
        description = "(Readonly) Network*",
        type = "value"
      },
      cache = {
        valuetype = "ResourceCache",
        description = "(Readonly) ResourceCache*",
        type = "value"
      },
      localization = {
        valuetype = "Localization",
        description = "(Readonly) Localization*",
        type = "value"
      },
      ui = {
        valuetype = "UI",
        description = "(Readonly) UI*",
        type = "value"
      },

  -- Global Constants

      ANIMATION_LOD_BASESCALE = {
        description = "const float",
        type = "value"
      },
      CHANNEL_POSITION = {
        description = "const char",
        type = "value"
      },
      CHANNEL_ROTATION = {
        description = "const char",
        type = "value"
      },
      CHANNEL_SCALE = {
        description = "const char",
        type = "value"
      },
      CLEAR_COLOR = {
        description = "const unsigned",
        type = "value"
      },
      CLEAR_DEPTH = {
        description = "const unsigned",
        type = "value"
      },
      CLEAR_STENCIL = {
        description = "const unsigned",
        type = "value"
      },
      CONTROLLER_AXIS_LEFTX = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_LEFTY = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_RIGHTX = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_RIGHTY = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_TRIGGERLEFT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_AXIS_TRIGGERRIGHT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_A = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_B = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_BACK = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_DOWN = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_LEFT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_RIGHT = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_DPAD_UP = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_GUIDE = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_LEFTSHOULDER = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_LEFTSTICK = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_RIGHTSHOULDER = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_RIGHTSTICK = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_START = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_X = {
        description = "const int",
        type = "value"
      },
      CONTROLLER_BUTTON_Y = {
        description = "const int",
        type = "value"
      },
      DD_DISABLED = {
        description = "const unsigned",
        type = "value"
      },
      DD_SOURCE = {
        description = "const unsigned",
        type = "value"
      },
      DD_SOURCE_AND_TARGET = {
        description = "const unsigned",
        type = "value"
      },
      DD_TARGET = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_ALL = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_EVENTPROFILER = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_MEMORY = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_MODE = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_NONE = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_PROFILER = {
        description = "const unsigned",
        type = "value"
      },
      DEBUGHUD_SHOW_STATS = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_LIGHTMASK = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_SHADOWMASK = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_VIEWMASK = {
        description = "const unsigned",
        type = "value"
      },
      DEFAULT_ZONEMASK = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_ANY = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_GEOMETRY = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_GEOMETRY2D = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_LIGHT = {
        description = "const unsigned",
        type = "value"
      },
      DRAWABLE_ZONE = {
        description = "const unsigned",
        type = "value"
      },
      FIRST_LOCAL_ID = {
        description = "const unsigned",
        type = "value"
      },
      FIRST_REPLICATED_ID = {
        description = "const unsigned",
        type = "value"
      },
      HAT_CENTER = {
        description = "const int",
        type = "value"
      },
      HAT_DOWN = {
        description = "const int",
        type = "value"
      },
      HAT_LEFT = {
        description = "const int",
        type = "value"
      },
      HAT_RIGHT = {
        description = "const int",
        type = "value"
      },
      HAT_UP = {
        description = "const int",
        type = "value"
      },
      KEY_0 = {
        description = "const int",
        type = "value"
      },
      KEY_1 = {
        description = "const int",
        type = "value"
      },
      KEY_2 = {
        description = "const int",
        type = "value"
      },
      KEY_3 = {
        description = "const int",
        type = "value"
      },
      KEY_4 = {
        description = "const int",
        type = "value"
      },
      KEY_5 = {
        description = "const int",
        type = "value"
      },
      KEY_6 = {
        description = "const int",
        type = "value"
      },
      KEY_7 = {
        description = "const int",
        type = "value"
      },
      KEY_8 = {
        description = "const int",
        type = "value"
      },
      KEY_9 = {
        description = "const int",
        type = "value"
      },
      KEY_A = {
        description = "const int",
        type = "value"
      },
      KEY_ALT = {
        description = "const int",
        type = "value"
      },
      KEY_APPLICATION = {
        description = "const int",
        type = "value"
      },
      KEY_B = {
        description = "const int",
        type = "value"
      },
      KEY_BACKSPACE = {
        description = "const int",
        type = "value"
      },
      KEY_C = {
        description = "const int",
        type = "value"
      },
      KEY_CAPSLOCK = {
        description = "const int",
        type = "value"
      },
      KEY_CTRL = {
        description = "const int",
        type = "value"
      },
      KEY_D = {
        description = "const int",
        type = "value"
      },
      KEY_DELETE = {
        description = "const int",
        type = "value"
      },
      KEY_DOWN = {
        description = "const int",
        type = "value"
      },
      KEY_E = {
        description = "const int",
        type = "value"
      },
      KEY_END = {
        description = "const int",
        type = "value"
      },
      KEY_ESCAPE = {
        description = "const int",
        type = "value"
      },
      KEY_F = {
        description = "const int",
        type = "value"
      },
      KEY_F1 = {
        description = "const int",
        type = "value"
      },
      KEY_F10 = {
        description = "const int",
        type = "value"
      },
      KEY_F11 = {
        description = "const int",
        type = "value"
      },
      KEY_F12 = {
        description = "const int",
        type = "value"
      },
      KEY_F13 = {
        description = "const int",
        type = "value"
      },
      KEY_F14 = {
        description = "const int",
        type = "value"
      },
      KEY_F15 = {
        description = "const int",
        type = "value"
      },
      KEY_F16 = {
        description = "const int",
        type = "value"
      },
      KEY_F17 = {
        description = "const int",
        type = "value"
      },
      KEY_F18 = {
        description = "const int",
        type = "value"
      },
      KEY_F19 = {
        description = "const int",
        type = "value"
      },
      KEY_F2 = {
        description = "const int",
        type = "value"
      },
      KEY_F20 = {
        description = "const int",
        type = "value"
      },
      KEY_F21 = {
        description = "const int",
        type = "value"
      },
      KEY_F22 = {
        description = "const int",
        type = "value"
      },
      KEY_F23 = {
        description = "const int",
        type = "value"
      },
      KEY_F24 = {
        description = "const int",
        type = "value"
      },
      KEY_F3 = {
        description = "const int",
        type = "value"
      },
      KEY_F4 = {
        description = "const int",
        type = "value"
      },
      KEY_F5 = {
        description = "const int",
        type = "value"
      },
      KEY_F6 = {
        description = "const int",
        type = "value"
      },
      KEY_F7 = {
        description = "const int",
        type = "value"
      },
      KEY_F8 = {
        description = "const int",
        type = "value"
      },
      KEY_F9 = {
        description = "const int",
        type = "value"
      },
      KEY_G = {
        description = "const int",
        type = "value"
      },
      KEY_GUI = {
        description = "const int",
        type = "value"
      },
      KEY_H = {
        description = "const int",
        type = "value"
      },
      KEY_HOME = {
        description = "const int",
        type = "value"
      },
      KEY_I = {
        description = "const int",
        type = "value"
      },
      KEY_INSERT = {
        description = "const int",
        type = "value"
      },
      KEY_J = {
        description = "const int",
        type = "value"
      },
      KEY_K = {
        description = "const int",
        type = "value"
      },
      KEY_KP_0 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_1 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_2 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_3 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_4 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_5 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_6 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_7 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_8 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_9 = {
        description = "const int",
        type = "value"
      },
      KEY_KP_DIVIDE = {
        description = "const int",
        type = "value"
      },
      KEY_KP_ENTER = {
        description = "const int",
        type = "value"
      },
      KEY_KP_MINUS = {
        description = "const int",
        type = "value"
      },
      KEY_KP_MULTIPLY = {
        description = "const int",
        type = "value"
      },
      KEY_KP_PERIOD = {
        description = "const int",
        type = "value"
      },
      KEY_KP_PLUS = {
        description = "const int",
        type = "value"
      },
      KEY_L = {
        description = "const int",
        type = "value"
      },
      KEY_LALT = {
        description = "const int",
        type = "value"
      },
      KEY_LCTRL = {
        description = "const int",
        type = "value"
      },
      KEY_LEFT = {
        description = "const int",
        type = "value"
      },
      KEY_LGUI = {
        description = "const int",
        type = "value"
      },
      KEY_LSHIFT = {
        description = "const int",
        type = "value"
      },
      KEY_M = {
        description = "const int",
        type = "value"
      },
      KEY_N = {
        description = "const int",
        type = "value"
      },
      KEY_NUMLOCKCLEAR = {
        description = "const int",
        type = "value"
      },
      KEY_O = {
        description = "const int",
        type = "value"
      },
      KEY_P = {
        description = "const int",
        type = "value"
      },
      KEY_PAGEDOWN = {
        description = "const int",
        type = "value"
      },
      KEY_PAGEUP = {
        description = "const int",
        type = "value"
      },
      KEY_PAUSE = {
        description = "const int",
        type = "value"
      },
      KEY_PRINTSCREEN = {
        description = "const int",
        type = "value"
      },
      KEY_Q = {
        description = "const int",
        type = "value"
      },
      KEY_R = {
        description = "const int",
        type = "value"
      },
      KEY_RALT = {
        description = "const int",
        type = "value"
      },
      KEY_RCTRL = {
        description = "const int",
        type = "value"
      },
      KEY_RETURN = {
        description = "const int",
        type = "value"
      },
      KEY_RETURN2 = {
        description = "const int",
        type = "value"
      },
      KEY_RGUI = {
        description = "const int",
        type = "value"
      },
      KEY_RIGHT = {
        description = "const int",
        type = "value"
      },
      KEY_RSHIFT = {
        description = "const int",
        type = "value"
      },
      KEY_S = {
        description = "const int",
        type = "value"
      },
      KEY_SCROLLLOCK = {
        description = "const int",
        type = "value"
      },
      KEY_SELECT = {
        description = "const int",
        type = "value"
      },
      KEY_SHIFT = {
        description = "const int",
        type = "value"
      },
      KEY_SPACE = {
        description = "const int",
        type = "value"
      },
      KEY_T = {
        description = "const int",
        type = "value"
      },
      KEY_TAB = {
        description = "const int",
        type = "value"
      },
      KEY_U = {
        description = "const int",
        type = "value"
      },
      KEY_UNKNOWN = {
        description = "const int",
        type = "value"
      },
      KEY_UP = {
        description = "const int",
        type = "value"
      },
      KEY_V = {
        description = "const int",
        type = "value"
      },
      KEY_W = {
        description = "const int",
        type = "value"
      },
      KEY_X = {
        description = "const int",
        type = "value"
      },
      KEY_Y = {
        description = "const int",
        type = "value"
      },
      KEY_Z = {
        description = "const int",
        type = "value"
      },
      LAST_LOCAL_ID = {
        description = "const unsigned",
        type = "value"
      },
      LAST_REPLICATED_ID = {
        description = "const unsigned",
        type = "value"
      },
      LOG_DEBUG = {
        description = "const int",
        type = "value"
      },
      LOG_ERROR = {
        description = "const int",
        type = "value"
      },
      LOG_INFO = {
        description = "const int",
        type = "value"
      },
      LOG_NONE = {
        description = "const int",
        type = "value"
      },
      LOG_WARNING = {
        description = "const int",
        type = "value"
      },
      MASK_BLENDINDICES = {
        description = "const unsigned",
        type = "value"
      },
      MASK_BLENDWEIGHTS = {
        description = "const unsigned",
        type = "value"
      },
      MASK_COLOR = {
        description = "const unsigned",
        type = "value"
      },
      MASK_CUBETEXCOORD1 = {
        description = "const unsigned",
        type = "value"
      },
      MASK_CUBETEXCOORD2 = {
        description = "const unsigned",
        type = "value"
      },
      MASK_INSTANCEMATRIX1 = {
        description = "const unsigned",
        type = "value"
      },
      MASK_INSTANCEMATRIX2 = {
        description = "const unsigned",
        type = "value"
      },
      MASK_INSTANCEMATRIX3 = {
        description = "const unsigned",
        type = "value"
      },
      MASK_NONE = {
        description = "const unsigned",
        type = "value"
      },
      MASK_NORMAL = {
        description = "const unsigned",
        type = "value"
      },
      MASK_OBJECTINDEX = {
        description = "const unsigned",
        type = "value"
      },
      MASK_POSITION = {
        description = "const unsigned",
        type = "value"
      },
      MASK_TANGENT = {
        description = "const unsigned",
        type = "value"
      },
      MASK_TEXCOORD1 = {
        description = "const unsigned",
        type = "value"
      },
      MASK_TEXCOORD2 = {
        description = "const unsigned",
        type = "value"
      },
      MAX_VERTEX_LIGHTS = {
        description = "const int",
        type = "value"
      },
      MOUSEB_LEFT = {
        description = "const int",
        type = "value"
      },
      MOUSEB_MIDDLE = {
        description = "const int",
        type = "value"
      },
      MOUSEB_RIGHT = {
        description = "const int",
        type = "value"
      },
      M_DEGTORAD = {
        description = "const float",
        type = "value"
      },
      M_DEGTORAD_2 = {
        description = "const float",
        type = "value"
      },
      M_EPSILON = {
        description = "const float",
        type = "value"
      },
      M_HALF_PI = {
        description = "const float",
        type = "value"
      },
      M_INFINITY = {
        description = "const float",
        type = "value"
      },
      M_LARGE_EPSILON = {
        description = "const float",
        type = "value"
      },
      M_LARGE_VALUE = {
        description = "const float",
        type = "value"
      },
      M_MAX_FOV = {
        description = "const float",
        type = "value"
      },
      M_MAX_INT = {
        description = "const int",
        type = "value"
      },
      M_MAX_UNSIGNED = {
        description = "const unsigned",
        type = "value"
      },
      M_MIN_INT = {
        description = "const int",
        type = "value"
      },
      M_MIN_NEARCLIP = {
        description = "const float",
        type = "value"
      },
      M_MIN_UNSIGNED = {
        description = "const unsigned",
        type = "value"
      },
      M_PI = {
        description = "const float",
        type = "value"
      },
      M_RADTODEG = {
        description = "const float",
        type = "value"
      },
      NUM_FRUSTUM_PLANES = {
        description = "const unsigned",
        type = "value"
      },
      NUM_FRUSTUM_VERTICES = {
        description = "const unsigned",
        type = "value"
      },
      PIXEL_SIZE = {
        description = "const float",
        type = "value"
      },
      QUALITY_HIGH = {
        description = "const int",
        type = "value"
      },
      QUALITY_LOW = {
        description = "const int",
        type = "value"
      },
      QUALITY_MAX = {
        description = "const int",
        type = "value"
      },
      QUALITY_MEDIUM = {
        description = "const int",
        type = "value"
      },
      QUAL_ALT = {
        description = "const int",
        type = "value"
      },
      QUAL_ANY = {
        description = "const int",
        type = "value"
      },
      QUAL_CTRL = {
        description = "const int",
        type = "value"
      },
      QUAL_SHIFT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_0 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_1 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_3 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_4 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_5 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_6 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_7 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_8 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_9 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_A = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_BACK = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_BOOKMARKS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_FORWARD = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_HOME = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_REFRESH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_SEARCH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AC_STOP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AGAIN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_ALT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_ALTERASE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_APOSTROPHE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_APP1 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_APP2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_APPLICATION = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AUDIOMUTE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AUDIONEXT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AUDIOPLAY = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AUDIOPREV = {
        description = "const int",
        type = "value"
      },
      SCANCODE_AUDIOSTOP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_B = {
        description = "const int",
        type = "value"
      },
      SCANCODE_BACKSLASH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_BACKSPACE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_BRIGHTNESSDOWN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_BRIGHTNESSUP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_C = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CALCULATOR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CANCEL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CAPSLOCK = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CLEAR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CLEARAGAIN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_COMMA = {
        description = "const int",
        type = "value"
      },
      SCANCODE_COMPUTER = {
        description = "const int",
        type = "value"
      },
      SCANCODE_COPY = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CRSEL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CTRL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CURRENCYSUBUNIT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CURRENCYUNIT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_CUT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_D = {
        description = "const int",
        type = "value"
      },
      SCANCODE_DECIMALSEPARATOR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_DELETE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_DISPLAYSWITCH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_DOWN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_E = {
        description = "const int",
        type = "value"
      },
      SCANCODE_EJECT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_END = {
        description = "const int",
        type = "value"
      },
      SCANCODE_EQUALS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_ESCAPE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_EXECUTE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_EXSEL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F1 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F10 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F11 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F12 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F13 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F14 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F15 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F16 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F17 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F18 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F19 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F20 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F21 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F22 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F23 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F24 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F3 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F4 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F5 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F6 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F7 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F8 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_F9 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_FIND = {
        description = "const int",
        type = "value"
      },
      SCANCODE_G = {
        description = "const int",
        type = "value"
      },
      SCANCODE_GRAVE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_GUI = {
        description = "const int",
        type = "value"
      },
      SCANCODE_H = {
        description = "const int",
        type = "value"
      },
      SCANCODE_HELP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_HOME = {
        description = "const int",
        type = "value"
      },
      SCANCODE_I = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INSERT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL1 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL3 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL4 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL5 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL6 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL7 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL8 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_INTERNATIONAL9 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_J = {
        description = "const int",
        type = "value"
      },
      SCANCODE_K = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KBDILLUMDOWN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KBDILLUMTOGGLE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KBDILLUMUP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_0 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_00 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_000 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_1 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_3 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_4 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_5 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_6 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_7 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_8 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_9 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_A = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_AMPERSAND = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_AT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_B = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_BACKSPACE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_BINARY = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_C = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_CLEAR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_CLEARENTRY = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_COLON = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_COMMA = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_D = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_DBLAMPERSAND = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_DBLVERTICALBAR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_DECIMAL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_DIVIDE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_E = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_ENTER = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_EQUALS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_EQUALSAS400 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_EXCLAM = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_F = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_GREATER = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_HASH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_HEXADECIMAL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_LEFTBRACE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_LEFTPAREN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_LESS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMADD = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMCLEAR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMDIVIDE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMMULTIPLY = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMRECALL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMSTORE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MEMSUBTRACT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MINUS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_MULTIPLY = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_OCTAL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_PERCENT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_PERIOD = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_PLUS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_PLUSMINUS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_POWER = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_RIGHTBRACE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_RIGHTPAREN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_SPACE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_TAB = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_VERTICALBAR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_KP_XOR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_L = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LALT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG1 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG3 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG4 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG5 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG6 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG7 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG8 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LANG9 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LCTRL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LEFT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LEFTBRACKET = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LGUI = {
        description = "const int",
        type = "value"
      },
      SCANCODE_LSHIFT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_M = {
        description = "const int",
        type = "value"
      },
      SCANCODE_MAIL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_MEDIASELECT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_MENU = {
        description = "const int",
        type = "value"
      },
      SCANCODE_MINUS = {
        description = "const int",
        type = "value"
      },
      SCANCODE_MODE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_MUTE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_N = {
        description = "const int",
        type = "value"
      },
      SCANCODE_NONUSBACKSLASH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_NONUSHASH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_NUMLOCKCLEAR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_O = {
        description = "const int",
        type = "value"
      },
      SCANCODE_OPER = {
        description = "const int",
        type = "value"
      },
      SCANCODE_OUT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_P = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PAGEDOWN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PAGEUP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PASTE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PAUSE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PERIOD = {
        description = "const int",
        type = "value"
      },
      SCANCODE_POWER = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PRINTSCREEN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_PRIOR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_Q = {
        description = "const int",
        type = "value"
      },
      SCANCODE_R = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RALT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RCTRL = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RETURN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RETURN2 = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RGUI = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RIGHT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RIGHTBRACKET = {
        description = "const int",
        type = "value"
      },
      SCANCODE_RSHIFT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_S = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SCROLLLOCK = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SELECT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SEMICOLON = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SEPARATOR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SHIFT = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SLASH = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SLEEP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SPACE = {
        description = "const int",
        type = "value"
      },
      SCANCODE_STOP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_SYSREQ = {
        description = "const int",
        type = "value"
      },
      SCANCODE_T = {
        description = "const int",
        type = "value"
      },
      SCANCODE_TAB = {
        description = "const int",
        type = "value"
      },
      SCANCODE_THOUSANDSSEPARATOR = {
        description = "const int",
        type = "value"
      },
      SCANCODE_U = {
        description = "const int",
        type = "value"
      },
      SCANCODE_UNDO = {
        description = "const int",
        type = "value"
      },
      SCANCODE_UNKNOWN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_UP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_V = {
        description = "const int",
        type = "value"
      },
      SCANCODE_VOLUMEDOWN = {
        description = "const int",
        type = "value"
      },
      SCANCODE_VOLUMEUP = {
        description = "const int",
        type = "value"
      },
      SCANCODE_W = {
        description = "const int",
        type = "value"
      },
      SCANCODE_WWW = {
        description = "const int",
        type = "value"
      },
      SCANCODE_X = {
        description = "const int",
        type = "value"
      },
      SCANCODE_Y = {
        description = "const int",
        type = "value"
      },
      SCANCODE_Z = {
        description = "const int",
        type = "value"
      },
      SCAN_DIRS = {
        description = "const unsigned",
        type = "value"
      },
      SCAN_FILES = {
        description = "const unsigned",
        type = "value"
      },
      SCAN_HIDDEN = {
        description = "const unsigned",
        type = "value"
      },
      SOUND_AMBIENT = {
        description = "const String",
        type = "value"
      },
      SOUND_EFFECT = {
        description = "const String",
        type = "value"
      },
      SOUND_MASTER = {
        description = "const String",
        type = "value"
      },
      SOUND_MUSIC = {
        description = "const String",
        type = "value"
      },
      SOUND_VOICE = {
        description = "const String",
        type = "value"
      },
      VO_DISABLE_OCCLUSION = {
        description = "const unsigned",
        type = "value"
      },
      VO_DISABLE_SHADOWS = {
        description = "const unsigned",
        type = "value"
      },
      VO_LOW_MATERIAL_QUALITY = {
        description = "const unsigned",
        type = "value"
      },
      VO_NONE = {
        description = "const unsigned",
        type = "value"
      },
}

return {
  name = "Urho3D",
  description = "Implements integration with Urho3D game engine.",
  author = "Danny Boisvert (https://github.com/silverkorn)",
  version = 0.41,
  dependencies = 1.40,

  onRegister = function(self)
     ide:AddInterpreter("urho3d", interpreter)
     ide:AddAPI("lua", "urho3d", api)
  end,

  onUnRegister = function(self)
     ide:RemoveInterpreter("urho3d")
     ide:RemoveAPI("lua", "urho3d")
  end,
}
